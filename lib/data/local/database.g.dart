// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'database.dart';

// ignore_for_file: type=lint
class $LocalUsersTable extends LocalUsers
    with TableInfo<$LocalUsersTable, LocalUser> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LocalUsersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _usernameMeta =
      const VerificationMeta('username');
  @override
  late final GeneratedColumn<String> username = GeneratedColumn<String>(
      'username', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 3, maxTextLength: 64),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _remoteIdMeta =
      const VerificationMeta('remoteId');
  @override
  late final GeneratedColumn<String> remoteId = GeneratedColumn<String>(
      'remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _pinHashMeta =
      const VerificationMeta('pinHash');
  @override
  late final GeneratedColumn<String> pinHash = GeneratedColumn<String>(
      'pin_hash', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _pinSaltMeta =
      const VerificationMeta('pinSalt');
  @override
  late final GeneratedColumn<String> pinSalt = GeneratedColumn<String>(
      'pin_salt', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _pinUpdatedAtMeta =
      const VerificationMeta('pinUpdatedAt');
  @override
  late final GeneratedColumn<DateTime> pinUpdatedAt = GeneratedColumn<DateTime>(
      'pin_updated_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _isDirtyMeta =
      const VerificationMeta('isDirty');
  @override
  late final GeneratedColumn<bool> isDirty = GeneratedColumn<bool>(
      'is_dirty', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_dirty" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _syncedAtMeta =
      const VerificationMeta('syncedAt');
  @override
  late final GeneratedColumn<DateTime> syncedAt = GeneratedColumn<DateTime>(
      'synced_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        username,
        remoteId,
        pinHash,
        pinSalt,
        pinUpdatedAt,
        isDirty,
        isDeleted,
        syncedAt,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'local_users';
  @override
  VerificationContext validateIntegrity(Insertable<LocalUser> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('username')) {
      context.handle(_usernameMeta,
          username.isAcceptableOrUnknown(data['username']!, _usernameMeta));
    } else if (isInserting) {
      context.missing(_usernameMeta);
    }
    if (data.containsKey('remote_id')) {
      context.handle(_remoteIdMeta,
          remoteId.isAcceptableOrUnknown(data['remote_id']!, _remoteIdMeta));
    }
    if (data.containsKey('pin_hash')) {
      context.handle(_pinHashMeta,
          pinHash.isAcceptableOrUnknown(data['pin_hash']!, _pinHashMeta));
    }
    if (data.containsKey('pin_salt')) {
      context.handle(_pinSaltMeta,
          pinSalt.isAcceptableOrUnknown(data['pin_salt']!, _pinSaltMeta));
    }
    if (data.containsKey('pin_updated_at')) {
      context.handle(
          _pinUpdatedAtMeta,
          pinUpdatedAt.isAcceptableOrUnknown(
              data['pin_updated_at']!, _pinUpdatedAtMeta));
    }
    if (data.containsKey('is_dirty')) {
      context.handle(_isDirtyMeta,
          isDirty.isAcceptableOrUnknown(data['is_dirty']!, _isDirtyMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('synced_at')) {
      context.handle(_syncedAtMeta,
          syncedAt.isAcceptableOrUnknown(data['synced_at']!, _syncedAtMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  LocalUser map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LocalUser(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      username: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}username'])!,
      remoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}remote_id']),
      pinHash: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}pin_hash']),
      pinSalt: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}pin_salt']),
      pinUpdatedAt: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}pin_updated_at']),
      isDirty: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_dirty'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      syncedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}synced_at']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $LocalUsersTable createAlias(String alias) {
    return $LocalUsersTable(attachedDatabase, alias);
  }
}

class LocalUser extends DataClass implements Insertable<LocalUser> {
  final int id;
  final String uuid;
  final String username;
  final String? remoteId;
  final String? pinHash;
  final String? pinSalt;
  final DateTime? pinUpdatedAt;
  final bool isDirty;
  final bool isDeleted;
  final DateTime? syncedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const LocalUser(
      {required this.id,
      required this.uuid,
      required this.username,
      this.remoteId,
      this.pinHash,
      this.pinSalt,
      this.pinUpdatedAt,
      required this.isDirty,
      required this.isDeleted,
      this.syncedAt,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['username'] = Variable<String>(username);
    if (!nullToAbsent || remoteId != null) {
      map['remote_id'] = Variable<String>(remoteId);
    }
    if (!nullToAbsent || pinHash != null) {
      map['pin_hash'] = Variable<String>(pinHash);
    }
    if (!nullToAbsent || pinSalt != null) {
      map['pin_salt'] = Variable<String>(pinSalt);
    }
    if (!nullToAbsent || pinUpdatedAt != null) {
      map['pin_updated_at'] = Variable<DateTime>(pinUpdatedAt);
    }
    map['is_dirty'] = Variable<bool>(isDirty);
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || syncedAt != null) {
      map['synced_at'] = Variable<DateTime>(syncedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  LocalUsersCompanion toCompanion(bool nullToAbsent) {
    return LocalUsersCompanion(
      id: Value(id),
      uuid: Value(uuid),
      username: Value(username),
      remoteId: remoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(remoteId),
      pinHash: pinHash == null && nullToAbsent
          ? const Value.absent()
          : Value(pinHash),
      pinSalt: pinSalt == null && nullToAbsent
          ? const Value.absent()
          : Value(pinSalt),
      pinUpdatedAt: pinUpdatedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(pinUpdatedAt),
      isDirty: Value(isDirty),
      isDeleted: Value(isDeleted),
      syncedAt: syncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory LocalUser.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return LocalUser(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      username: serializer.fromJson<String>(json['username']),
      remoteId: serializer.fromJson<String?>(json['remoteId']),
      pinHash: serializer.fromJson<String?>(json['pinHash']),
      pinSalt: serializer.fromJson<String?>(json['pinSalt']),
      pinUpdatedAt: serializer.fromJson<DateTime?>(json['pinUpdatedAt']),
      isDirty: serializer.fromJson<bool>(json['isDirty']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      syncedAt: serializer.fromJson<DateTime?>(json['syncedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'username': serializer.toJson<String>(username),
      'remoteId': serializer.toJson<String?>(remoteId),
      'pinHash': serializer.toJson<String?>(pinHash),
      'pinSalt': serializer.toJson<String?>(pinSalt),
      'pinUpdatedAt': serializer.toJson<DateTime?>(pinUpdatedAt),
      'isDirty': serializer.toJson<bool>(isDirty),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'syncedAt': serializer.toJson<DateTime?>(syncedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  LocalUser copyWith(
          {int? id,
          String? uuid,
          String? username,
          Value<String?> remoteId = const Value.absent(),
          Value<String?> pinHash = const Value.absent(),
          Value<String?> pinSalt = const Value.absent(),
          Value<DateTime?> pinUpdatedAt = const Value.absent(),
          bool? isDirty,
          bool? isDeleted,
          Value<DateTime?> syncedAt = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      LocalUser(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        username: username ?? this.username,
        remoteId: remoteId.present ? remoteId.value : this.remoteId,
        pinHash: pinHash.present ? pinHash.value : this.pinHash,
        pinSalt: pinSalt.present ? pinSalt.value : this.pinSalt,
        pinUpdatedAt:
            pinUpdatedAt.present ? pinUpdatedAt.value : this.pinUpdatedAt,
        isDirty: isDirty ?? this.isDirty,
        isDeleted: isDeleted ?? this.isDeleted,
        syncedAt: syncedAt.present ? syncedAt.value : this.syncedAt,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  LocalUser copyWithCompanion(LocalUsersCompanion data) {
    return LocalUser(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      username: data.username.present ? data.username.value : this.username,
      remoteId: data.remoteId.present ? data.remoteId.value : this.remoteId,
      pinHash: data.pinHash.present ? data.pinHash.value : this.pinHash,
      pinSalt: data.pinSalt.present ? data.pinSalt.value : this.pinSalt,
      pinUpdatedAt: data.pinUpdatedAt.present
          ? data.pinUpdatedAt.value
          : this.pinUpdatedAt,
      isDirty: data.isDirty.present ? data.isDirty.value : this.isDirty,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      syncedAt: data.syncedAt.present ? data.syncedAt.value : this.syncedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('LocalUser(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('username: $username, ')
          ..write('remoteId: $remoteId, ')
          ..write('pinHash: $pinHash, ')
          ..write('pinSalt: $pinSalt, ')
          ..write('pinUpdatedAt: $pinUpdatedAt, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      username,
      remoteId,
      pinHash,
      pinSalt,
      pinUpdatedAt,
      isDirty,
      isDeleted,
      syncedAt,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LocalUser &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.username == this.username &&
          other.remoteId == this.remoteId &&
          other.pinHash == this.pinHash &&
          other.pinSalt == this.pinSalt &&
          other.pinUpdatedAt == this.pinUpdatedAt &&
          other.isDirty == this.isDirty &&
          other.isDeleted == this.isDeleted &&
          other.syncedAt == this.syncedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class LocalUsersCompanion extends UpdateCompanion<LocalUser> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> username;
  final Value<String?> remoteId;
  final Value<String?> pinHash;
  final Value<String?> pinSalt;
  final Value<DateTime?> pinUpdatedAt;
  final Value<bool> isDirty;
  final Value<bool> isDeleted;
  final Value<DateTime?> syncedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const LocalUsersCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.username = const Value.absent(),
    this.remoteId = const Value.absent(),
    this.pinHash = const Value.absent(),
    this.pinSalt = const Value.absent(),
    this.pinUpdatedAt = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  LocalUsersCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String username,
    this.remoteId = const Value.absent(),
    this.pinHash = const Value.absent(),
    this.pinSalt = const Value.absent(),
    this.pinUpdatedAt = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        username = Value(username);
  static Insertable<LocalUser> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? username,
    Expression<String>? remoteId,
    Expression<String>? pinHash,
    Expression<String>? pinSalt,
    Expression<DateTime>? pinUpdatedAt,
    Expression<bool>? isDirty,
    Expression<bool>? isDeleted,
    Expression<DateTime>? syncedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (username != null) 'username': username,
      if (remoteId != null) 'remote_id': remoteId,
      if (pinHash != null) 'pin_hash': pinHash,
      if (pinSalt != null) 'pin_salt': pinSalt,
      if (pinUpdatedAt != null) 'pin_updated_at': pinUpdatedAt,
      if (isDirty != null) 'is_dirty': isDirty,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (syncedAt != null) 'synced_at': syncedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  LocalUsersCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? username,
      Value<String?>? remoteId,
      Value<String?>? pinHash,
      Value<String?>? pinSalt,
      Value<DateTime?>? pinUpdatedAt,
      Value<bool>? isDirty,
      Value<bool>? isDeleted,
      Value<DateTime?>? syncedAt,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return LocalUsersCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      username: username ?? this.username,
      remoteId: remoteId ?? this.remoteId,
      pinHash: pinHash ?? this.pinHash,
      pinSalt: pinSalt ?? this.pinSalt,
      pinUpdatedAt: pinUpdatedAt ?? this.pinUpdatedAt,
      isDirty: isDirty ?? this.isDirty,
      isDeleted: isDeleted ?? this.isDeleted,
      syncedAt: syncedAt ?? this.syncedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (username.present) {
      map['username'] = Variable<String>(username.value);
    }
    if (remoteId.present) {
      map['remote_id'] = Variable<String>(remoteId.value);
    }
    if (pinHash.present) {
      map['pin_hash'] = Variable<String>(pinHash.value);
    }
    if (pinSalt.present) {
      map['pin_salt'] = Variable<String>(pinSalt.value);
    }
    if (pinUpdatedAt.present) {
      map['pin_updated_at'] = Variable<DateTime>(pinUpdatedAt.value);
    }
    if (isDirty.present) {
      map['is_dirty'] = Variable<bool>(isDirty.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (syncedAt.present) {
      map['synced_at'] = Variable<DateTime>(syncedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LocalUsersCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('username: $username, ')
          ..write('remoteId: $remoteId, ')
          ..write('pinHash: $pinHash, ')
          ..write('pinSalt: $pinSalt, ')
          ..write('pinUpdatedAt: $pinUpdatedAt, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $BooksTable extends Books with TableInfo<$BooksTable, Book> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BooksTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _remoteIdMeta =
      const VerificationMeta('remoteId');
  @override
  late final GeneratedColumn<String> remoteId = GeneratedColumn<String>(
      'remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _ownerUserIdMeta =
      const VerificationMeta('ownerUserId');
  @override
  late final GeneratedColumn<int> ownerUserId = GeneratedColumn<int>(
      'owner_user_id', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES local_users (id)'));
  static const VerificationMeta _ownerRemoteIdMeta =
      const VerificationMeta('ownerRemoteId');
  @override
  late final GeneratedColumn<String> ownerRemoteId = GeneratedColumn<String>(
      'owner_remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
      'title', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 255),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _authorMeta = const VerificationMeta('author');
  @override
  late final GeneratedColumn<String> author = GeneratedColumn<String>(
      'author', aliasedName, true,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 255),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _isbnMeta = const VerificationMeta('isbn');
  @override
  late final GeneratedColumn<String> isbn = GeneratedColumn<String>(
      'isbn', aliasedName, true,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 10, maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _barcodeMeta =
      const VerificationMeta('barcode');
  @override
  late final GeneratedColumn<String> barcode = GeneratedColumn<String>(
      'barcode', aliasedName, true,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 64),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _coverPathMeta =
      const VerificationMeta('coverPath');
  @override
  late final GeneratedColumn<String> coverPath = GeneratedColumn<String>(
      'cover_path', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('available'));
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _readingStatusMeta =
      const VerificationMeta('readingStatus');
  @override
  late final GeneratedColumn<String> readingStatus = GeneratedColumn<String>(
      'reading_status', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 32),
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('pending'));
  static const VerificationMeta _isReadMeta = const VerificationMeta('isRead');
  @override
  late final GeneratedColumn<bool> isRead = GeneratedColumn<bool>(
      'is_read', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_read" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _readAtMeta = const VerificationMeta('readAt');
  @override
  late final GeneratedColumn<DateTime> readAt = GeneratedColumn<DateTime>(
      'read_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _isBorrowedExternalMeta =
      const VerificationMeta('isBorrowedExternal');
  @override
  late final GeneratedColumn<bool> isBorrowedExternal = GeneratedColumn<bool>(
      'is_borrowed_external', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_borrowed_external" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _externalLenderNameMeta =
      const VerificationMeta('externalLenderName');
  @override
  late final GeneratedColumn<String> externalLenderName =
      GeneratedColumn<String>('external_lender_name', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _genreMeta = const VerificationMeta('genre');
  @override
  late final GeneratedColumn<String> genre = GeneratedColumn<String>(
      'genre', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isPhysicalMeta =
      const VerificationMeta('isPhysical');
  @override
  late final GeneratedColumn<bool> isPhysical = GeneratedColumn<bool>(
      'is_physical', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_physical" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _pageCountMeta =
      const VerificationMeta('pageCount');
  @override
  late final GeneratedColumn<int> pageCount = GeneratedColumn<int>(
      'page_count', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _publicationYearMeta =
      const VerificationMeta('publicationYear');
  @override
  late final GeneratedColumn<int> publicationYear = GeneratedColumn<int>(
      'publication_year', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _isDirtyMeta =
      const VerificationMeta('isDirty');
  @override
  late final GeneratedColumn<bool> isDirty = GeneratedColumn<bool>(
      'is_dirty', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_dirty" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _syncedAtMeta =
      const VerificationMeta('syncedAt');
  @override
  late final GeneratedColumn<DateTime> syncedAt = GeneratedColumn<DateTime>(
      'synced_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        remoteId,
        ownerUserId,
        ownerRemoteId,
        title,
        author,
        isbn,
        barcode,
        coverPath,
        status,
        description,
        readingStatus,
        isRead,
        readAt,
        isBorrowedExternal,
        externalLenderName,
        genre,
        isPhysical,
        pageCount,
        publicationYear,
        isDirty,
        isDeleted,
        syncedAt,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'books';
  @override
  VerificationContext validateIntegrity(Insertable<Book> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('remote_id')) {
      context.handle(_remoteIdMeta,
          remoteId.isAcceptableOrUnknown(data['remote_id']!, _remoteIdMeta));
    }
    if (data.containsKey('owner_user_id')) {
      context.handle(
          _ownerUserIdMeta,
          ownerUserId.isAcceptableOrUnknown(
              data['owner_user_id']!, _ownerUserIdMeta));
    }
    if (data.containsKey('owner_remote_id')) {
      context.handle(
          _ownerRemoteIdMeta,
          ownerRemoteId.isAcceptableOrUnknown(
              data['owner_remote_id']!, _ownerRemoteIdMeta));
    }
    if (data.containsKey('title')) {
      context.handle(
          _titleMeta, title.isAcceptableOrUnknown(data['title']!, _titleMeta));
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('author')) {
      context.handle(_authorMeta,
          author.isAcceptableOrUnknown(data['author']!, _authorMeta));
    }
    if (data.containsKey('isbn')) {
      context.handle(
          _isbnMeta, isbn.isAcceptableOrUnknown(data['isbn']!, _isbnMeta));
    }
    if (data.containsKey('barcode')) {
      context.handle(_barcodeMeta,
          barcode.isAcceptableOrUnknown(data['barcode']!, _barcodeMeta));
    }
    if (data.containsKey('cover_path')) {
      context.handle(_coverPathMeta,
          coverPath.isAcceptableOrUnknown(data['cover_path']!, _coverPathMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    if (data.containsKey('reading_status')) {
      context.handle(
          _readingStatusMeta,
          readingStatus.isAcceptableOrUnknown(
              data['reading_status']!, _readingStatusMeta));
    }
    if (data.containsKey('is_read')) {
      context.handle(_isReadMeta,
          isRead.isAcceptableOrUnknown(data['is_read']!, _isReadMeta));
    }
    if (data.containsKey('read_at')) {
      context.handle(_readAtMeta,
          readAt.isAcceptableOrUnknown(data['read_at']!, _readAtMeta));
    }
    if (data.containsKey('is_borrowed_external')) {
      context.handle(
          _isBorrowedExternalMeta,
          isBorrowedExternal.isAcceptableOrUnknown(
              data['is_borrowed_external']!, _isBorrowedExternalMeta));
    }
    if (data.containsKey('external_lender_name')) {
      context.handle(
          _externalLenderNameMeta,
          externalLenderName.isAcceptableOrUnknown(
              data['external_lender_name']!, _externalLenderNameMeta));
    }
    if (data.containsKey('genre')) {
      context.handle(
          _genreMeta, genre.isAcceptableOrUnknown(data['genre']!, _genreMeta));
    }
    if (data.containsKey('is_physical')) {
      context.handle(
          _isPhysicalMeta,
          isPhysical.isAcceptableOrUnknown(
              data['is_physical']!, _isPhysicalMeta));
    }
    if (data.containsKey('page_count')) {
      context.handle(_pageCountMeta,
          pageCount.isAcceptableOrUnknown(data['page_count']!, _pageCountMeta));
    }
    if (data.containsKey('publication_year')) {
      context.handle(
          _publicationYearMeta,
          publicationYear.isAcceptableOrUnknown(
              data['publication_year']!, _publicationYearMeta));
    }
    if (data.containsKey('is_dirty')) {
      context.handle(_isDirtyMeta,
          isDirty.isAcceptableOrUnknown(data['is_dirty']!, _isDirtyMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('synced_at')) {
      context.handle(_syncedAtMeta,
          syncedAt.isAcceptableOrUnknown(data['synced_at']!, _syncedAtMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Book map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Book(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      remoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}remote_id']),
      ownerUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}owner_user_id']),
      ownerRemoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}owner_remote_id']),
      title: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}title'])!,
      author: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}author']),
      isbn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}isbn']),
      barcode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}barcode']),
      coverPath: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}cover_path']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
      readingStatus: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reading_status'])!,
      isRead: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_read'])!,
      readAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}read_at']),
      isBorrowedExternal: attachedDatabase.typeMapping.read(
          DriftSqlType.bool, data['${effectivePrefix}is_borrowed_external'])!,
      externalLenderName: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}external_lender_name']),
      genre: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}genre']),
      isPhysical: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_physical'])!,
      pageCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}page_count']),
      publicationYear: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}publication_year']),
      isDirty: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_dirty'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      syncedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}synced_at']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $BooksTable createAlias(String alias) {
    return $BooksTable(attachedDatabase, alias);
  }
}

class Book extends DataClass implements Insertable<Book> {
  final int id;
  final String uuid;
  final String? remoteId;
  final int? ownerUserId;
  final String? ownerRemoteId;
  final String title;
  final String? author;
  final String? isbn;
  final String? barcode;
  final String? coverPath;
  final String status;
  final String? description;
  final String readingStatus;
  final bool isRead;
  final DateTime? readAt;
  final bool isBorrowedExternal;
  final String? externalLenderName;
  final String? genre;
  final bool isPhysical;
  final int? pageCount;
  final int? publicationYear;
  final bool isDirty;
  final bool isDeleted;
  final DateTime? syncedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Book(
      {required this.id,
      required this.uuid,
      this.remoteId,
      this.ownerUserId,
      this.ownerRemoteId,
      required this.title,
      this.author,
      this.isbn,
      this.barcode,
      this.coverPath,
      required this.status,
      this.description,
      required this.readingStatus,
      required this.isRead,
      this.readAt,
      required this.isBorrowedExternal,
      this.externalLenderName,
      this.genre,
      required this.isPhysical,
      this.pageCount,
      this.publicationYear,
      required this.isDirty,
      required this.isDeleted,
      this.syncedAt,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    if (!nullToAbsent || remoteId != null) {
      map['remote_id'] = Variable<String>(remoteId);
    }
    if (!nullToAbsent || ownerUserId != null) {
      map['owner_user_id'] = Variable<int>(ownerUserId);
    }
    if (!nullToAbsent || ownerRemoteId != null) {
      map['owner_remote_id'] = Variable<String>(ownerRemoteId);
    }
    map['title'] = Variable<String>(title);
    if (!nullToAbsent || author != null) {
      map['author'] = Variable<String>(author);
    }
    if (!nullToAbsent || isbn != null) {
      map['isbn'] = Variable<String>(isbn);
    }
    if (!nullToAbsent || barcode != null) {
      map['barcode'] = Variable<String>(barcode);
    }
    if (!nullToAbsent || coverPath != null) {
      map['cover_path'] = Variable<String>(coverPath);
    }
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['reading_status'] = Variable<String>(readingStatus);
    map['is_read'] = Variable<bool>(isRead);
    if (!nullToAbsent || readAt != null) {
      map['read_at'] = Variable<DateTime>(readAt);
    }
    map['is_borrowed_external'] = Variable<bool>(isBorrowedExternal);
    if (!nullToAbsent || externalLenderName != null) {
      map['external_lender_name'] = Variable<String>(externalLenderName);
    }
    if (!nullToAbsent || genre != null) {
      map['genre'] = Variable<String>(genre);
    }
    map['is_physical'] = Variable<bool>(isPhysical);
    if (!nullToAbsent || pageCount != null) {
      map['page_count'] = Variable<int>(pageCount);
    }
    if (!nullToAbsent || publicationYear != null) {
      map['publication_year'] = Variable<int>(publicationYear);
    }
    map['is_dirty'] = Variable<bool>(isDirty);
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || syncedAt != null) {
      map['synced_at'] = Variable<DateTime>(syncedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  BooksCompanion toCompanion(bool nullToAbsent) {
    return BooksCompanion(
      id: Value(id),
      uuid: Value(uuid),
      remoteId: remoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(remoteId),
      ownerUserId: ownerUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(ownerUserId),
      ownerRemoteId: ownerRemoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(ownerRemoteId),
      title: Value(title),
      author:
          author == null && nullToAbsent ? const Value.absent() : Value(author),
      isbn: isbn == null && nullToAbsent ? const Value.absent() : Value(isbn),
      barcode: barcode == null && nullToAbsent
          ? const Value.absent()
          : Value(barcode),
      coverPath: coverPath == null && nullToAbsent
          ? const Value.absent()
          : Value(coverPath),
      status: Value(status),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      readingStatus: Value(readingStatus),
      isRead: Value(isRead),
      readAt:
          readAt == null && nullToAbsent ? const Value.absent() : Value(readAt),
      isBorrowedExternal: Value(isBorrowedExternal),
      externalLenderName: externalLenderName == null && nullToAbsent
          ? const Value.absent()
          : Value(externalLenderName),
      genre:
          genre == null && nullToAbsent ? const Value.absent() : Value(genre),
      isPhysical: Value(isPhysical),
      pageCount: pageCount == null && nullToAbsent
          ? const Value.absent()
          : Value(pageCount),
      publicationYear: publicationYear == null && nullToAbsent
          ? const Value.absent()
          : Value(publicationYear),
      isDirty: Value(isDirty),
      isDeleted: Value(isDeleted),
      syncedAt: syncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Book.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Book(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      remoteId: serializer.fromJson<String?>(json['remoteId']),
      ownerUserId: serializer.fromJson<int?>(json['ownerUserId']),
      ownerRemoteId: serializer.fromJson<String?>(json['ownerRemoteId']),
      title: serializer.fromJson<String>(json['title']),
      author: serializer.fromJson<String?>(json['author']),
      isbn: serializer.fromJson<String?>(json['isbn']),
      barcode: serializer.fromJson<String?>(json['barcode']),
      coverPath: serializer.fromJson<String?>(json['coverPath']),
      status: serializer.fromJson<String>(json['status']),
      description: serializer.fromJson<String?>(json['description']),
      readingStatus: serializer.fromJson<String>(json['readingStatus']),
      isRead: serializer.fromJson<bool>(json['isRead']),
      readAt: serializer.fromJson<DateTime?>(json['readAt']),
      isBorrowedExternal: serializer.fromJson<bool>(json['isBorrowedExternal']),
      externalLenderName:
          serializer.fromJson<String?>(json['externalLenderName']),
      genre: serializer.fromJson<String?>(json['genre']),
      isPhysical: serializer.fromJson<bool>(json['isPhysical']),
      pageCount: serializer.fromJson<int?>(json['pageCount']),
      publicationYear: serializer.fromJson<int?>(json['publicationYear']),
      isDirty: serializer.fromJson<bool>(json['isDirty']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      syncedAt: serializer.fromJson<DateTime?>(json['syncedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'remoteId': serializer.toJson<String?>(remoteId),
      'ownerUserId': serializer.toJson<int?>(ownerUserId),
      'ownerRemoteId': serializer.toJson<String?>(ownerRemoteId),
      'title': serializer.toJson<String>(title),
      'author': serializer.toJson<String?>(author),
      'isbn': serializer.toJson<String?>(isbn),
      'barcode': serializer.toJson<String?>(barcode),
      'coverPath': serializer.toJson<String?>(coverPath),
      'status': serializer.toJson<String>(status),
      'description': serializer.toJson<String?>(description),
      'readingStatus': serializer.toJson<String>(readingStatus),
      'isRead': serializer.toJson<bool>(isRead),
      'readAt': serializer.toJson<DateTime?>(readAt),
      'isBorrowedExternal': serializer.toJson<bool>(isBorrowedExternal),
      'externalLenderName': serializer.toJson<String?>(externalLenderName),
      'genre': serializer.toJson<String?>(genre),
      'isPhysical': serializer.toJson<bool>(isPhysical),
      'pageCount': serializer.toJson<int?>(pageCount),
      'publicationYear': serializer.toJson<int?>(publicationYear),
      'isDirty': serializer.toJson<bool>(isDirty),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'syncedAt': serializer.toJson<DateTime?>(syncedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  Book copyWith(
          {int? id,
          String? uuid,
          Value<String?> remoteId = const Value.absent(),
          Value<int?> ownerUserId = const Value.absent(),
          Value<String?> ownerRemoteId = const Value.absent(),
          String? title,
          Value<String?> author = const Value.absent(),
          Value<String?> isbn = const Value.absent(),
          Value<String?> barcode = const Value.absent(),
          Value<String?> coverPath = const Value.absent(),
          String? status,
          Value<String?> description = const Value.absent(),
          String? readingStatus,
          bool? isRead,
          Value<DateTime?> readAt = const Value.absent(),
          bool? isBorrowedExternal,
          Value<String?> externalLenderName = const Value.absent(),
          Value<String?> genre = const Value.absent(),
          bool? isPhysical,
          Value<int?> pageCount = const Value.absent(),
          Value<int?> publicationYear = const Value.absent(),
          bool? isDirty,
          bool? isDeleted,
          Value<DateTime?> syncedAt = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      Book(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        remoteId: remoteId.present ? remoteId.value : this.remoteId,
        ownerUserId: ownerUserId.present ? ownerUserId.value : this.ownerUserId,
        ownerRemoteId:
            ownerRemoteId.present ? ownerRemoteId.value : this.ownerRemoteId,
        title: title ?? this.title,
        author: author.present ? author.value : this.author,
        isbn: isbn.present ? isbn.value : this.isbn,
        barcode: barcode.present ? barcode.value : this.barcode,
        coverPath: coverPath.present ? coverPath.value : this.coverPath,
        status: status ?? this.status,
        description: description.present ? description.value : this.description,
        readingStatus: readingStatus ?? this.readingStatus,
        isRead: isRead ?? this.isRead,
        readAt: readAt.present ? readAt.value : this.readAt,
        isBorrowedExternal: isBorrowedExternal ?? this.isBorrowedExternal,
        externalLenderName: externalLenderName.present
            ? externalLenderName.value
            : this.externalLenderName,
        genre: genre.present ? genre.value : this.genre,
        isPhysical: isPhysical ?? this.isPhysical,
        pageCount: pageCount.present ? pageCount.value : this.pageCount,
        publicationYear: publicationYear.present
            ? publicationYear.value
            : this.publicationYear,
        isDirty: isDirty ?? this.isDirty,
        isDeleted: isDeleted ?? this.isDeleted,
        syncedAt: syncedAt.present ? syncedAt.value : this.syncedAt,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  Book copyWithCompanion(BooksCompanion data) {
    return Book(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      remoteId: data.remoteId.present ? data.remoteId.value : this.remoteId,
      ownerUserId:
          data.ownerUserId.present ? data.ownerUserId.value : this.ownerUserId,
      ownerRemoteId: data.ownerRemoteId.present
          ? data.ownerRemoteId.value
          : this.ownerRemoteId,
      title: data.title.present ? data.title.value : this.title,
      author: data.author.present ? data.author.value : this.author,
      isbn: data.isbn.present ? data.isbn.value : this.isbn,
      barcode: data.barcode.present ? data.barcode.value : this.barcode,
      coverPath: data.coverPath.present ? data.coverPath.value : this.coverPath,
      status: data.status.present ? data.status.value : this.status,
      description:
          data.description.present ? data.description.value : this.description,
      readingStatus: data.readingStatus.present
          ? data.readingStatus.value
          : this.readingStatus,
      isRead: data.isRead.present ? data.isRead.value : this.isRead,
      readAt: data.readAt.present ? data.readAt.value : this.readAt,
      isBorrowedExternal: data.isBorrowedExternal.present
          ? data.isBorrowedExternal.value
          : this.isBorrowedExternal,
      externalLenderName: data.externalLenderName.present
          ? data.externalLenderName.value
          : this.externalLenderName,
      genre: data.genre.present ? data.genre.value : this.genre,
      isPhysical:
          data.isPhysical.present ? data.isPhysical.value : this.isPhysical,
      pageCount: data.pageCount.present ? data.pageCount.value : this.pageCount,
      publicationYear: data.publicationYear.present
          ? data.publicationYear.value
          : this.publicationYear,
      isDirty: data.isDirty.present ? data.isDirty.value : this.isDirty,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      syncedAt: data.syncedAt.present ? data.syncedAt.value : this.syncedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Book(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('ownerUserId: $ownerUserId, ')
          ..write('ownerRemoteId: $ownerRemoteId, ')
          ..write('title: $title, ')
          ..write('author: $author, ')
          ..write('isbn: $isbn, ')
          ..write('barcode: $barcode, ')
          ..write('coverPath: $coverPath, ')
          ..write('status: $status, ')
          ..write('description: $description, ')
          ..write('readingStatus: $readingStatus, ')
          ..write('isRead: $isRead, ')
          ..write('readAt: $readAt, ')
          ..write('isBorrowedExternal: $isBorrowedExternal, ')
          ..write('externalLenderName: $externalLenderName, ')
          ..write('genre: $genre, ')
          ..write('isPhysical: $isPhysical, ')
          ..write('pageCount: $pageCount, ')
          ..write('publicationYear: $publicationYear, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        uuid,
        remoteId,
        ownerUserId,
        ownerRemoteId,
        title,
        author,
        isbn,
        barcode,
        coverPath,
        status,
        description,
        readingStatus,
        isRead,
        readAt,
        isBorrowedExternal,
        externalLenderName,
        genre,
        isPhysical,
        pageCount,
        publicationYear,
        isDirty,
        isDeleted,
        syncedAt,
        createdAt,
        updatedAt
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Book &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.remoteId == this.remoteId &&
          other.ownerUserId == this.ownerUserId &&
          other.ownerRemoteId == this.ownerRemoteId &&
          other.title == this.title &&
          other.author == this.author &&
          other.isbn == this.isbn &&
          other.barcode == this.barcode &&
          other.coverPath == this.coverPath &&
          other.status == this.status &&
          other.description == this.description &&
          other.readingStatus == this.readingStatus &&
          other.isRead == this.isRead &&
          other.readAt == this.readAt &&
          other.isBorrowedExternal == this.isBorrowedExternal &&
          other.externalLenderName == this.externalLenderName &&
          other.genre == this.genre &&
          other.isPhysical == this.isPhysical &&
          other.pageCount == this.pageCount &&
          other.publicationYear == this.publicationYear &&
          other.isDirty == this.isDirty &&
          other.isDeleted == this.isDeleted &&
          other.syncedAt == this.syncedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class BooksCompanion extends UpdateCompanion<Book> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String?> remoteId;
  final Value<int?> ownerUserId;
  final Value<String?> ownerRemoteId;
  final Value<String> title;
  final Value<String?> author;
  final Value<String?> isbn;
  final Value<String?> barcode;
  final Value<String?> coverPath;
  final Value<String> status;
  final Value<String?> description;
  final Value<String> readingStatus;
  final Value<bool> isRead;
  final Value<DateTime?> readAt;
  final Value<bool> isBorrowedExternal;
  final Value<String?> externalLenderName;
  final Value<String?> genre;
  final Value<bool> isPhysical;
  final Value<int?> pageCount;
  final Value<int?> publicationYear;
  final Value<bool> isDirty;
  final Value<bool> isDeleted;
  final Value<DateTime?> syncedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const BooksCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.remoteId = const Value.absent(),
    this.ownerUserId = const Value.absent(),
    this.ownerRemoteId = const Value.absent(),
    this.title = const Value.absent(),
    this.author = const Value.absent(),
    this.isbn = const Value.absent(),
    this.barcode = const Value.absent(),
    this.coverPath = const Value.absent(),
    this.status = const Value.absent(),
    this.description = const Value.absent(),
    this.readingStatus = const Value.absent(),
    this.isRead = const Value.absent(),
    this.readAt = const Value.absent(),
    this.isBorrowedExternal = const Value.absent(),
    this.externalLenderName = const Value.absent(),
    this.genre = const Value.absent(),
    this.isPhysical = const Value.absent(),
    this.pageCount = const Value.absent(),
    this.publicationYear = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  BooksCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    this.remoteId = const Value.absent(),
    this.ownerUserId = const Value.absent(),
    this.ownerRemoteId = const Value.absent(),
    required String title,
    this.author = const Value.absent(),
    this.isbn = const Value.absent(),
    this.barcode = const Value.absent(),
    this.coverPath = const Value.absent(),
    this.status = const Value.absent(),
    this.description = const Value.absent(),
    this.readingStatus = const Value.absent(),
    this.isRead = const Value.absent(),
    this.readAt = const Value.absent(),
    this.isBorrowedExternal = const Value.absent(),
    this.externalLenderName = const Value.absent(),
    this.genre = const Value.absent(),
    this.isPhysical = const Value.absent(),
    this.pageCount = const Value.absent(),
    this.publicationYear = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        title = Value(title);
  static Insertable<Book> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? remoteId,
    Expression<int>? ownerUserId,
    Expression<String>? ownerRemoteId,
    Expression<String>? title,
    Expression<String>? author,
    Expression<String>? isbn,
    Expression<String>? barcode,
    Expression<String>? coverPath,
    Expression<String>? status,
    Expression<String>? description,
    Expression<String>? readingStatus,
    Expression<bool>? isRead,
    Expression<DateTime>? readAt,
    Expression<bool>? isBorrowedExternal,
    Expression<String>? externalLenderName,
    Expression<String>? genre,
    Expression<bool>? isPhysical,
    Expression<int>? pageCount,
    Expression<int>? publicationYear,
    Expression<bool>? isDirty,
    Expression<bool>? isDeleted,
    Expression<DateTime>? syncedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (remoteId != null) 'remote_id': remoteId,
      if (ownerUserId != null) 'owner_user_id': ownerUserId,
      if (ownerRemoteId != null) 'owner_remote_id': ownerRemoteId,
      if (title != null) 'title': title,
      if (author != null) 'author': author,
      if (isbn != null) 'isbn': isbn,
      if (barcode != null) 'barcode': barcode,
      if (coverPath != null) 'cover_path': coverPath,
      if (status != null) 'status': status,
      if (description != null) 'description': description,
      if (readingStatus != null) 'reading_status': readingStatus,
      if (isRead != null) 'is_read': isRead,
      if (readAt != null) 'read_at': readAt,
      if (isBorrowedExternal != null)
        'is_borrowed_external': isBorrowedExternal,
      if (externalLenderName != null)
        'external_lender_name': externalLenderName,
      if (genre != null) 'genre': genre,
      if (isPhysical != null) 'is_physical': isPhysical,
      if (pageCount != null) 'page_count': pageCount,
      if (publicationYear != null) 'publication_year': publicationYear,
      if (isDirty != null) 'is_dirty': isDirty,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (syncedAt != null) 'synced_at': syncedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  BooksCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String?>? remoteId,
      Value<int?>? ownerUserId,
      Value<String?>? ownerRemoteId,
      Value<String>? title,
      Value<String?>? author,
      Value<String?>? isbn,
      Value<String?>? barcode,
      Value<String?>? coverPath,
      Value<String>? status,
      Value<String?>? description,
      Value<String>? readingStatus,
      Value<bool>? isRead,
      Value<DateTime?>? readAt,
      Value<bool>? isBorrowedExternal,
      Value<String?>? externalLenderName,
      Value<String?>? genre,
      Value<bool>? isPhysical,
      Value<int?>? pageCount,
      Value<int?>? publicationYear,
      Value<bool>? isDirty,
      Value<bool>? isDeleted,
      Value<DateTime?>? syncedAt,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return BooksCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      remoteId: remoteId ?? this.remoteId,
      ownerUserId: ownerUserId ?? this.ownerUserId,
      ownerRemoteId: ownerRemoteId ?? this.ownerRemoteId,
      title: title ?? this.title,
      author: author ?? this.author,
      isbn: isbn ?? this.isbn,
      barcode: barcode ?? this.barcode,
      coverPath: coverPath ?? this.coverPath,
      status: status ?? this.status,
      description: description ?? this.description,
      readingStatus: readingStatus ?? this.readingStatus,
      isRead: isRead ?? this.isRead,
      readAt: readAt ?? this.readAt,
      isBorrowedExternal: isBorrowedExternal ?? this.isBorrowedExternal,
      externalLenderName: externalLenderName ?? this.externalLenderName,
      genre: genre ?? this.genre,
      isPhysical: isPhysical ?? this.isPhysical,
      pageCount: pageCount ?? this.pageCount,
      publicationYear: publicationYear ?? this.publicationYear,
      isDirty: isDirty ?? this.isDirty,
      isDeleted: isDeleted ?? this.isDeleted,
      syncedAt: syncedAt ?? this.syncedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (remoteId.present) {
      map['remote_id'] = Variable<String>(remoteId.value);
    }
    if (ownerUserId.present) {
      map['owner_user_id'] = Variable<int>(ownerUserId.value);
    }
    if (ownerRemoteId.present) {
      map['owner_remote_id'] = Variable<String>(ownerRemoteId.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (author.present) {
      map['author'] = Variable<String>(author.value);
    }
    if (isbn.present) {
      map['isbn'] = Variable<String>(isbn.value);
    }
    if (barcode.present) {
      map['barcode'] = Variable<String>(barcode.value);
    }
    if (coverPath.present) {
      map['cover_path'] = Variable<String>(coverPath.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (readingStatus.present) {
      map['reading_status'] = Variable<String>(readingStatus.value);
    }
    if (isRead.present) {
      map['is_read'] = Variable<bool>(isRead.value);
    }
    if (readAt.present) {
      map['read_at'] = Variable<DateTime>(readAt.value);
    }
    if (isBorrowedExternal.present) {
      map['is_borrowed_external'] = Variable<bool>(isBorrowedExternal.value);
    }
    if (externalLenderName.present) {
      map['external_lender_name'] = Variable<String>(externalLenderName.value);
    }
    if (genre.present) {
      map['genre'] = Variable<String>(genre.value);
    }
    if (isPhysical.present) {
      map['is_physical'] = Variable<bool>(isPhysical.value);
    }
    if (pageCount.present) {
      map['page_count'] = Variable<int>(pageCount.value);
    }
    if (publicationYear.present) {
      map['publication_year'] = Variable<int>(publicationYear.value);
    }
    if (isDirty.present) {
      map['is_dirty'] = Variable<bool>(isDirty.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (syncedAt.present) {
      map['synced_at'] = Variable<DateTime>(syncedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BooksCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('ownerUserId: $ownerUserId, ')
          ..write('ownerRemoteId: $ownerRemoteId, ')
          ..write('title: $title, ')
          ..write('author: $author, ')
          ..write('isbn: $isbn, ')
          ..write('barcode: $barcode, ')
          ..write('coverPath: $coverPath, ')
          ..write('status: $status, ')
          ..write('description: $description, ')
          ..write('readingStatus: $readingStatus, ')
          ..write('isRead: $isRead, ')
          ..write('readAt: $readAt, ')
          ..write('isBorrowedExternal: $isBorrowedExternal, ')
          ..write('externalLenderName: $externalLenderName, ')
          ..write('genre: $genre, ')
          ..write('isPhysical: $isPhysical, ')
          ..write('pageCount: $pageCount, ')
          ..write('publicationYear: $publicationYear, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $BookReviewsTable extends BookReviews
    with TableInfo<$BookReviewsTable, BookReview> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BookReviewsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _remoteIdMeta =
      const VerificationMeta('remoteId');
  @override
  late final GeneratedColumn<String> remoteId = GeneratedColumn<String>(
      'remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _bookIdMeta = const VerificationMeta('bookId');
  @override
  late final GeneratedColumn<int> bookId = GeneratedColumn<int>(
      'book_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES books (id) ON DELETE CASCADE'));
  static const VerificationMeta _bookUuidMeta =
      const VerificationMeta('bookUuid');
  @override
  late final GeneratedColumn<String> bookUuid = GeneratedColumn<String>(
      'book_uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _authorUserIdMeta =
      const VerificationMeta('authorUserId');
  @override
  late final GeneratedColumn<int> authorUserId = GeneratedColumn<int>(
      'author_user_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES local_users (id)'));
  static const VerificationMeta _authorRemoteIdMeta =
      const VerificationMeta('authorRemoteId');
  @override
  late final GeneratedColumn<String> authorRemoteId = GeneratedColumn<String>(
      'author_remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _ratingMeta = const VerificationMeta('rating');
  @override
  late final GeneratedColumn<int> rating = GeneratedColumn<int>(
      'rating', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      $customConstraints: 'NOT NULL CHECK (rating BETWEEN 1 AND 4)');
  static const VerificationMeta _reviewMeta = const VerificationMeta('review');
  @override
  late final GeneratedColumn<String> review = GeneratedColumn<String>(
      'review', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDirtyMeta =
      const VerificationMeta('isDirty');
  @override
  late final GeneratedColumn<bool> isDirty = GeneratedColumn<bool>(
      'is_dirty', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_dirty" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _syncedAtMeta =
      const VerificationMeta('syncedAt');
  @override
  late final GeneratedColumn<DateTime> syncedAt = GeneratedColumn<DateTime>(
      'synced_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        remoteId,
        bookId,
        bookUuid,
        authorUserId,
        authorRemoteId,
        rating,
        review,
        isDirty,
        isDeleted,
        syncedAt,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'book_reviews';
  @override
  VerificationContext validateIntegrity(Insertable<BookReview> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('remote_id')) {
      context.handle(_remoteIdMeta,
          remoteId.isAcceptableOrUnknown(data['remote_id']!, _remoteIdMeta));
    }
    if (data.containsKey('book_id')) {
      context.handle(_bookIdMeta,
          bookId.isAcceptableOrUnknown(data['book_id']!, _bookIdMeta));
    } else if (isInserting) {
      context.missing(_bookIdMeta);
    }
    if (data.containsKey('book_uuid')) {
      context.handle(_bookUuidMeta,
          bookUuid.isAcceptableOrUnknown(data['book_uuid']!, _bookUuidMeta));
    } else if (isInserting) {
      context.missing(_bookUuidMeta);
    }
    if (data.containsKey('author_user_id')) {
      context.handle(
          _authorUserIdMeta,
          authorUserId.isAcceptableOrUnknown(
              data['author_user_id']!, _authorUserIdMeta));
    } else if (isInserting) {
      context.missing(_authorUserIdMeta);
    }
    if (data.containsKey('author_remote_id')) {
      context.handle(
          _authorRemoteIdMeta,
          authorRemoteId.isAcceptableOrUnknown(
              data['author_remote_id']!, _authorRemoteIdMeta));
    }
    if (data.containsKey('rating')) {
      context.handle(_ratingMeta,
          rating.isAcceptableOrUnknown(data['rating']!, _ratingMeta));
    } else if (isInserting) {
      context.missing(_ratingMeta);
    }
    if (data.containsKey('review')) {
      context.handle(_reviewMeta,
          review.isAcceptableOrUnknown(data['review']!, _reviewMeta));
    }
    if (data.containsKey('is_dirty')) {
      context.handle(_isDirtyMeta,
          isDirty.isAcceptableOrUnknown(data['is_dirty']!, _isDirtyMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('synced_at')) {
      context.handle(_syncedAtMeta,
          syncedAt.isAcceptableOrUnknown(data['synced_at']!, _syncedAtMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {bookId, authorUserId},
      ];
  @override
  BookReview map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BookReview(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      remoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}remote_id']),
      bookId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}book_id'])!,
      bookUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}book_uuid'])!,
      authorUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}author_user_id'])!,
      authorRemoteId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}author_remote_id']),
      rating: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}rating'])!,
      review: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}review']),
      isDirty: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_dirty'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      syncedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}synced_at']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $BookReviewsTable createAlias(String alias) {
    return $BookReviewsTable(attachedDatabase, alias);
  }
}

class BookReview extends DataClass implements Insertable<BookReview> {
  final int id;
  final String uuid;
  final String? remoteId;
  final int bookId;
  final String bookUuid;
  final int authorUserId;
  final String? authorRemoteId;
  final int rating;
  final String? review;
  final bool isDirty;
  final bool isDeleted;
  final DateTime? syncedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const BookReview(
      {required this.id,
      required this.uuid,
      this.remoteId,
      required this.bookId,
      required this.bookUuid,
      required this.authorUserId,
      this.authorRemoteId,
      required this.rating,
      this.review,
      required this.isDirty,
      required this.isDeleted,
      this.syncedAt,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    if (!nullToAbsent || remoteId != null) {
      map['remote_id'] = Variable<String>(remoteId);
    }
    map['book_id'] = Variable<int>(bookId);
    map['book_uuid'] = Variable<String>(bookUuid);
    map['author_user_id'] = Variable<int>(authorUserId);
    if (!nullToAbsent || authorRemoteId != null) {
      map['author_remote_id'] = Variable<String>(authorRemoteId);
    }
    map['rating'] = Variable<int>(rating);
    if (!nullToAbsent || review != null) {
      map['review'] = Variable<String>(review);
    }
    map['is_dirty'] = Variable<bool>(isDirty);
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || syncedAt != null) {
      map['synced_at'] = Variable<DateTime>(syncedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  BookReviewsCompanion toCompanion(bool nullToAbsent) {
    return BookReviewsCompanion(
      id: Value(id),
      uuid: Value(uuid),
      remoteId: remoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(remoteId),
      bookId: Value(bookId),
      bookUuid: Value(bookUuid),
      authorUserId: Value(authorUserId),
      authorRemoteId: authorRemoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(authorRemoteId),
      rating: Value(rating),
      review:
          review == null && nullToAbsent ? const Value.absent() : Value(review),
      isDirty: Value(isDirty),
      isDeleted: Value(isDeleted),
      syncedAt: syncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory BookReview.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BookReview(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      remoteId: serializer.fromJson<String?>(json['remoteId']),
      bookId: serializer.fromJson<int>(json['bookId']),
      bookUuid: serializer.fromJson<String>(json['bookUuid']),
      authorUserId: serializer.fromJson<int>(json['authorUserId']),
      authorRemoteId: serializer.fromJson<String?>(json['authorRemoteId']),
      rating: serializer.fromJson<int>(json['rating']),
      review: serializer.fromJson<String?>(json['review']),
      isDirty: serializer.fromJson<bool>(json['isDirty']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      syncedAt: serializer.fromJson<DateTime?>(json['syncedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'remoteId': serializer.toJson<String?>(remoteId),
      'bookId': serializer.toJson<int>(bookId),
      'bookUuid': serializer.toJson<String>(bookUuid),
      'authorUserId': serializer.toJson<int>(authorUserId),
      'authorRemoteId': serializer.toJson<String?>(authorRemoteId),
      'rating': serializer.toJson<int>(rating),
      'review': serializer.toJson<String?>(review),
      'isDirty': serializer.toJson<bool>(isDirty),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'syncedAt': serializer.toJson<DateTime?>(syncedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  BookReview copyWith(
          {int? id,
          String? uuid,
          Value<String?> remoteId = const Value.absent(),
          int? bookId,
          String? bookUuid,
          int? authorUserId,
          Value<String?> authorRemoteId = const Value.absent(),
          int? rating,
          Value<String?> review = const Value.absent(),
          bool? isDirty,
          bool? isDeleted,
          Value<DateTime?> syncedAt = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      BookReview(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        remoteId: remoteId.present ? remoteId.value : this.remoteId,
        bookId: bookId ?? this.bookId,
        bookUuid: bookUuid ?? this.bookUuid,
        authorUserId: authorUserId ?? this.authorUserId,
        authorRemoteId:
            authorRemoteId.present ? authorRemoteId.value : this.authorRemoteId,
        rating: rating ?? this.rating,
        review: review.present ? review.value : this.review,
        isDirty: isDirty ?? this.isDirty,
        isDeleted: isDeleted ?? this.isDeleted,
        syncedAt: syncedAt.present ? syncedAt.value : this.syncedAt,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  BookReview copyWithCompanion(BookReviewsCompanion data) {
    return BookReview(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      remoteId: data.remoteId.present ? data.remoteId.value : this.remoteId,
      bookId: data.bookId.present ? data.bookId.value : this.bookId,
      bookUuid: data.bookUuid.present ? data.bookUuid.value : this.bookUuid,
      authorUserId: data.authorUserId.present
          ? data.authorUserId.value
          : this.authorUserId,
      authorRemoteId: data.authorRemoteId.present
          ? data.authorRemoteId.value
          : this.authorRemoteId,
      rating: data.rating.present ? data.rating.value : this.rating,
      review: data.review.present ? data.review.value : this.review,
      isDirty: data.isDirty.present ? data.isDirty.value : this.isDirty,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      syncedAt: data.syncedAt.present ? data.syncedAt.value : this.syncedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BookReview(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('bookId: $bookId, ')
          ..write('bookUuid: $bookUuid, ')
          ..write('authorUserId: $authorUserId, ')
          ..write('authorRemoteId: $authorRemoteId, ')
          ..write('rating: $rating, ')
          ..write('review: $review, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      remoteId,
      bookId,
      bookUuid,
      authorUserId,
      authorRemoteId,
      rating,
      review,
      isDirty,
      isDeleted,
      syncedAt,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BookReview &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.remoteId == this.remoteId &&
          other.bookId == this.bookId &&
          other.bookUuid == this.bookUuid &&
          other.authorUserId == this.authorUserId &&
          other.authorRemoteId == this.authorRemoteId &&
          other.rating == this.rating &&
          other.review == this.review &&
          other.isDirty == this.isDirty &&
          other.isDeleted == this.isDeleted &&
          other.syncedAt == this.syncedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class BookReviewsCompanion extends UpdateCompanion<BookReview> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String?> remoteId;
  final Value<int> bookId;
  final Value<String> bookUuid;
  final Value<int> authorUserId;
  final Value<String?> authorRemoteId;
  final Value<int> rating;
  final Value<String?> review;
  final Value<bool> isDirty;
  final Value<bool> isDeleted;
  final Value<DateTime?> syncedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const BookReviewsCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.remoteId = const Value.absent(),
    this.bookId = const Value.absent(),
    this.bookUuid = const Value.absent(),
    this.authorUserId = const Value.absent(),
    this.authorRemoteId = const Value.absent(),
    this.rating = const Value.absent(),
    this.review = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  BookReviewsCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    this.remoteId = const Value.absent(),
    required int bookId,
    required String bookUuid,
    required int authorUserId,
    this.authorRemoteId = const Value.absent(),
    required int rating,
    this.review = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        bookId = Value(bookId),
        bookUuid = Value(bookUuid),
        authorUserId = Value(authorUserId),
        rating = Value(rating);
  static Insertable<BookReview> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? remoteId,
    Expression<int>? bookId,
    Expression<String>? bookUuid,
    Expression<int>? authorUserId,
    Expression<String>? authorRemoteId,
    Expression<int>? rating,
    Expression<String>? review,
    Expression<bool>? isDirty,
    Expression<bool>? isDeleted,
    Expression<DateTime>? syncedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (remoteId != null) 'remote_id': remoteId,
      if (bookId != null) 'book_id': bookId,
      if (bookUuid != null) 'book_uuid': bookUuid,
      if (authorUserId != null) 'author_user_id': authorUserId,
      if (authorRemoteId != null) 'author_remote_id': authorRemoteId,
      if (rating != null) 'rating': rating,
      if (review != null) 'review': review,
      if (isDirty != null) 'is_dirty': isDirty,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (syncedAt != null) 'synced_at': syncedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  BookReviewsCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String?>? remoteId,
      Value<int>? bookId,
      Value<String>? bookUuid,
      Value<int>? authorUserId,
      Value<String?>? authorRemoteId,
      Value<int>? rating,
      Value<String?>? review,
      Value<bool>? isDirty,
      Value<bool>? isDeleted,
      Value<DateTime?>? syncedAt,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return BookReviewsCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      remoteId: remoteId ?? this.remoteId,
      bookId: bookId ?? this.bookId,
      bookUuid: bookUuid ?? this.bookUuid,
      authorUserId: authorUserId ?? this.authorUserId,
      authorRemoteId: authorRemoteId ?? this.authorRemoteId,
      rating: rating ?? this.rating,
      review: review ?? this.review,
      isDirty: isDirty ?? this.isDirty,
      isDeleted: isDeleted ?? this.isDeleted,
      syncedAt: syncedAt ?? this.syncedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (remoteId.present) {
      map['remote_id'] = Variable<String>(remoteId.value);
    }
    if (bookId.present) {
      map['book_id'] = Variable<int>(bookId.value);
    }
    if (bookUuid.present) {
      map['book_uuid'] = Variable<String>(bookUuid.value);
    }
    if (authorUserId.present) {
      map['author_user_id'] = Variable<int>(authorUserId.value);
    }
    if (authorRemoteId.present) {
      map['author_remote_id'] = Variable<String>(authorRemoteId.value);
    }
    if (rating.present) {
      map['rating'] = Variable<int>(rating.value);
    }
    if (review.present) {
      map['review'] = Variable<String>(review.value);
    }
    if (isDirty.present) {
      map['is_dirty'] = Variable<bool>(isDirty.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (syncedAt.present) {
      map['synced_at'] = Variable<DateTime>(syncedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BookReviewsCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('bookId: $bookId, ')
          ..write('bookUuid: $bookUuid, ')
          ..write('authorUserId: $authorUserId, ')
          ..write('authorRemoteId: $authorRemoteId, ')
          ..write('rating: $rating, ')
          ..write('review: $review, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $ReadingTimelineEntriesTable extends ReadingTimelineEntries
    with TableInfo<$ReadingTimelineEntriesTable, ReadingTimelineEntry> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ReadingTimelineEntriesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _remoteIdMeta =
      const VerificationMeta('remoteId');
  @override
  late final GeneratedColumn<String> remoteId = GeneratedColumn<String>(
      'remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _bookIdMeta = const VerificationMeta('bookId');
  @override
  late final GeneratedColumn<int> bookId = GeneratedColumn<int>(
      'book_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES books (id) ON DELETE CASCADE'));
  static const VerificationMeta _bookUuidMeta =
      const VerificationMeta('bookUuid');
  @override
  late final GeneratedColumn<String> bookUuid = GeneratedColumn<String>(
      'book_uuid', aliasedName, true,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _ownerUserIdMeta =
      const VerificationMeta('ownerUserId');
  @override
  late final GeneratedColumn<int> ownerUserId = GeneratedColumn<int>(
      'owner_user_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES local_users (id)'));
  static const VerificationMeta _currentPageMeta =
      const VerificationMeta('currentPage');
  @override
  late final GeneratedColumn<int> currentPage = GeneratedColumn<int>(
      'current_page', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _percentageReadMeta =
      const VerificationMeta('percentageRead');
  @override
  late final GeneratedColumn<int> percentageRead = GeneratedColumn<int>(
      'percentage_read', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _eventTypeMeta =
      const VerificationMeta('eventType');
  @override
  late final GeneratedColumn<String> eventType = GeneratedColumn<String>(
      'event_type', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 32),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _noteMeta = const VerificationMeta('note');
  @override
  late final GeneratedColumn<String> note = GeneratedColumn<String>(
      'note', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _eventDateMeta =
      const VerificationMeta('eventDate');
  @override
  late final GeneratedColumn<DateTime> eventDate = GeneratedColumn<DateTime>(
      'event_date', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _isDirtyMeta =
      const VerificationMeta('isDirty');
  @override
  late final GeneratedColumn<bool> isDirty = GeneratedColumn<bool>(
      'is_dirty', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_dirty" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _syncedAtMeta =
      const VerificationMeta('syncedAt');
  @override
  late final GeneratedColumn<DateTime> syncedAt = GeneratedColumn<DateTime>(
      'synced_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        remoteId,
        bookId,
        bookUuid,
        ownerUserId,
        currentPage,
        percentageRead,
        eventType,
        note,
        eventDate,
        isDirty,
        isDeleted,
        syncedAt,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'reading_timeline_entries';
  @override
  VerificationContext validateIntegrity(
      Insertable<ReadingTimelineEntry> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('remote_id')) {
      context.handle(_remoteIdMeta,
          remoteId.isAcceptableOrUnknown(data['remote_id']!, _remoteIdMeta));
    }
    if (data.containsKey('book_id')) {
      context.handle(_bookIdMeta,
          bookId.isAcceptableOrUnknown(data['book_id']!, _bookIdMeta));
    } else if (isInserting) {
      context.missing(_bookIdMeta);
    }
    if (data.containsKey('book_uuid')) {
      context.handle(_bookUuidMeta,
          bookUuid.isAcceptableOrUnknown(data['book_uuid']!, _bookUuidMeta));
    }
    if (data.containsKey('owner_user_id')) {
      context.handle(
          _ownerUserIdMeta,
          ownerUserId.isAcceptableOrUnknown(
              data['owner_user_id']!, _ownerUserIdMeta));
    } else if (isInserting) {
      context.missing(_ownerUserIdMeta);
    }
    if (data.containsKey('current_page')) {
      context.handle(
          _currentPageMeta,
          currentPage.isAcceptableOrUnknown(
              data['current_page']!, _currentPageMeta));
    }
    if (data.containsKey('percentage_read')) {
      context.handle(
          _percentageReadMeta,
          percentageRead.isAcceptableOrUnknown(
              data['percentage_read']!, _percentageReadMeta));
    }
    if (data.containsKey('event_type')) {
      context.handle(_eventTypeMeta,
          eventType.isAcceptableOrUnknown(data['event_type']!, _eventTypeMeta));
    } else if (isInserting) {
      context.missing(_eventTypeMeta);
    }
    if (data.containsKey('note')) {
      context.handle(
          _noteMeta, note.isAcceptableOrUnknown(data['note']!, _noteMeta));
    }
    if (data.containsKey('event_date')) {
      context.handle(_eventDateMeta,
          eventDate.isAcceptableOrUnknown(data['event_date']!, _eventDateMeta));
    }
    if (data.containsKey('is_dirty')) {
      context.handle(_isDirtyMeta,
          isDirty.isAcceptableOrUnknown(data['is_dirty']!, _isDirtyMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('synced_at')) {
      context.handle(_syncedAtMeta,
          syncedAt.isAcceptableOrUnknown(data['synced_at']!, _syncedAtMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ReadingTimelineEntry map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ReadingTimelineEntry(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      remoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}remote_id']),
      bookId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}book_id'])!,
      bookUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}book_uuid']),
      ownerUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}owner_user_id'])!,
      currentPage: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}current_page']),
      percentageRead: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}percentage_read']),
      eventType: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}event_type'])!,
      note: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}note']),
      eventDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}event_date'])!,
      isDirty: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_dirty'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      syncedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}synced_at']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $ReadingTimelineEntriesTable createAlias(String alias) {
    return $ReadingTimelineEntriesTable(attachedDatabase, alias);
  }
}

class ReadingTimelineEntry extends DataClass
    implements Insertable<ReadingTimelineEntry> {
  final int id;
  final String uuid;
  final String? remoteId;
  final int bookId;
  final String? bookUuid;
  final int ownerUserId;
  final int? currentPage;
  final int? percentageRead;
  final String eventType;
  final String? note;
  final DateTime eventDate;
  final bool isDirty;
  final bool isDeleted;
  final DateTime? syncedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const ReadingTimelineEntry(
      {required this.id,
      required this.uuid,
      this.remoteId,
      required this.bookId,
      this.bookUuid,
      required this.ownerUserId,
      this.currentPage,
      this.percentageRead,
      required this.eventType,
      this.note,
      required this.eventDate,
      required this.isDirty,
      required this.isDeleted,
      this.syncedAt,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    if (!nullToAbsent || remoteId != null) {
      map['remote_id'] = Variable<String>(remoteId);
    }
    map['book_id'] = Variable<int>(bookId);
    if (!nullToAbsent || bookUuid != null) {
      map['book_uuid'] = Variable<String>(bookUuid);
    }
    map['owner_user_id'] = Variable<int>(ownerUserId);
    if (!nullToAbsent || currentPage != null) {
      map['current_page'] = Variable<int>(currentPage);
    }
    if (!nullToAbsent || percentageRead != null) {
      map['percentage_read'] = Variable<int>(percentageRead);
    }
    map['event_type'] = Variable<String>(eventType);
    if (!nullToAbsent || note != null) {
      map['note'] = Variable<String>(note);
    }
    map['event_date'] = Variable<DateTime>(eventDate);
    map['is_dirty'] = Variable<bool>(isDirty);
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || syncedAt != null) {
      map['synced_at'] = Variable<DateTime>(syncedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  ReadingTimelineEntriesCompanion toCompanion(bool nullToAbsent) {
    return ReadingTimelineEntriesCompanion(
      id: Value(id),
      uuid: Value(uuid),
      remoteId: remoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(remoteId),
      bookId: Value(bookId),
      bookUuid: bookUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(bookUuid),
      ownerUserId: Value(ownerUserId),
      currentPage: currentPage == null && nullToAbsent
          ? const Value.absent()
          : Value(currentPage),
      percentageRead: percentageRead == null && nullToAbsent
          ? const Value.absent()
          : Value(percentageRead),
      eventType: Value(eventType),
      note: note == null && nullToAbsent ? const Value.absent() : Value(note),
      eventDate: Value(eventDate),
      isDirty: Value(isDirty),
      isDeleted: Value(isDeleted),
      syncedAt: syncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ReadingTimelineEntry.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ReadingTimelineEntry(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      remoteId: serializer.fromJson<String?>(json['remoteId']),
      bookId: serializer.fromJson<int>(json['bookId']),
      bookUuid: serializer.fromJson<String?>(json['bookUuid']),
      ownerUserId: serializer.fromJson<int>(json['ownerUserId']),
      currentPage: serializer.fromJson<int?>(json['currentPage']),
      percentageRead: serializer.fromJson<int?>(json['percentageRead']),
      eventType: serializer.fromJson<String>(json['eventType']),
      note: serializer.fromJson<String?>(json['note']),
      eventDate: serializer.fromJson<DateTime>(json['eventDate']),
      isDirty: serializer.fromJson<bool>(json['isDirty']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      syncedAt: serializer.fromJson<DateTime?>(json['syncedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'remoteId': serializer.toJson<String?>(remoteId),
      'bookId': serializer.toJson<int>(bookId),
      'bookUuid': serializer.toJson<String?>(bookUuid),
      'ownerUserId': serializer.toJson<int>(ownerUserId),
      'currentPage': serializer.toJson<int?>(currentPage),
      'percentageRead': serializer.toJson<int?>(percentageRead),
      'eventType': serializer.toJson<String>(eventType),
      'note': serializer.toJson<String?>(note),
      'eventDate': serializer.toJson<DateTime>(eventDate),
      'isDirty': serializer.toJson<bool>(isDirty),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'syncedAt': serializer.toJson<DateTime?>(syncedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  ReadingTimelineEntry copyWith(
          {int? id,
          String? uuid,
          Value<String?> remoteId = const Value.absent(),
          int? bookId,
          Value<String?> bookUuid = const Value.absent(),
          int? ownerUserId,
          Value<int?> currentPage = const Value.absent(),
          Value<int?> percentageRead = const Value.absent(),
          String? eventType,
          Value<String?> note = const Value.absent(),
          DateTime? eventDate,
          bool? isDirty,
          bool? isDeleted,
          Value<DateTime?> syncedAt = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      ReadingTimelineEntry(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        remoteId: remoteId.present ? remoteId.value : this.remoteId,
        bookId: bookId ?? this.bookId,
        bookUuid: bookUuid.present ? bookUuid.value : this.bookUuid,
        ownerUserId: ownerUserId ?? this.ownerUserId,
        currentPage: currentPage.present ? currentPage.value : this.currentPage,
        percentageRead:
            percentageRead.present ? percentageRead.value : this.percentageRead,
        eventType: eventType ?? this.eventType,
        note: note.present ? note.value : this.note,
        eventDate: eventDate ?? this.eventDate,
        isDirty: isDirty ?? this.isDirty,
        isDeleted: isDeleted ?? this.isDeleted,
        syncedAt: syncedAt.present ? syncedAt.value : this.syncedAt,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  ReadingTimelineEntry copyWithCompanion(ReadingTimelineEntriesCompanion data) {
    return ReadingTimelineEntry(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      remoteId: data.remoteId.present ? data.remoteId.value : this.remoteId,
      bookId: data.bookId.present ? data.bookId.value : this.bookId,
      bookUuid: data.bookUuid.present ? data.bookUuid.value : this.bookUuid,
      ownerUserId:
          data.ownerUserId.present ? data.ownerUserId.value : this.ownerUserId,
      currentPage:
          data.currentPage.present ? data.currentPage.value : this.currentPage,
      percentageRead: data.percentageRead.present
          ? data.percentageRead.value
          : this.percentageRead,
      eventType: data.eventType.present ? data.eventType.value : this.eventType,
      note: data.note.present ? data.note.value : this.note,
      eventDate: data.eventDate.present ? data.eventDate.value : this.eventDate,
      isDirty: data.isDirty.present ? data.isDirty.value : this.isDirty,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      syncedAt: data.syncedAt.present ? data.syncedAt.value : this.syncedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ReadingTimelineEntry(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('bookId: $bookId, ')
          ..write('bookUuid: $bookUuid, ')
          ..write('ownerUserId: $ownerUserId, ')
          ..write('currentPage: $currentPage, ')
          ..write('percentageRead: $percentageRead, ')
          ..write('eventType: $eventType, ')
          ..write('note: $note, ')
          ..write('eventDate: $eventDate, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      remoteId,
      bookId,
      bookUuid,
      ownerUserId,
      currentPage,
      percentageRead,
      eventType,
      note,
      eventDate,
      isDirty,
      isDeleted,
      syncedAt,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ReadingTimelineEntry &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.remoteId == this.remoteId &&
          other.bookId == this.bookId &&
          other.bookUuid == this.bookUuid &&
          other.ownerUserId == this.ownerUserId &&
          other.currentPage == this.currentPage &&
          other.percentageRead == this.percentageRead &&
          other.eventType == this.eventType &&
          other.note == this.note &&
          other.eventDate == this.eventDate &&
          other.isDirty == this.isDirty &&
          other.isDeleted == this.isDeleted &&
          other.syncedAt == this.syncedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ReadingTimelineEntriesCompanion
    extends UpdateCompanion<ReadingTimelineEntry> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String?> remoteId;
  final Value<int> bookId;
  final Value<String?> bookUuid;
  final Value<int> ownerUserId;
  final Value<int?> currentPage;
  final Value<int?> percentageRead;
  final Value<String> eventType;
  final Value<String?> note;
  final Value<DateTime> eventDate;
  final Value<bool> isDirty;
  final Value<bool> isDeleted;
  final Value<DateTime?> syncedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const ReadingTimelineEntriesCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.remoteId = const Value.absent(),
    this.bookId = const Value.absent(),
    this.bookUuid = const Value.absent(),
    this.ownerUserId = const Value.absent(),
    this.currentPage = const Value.absent(),
    this.percentageRead = const Value.absent(),
    this.eventType = const Value.absent(),
    this.note = const Value.absent(),
    this.eventDate = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  ReadingTimelineEntriesCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    this.remoteId = const Value.absent(),
    required int bookId,
    this.bookUuid = const Value.absent(),
    required int ownerUserId,
    this.currentPage = const Value.absent(),
    this.percentageRead = const Value.absent(),
    required String eventType,
    this.note = const Value.absent(),
    this.eventDate = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        bookId = Value(bookId),
        ownerUserId = Value(ownerUserId),
        eventType = Value(eventType);
  static Insertable<ReadingTimelineEntry> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? remoteId,
    Expression<int>? bookId,
    Expression<String>? bookUuid,
    Expression<int>? ownerUserId,
    Expression<int>? currentPage,
    Expression<int>? percentageRead,
    Expression<String>? eventType,
    Expression<String>? note,
    Expression<DateTime>? eventDate,
    Expression<bool>? isDirty,
    Expression<bool>? isDeleted,
    Expression<DateTime>? syncedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (remoteId != null) 'remote_id': remoteId,
      if (bookId != null) 'book_id': bookId,
      if (bookUuid != null) 'book_uuid': bookUuid,
      if (ownerUserId != null) 'owner_user_id': ownerUserId,
      if (currentPage != null) 'current_page': currentPage,
      if (percentageRead != null) 'percentage_read': percentageRead,
      if (eventType != null) 'event_type': eventType,
      if (note != null) 'note': note,
      if (eventDate != null) 'event_date': eventDate,
      if (isDirty != null) 'is_dirty': isDirty,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (syncedAt != null) 'synced_at': syncedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  ReadingTimelineEntriesCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String?>? remoteId,
      Value<int>? bookId,
      Value<String?>? bookUuid,
      Value<int>? ownerUserId,
      Value<int?>? currentPage,
      Value<int?>? percentageRead,
      Value<String>? eventType,
      Value<String?>? note,
      Value<DateTime>? eventDate,
      Value<bool>? isDirty,
      Value<bool>? isDeleted,
      Value<DateTime?>? syncedAt,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return ReadingTimelineEntriesCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      remoteId: remoteId ?? this.remoteId,
      bookId: bookId ?? this.bookId,
      bookUuid: bookUuid ?? this.bookUuid,
      ownerUserId: ownerUserId ?? this.ownerUserId,
      currentPage: currentPage ?? this.currentPage,
      percentageRead: percentageRead ?? this.percentageRead,
      eventType: eventType ?? this.eventType,
      note: note ?? this.note,
      eventDate: eventDate ?? this.eventDate,
      isDirty: isDirty ?? this.isDirty,
      isDeleted: isDeleted ?? this.isDeleted,
      syncedAt: syncedAt ?? this.syncedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (remoteId.present) {
      map['remote_id'] = Variable<String>(remoteId.value);
    }
    if (bookId.present) {
      map['book_id'] = Variable<int>(bookId.value);
    }
    if (bookUuid.present) {
      map['book_uuid'] = Variable<String>(bookUuid.value);
    }
    if (ownerUserId.present) {
      map['owner_user_id'] = Variable<int>(ownerUserId.value);
    }
    if (currentPage.present) {
      map['current_page'] = Variable<int>(currentPage.value);
    }
    if (percentageRead.present) {
      map['percentage_read'] = Variable<int>(percentageRead.value);
    }
    if (eventType.present) {
      map['event_type'] = Variable<String>(eventType.value);
    }
    if (note.present) {
      map['note'] = Variable<String>(note.value);
    }
    if (eventDate.present) {
      map['event_date'] = Variable<DateTime>(eventDate.value);
    }
    if (isDirty.present) {
      map['is_dirty'] = Variable<bool>(isDirty.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (syncedAt.present) {
      map['synced_at'] = Variable<DateTime>(syncedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ReadingTimelineEntriesCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('bookId: $bookId, ')
          ..write('bookUuid: $bookUuid, ')
          ..write('ownerUserId: $ownerUserId, ')
          ..write('currentPage: $currentPage, ')
          ..write('percentageRead: $percentageRead, ')
          ..write('eventType: $eventType, ')
          ..write('note: $note, ')
          ..write('eventDate: $eventDate, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $GroupsTable extends Groups with TableInfo<$GroupsTable, Group> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GroupsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _remoteIdMeta =
      const VerificationMeta('remoteId');
  @override
  late final GeneratedColumn<String> remoteId = GeneratedColumn<String>(
      'remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 128),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, true,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 0, maxTextLength: 512),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _ownerUserIdMeta =
      const VerificationMeta('ownerUserId');
  @override
  late final GeneratedColumn<int> ownerUserId = GeneratedColumn<int>(
      'owner_user_id', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES local_users (id)'));
  static const VerificationMeta _ownerRemoteIdMeta =
      const VerificationMeta('ownerRemoteId');
  @override
  late final GeneratedColumn<String> ownerRemoteId = GeneratedColumn<String>(
      'owner_remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDirtyMeta =
      const VerificationMeta('isDirty');
  @override
  late final GeneratedColumn<bool> isDirty = GeneratedColumn<bool>(
      'is_dirty', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_dirty" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _syncedAtMeta =
      const VerificationMeta('syncedAt');
  @override
  late final GeneratedColumn<DateTime> syncedAt = GeneratedColumn<DateTime>(
      'synced_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        remoteId,
        name,
        description,
        ownerUserId,
        ownerRemoteId,
        isDirty,
        isDeleted,
        syncedAt,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'groups';
  @override
  VerificationContext validateIntegrity(Insertable<Group> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('remote_id')) {
      context.handle(_remoteIdMeta,
          remoteId.isAcceptableOrUnknown(data['remote_id']!, _remoteIdMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    }
    if (data.containsKey('owner_user_id')) {
      context.handle(
          _ownerUserIdMeta,
          ownerUserId.isAcceptableOrUnknown(
              data['owner_user_id']!, _ownerUserIdMeta));
    }
    if (data.containsKey('owner_remote_id')) {
      context.handle(
          _ownerRemoteIdMeta,
          ownerRemoteId.isAcceptableOrUnknown(
              data['owner_remote_id']!, _ownerRemoteIdMeta));
    }
    if (data.containsKey('is_dirty')) {
      context.handle(_isDirtyMeta,
          isDirty.isAcceptableOrUnknown(data['is_dirty']!, _isDirtyMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('synced_at')) {
      context.handle(_syncedAtMeta,
          syncedAt.isAcceptableOrUnknown(data['synced_at']!, _syncedAtMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Group map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Group(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      remoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}remote_id']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description']),
      ownerUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}owner_user_id']),
      ownerRemoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}owner_remote_id']),
      isDirty: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_dirty'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      syncedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}synced_at']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $GroupsTable createAlias(String alias) {
    return $GroupsTable(attachedDatabase, alias);
  }
}

class Group extends DataClass implements Insertable<Group> {
  final int id;
  final String uuid;
  final String? remoteId;
  final String name;
  final String? description;
  final int? ownerUserId;
  final String? ownerRemoteId;
  final bool isDirty;
  final bool isDeleted;
  final DateTime? syncedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Group(
      {required this.id,
      required this.uuid,
      this.remoteId,
      required this.name,
      this.description,
      this.ownerUserId,
      this.ownerRemoteId,
      required this.isDirty,
      required this.isDeleted,
      this.syncedAt,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    if (!nullToAbsent || remoteId != null) {
      map['remote_id'] = Variable<String>(remoteId);
    }
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    if (!nullToAbsent || ownerUserId != null) {
      map['owner_user_id'] = Variable<int>(ownerUserId);
    }
    if (!nullToAbsent || ownerRemoteId != null) {
      map['owner_remote_id'] = Variable<String>(ownerRemoteId);
    }
    map['is_dirty'] = Variable<bool>(isDirty);
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || syncedAt != null) {
      map['synced_at'] = Variable<DateTime>(syncedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  GroupsCompanion toCompanion(bool nullToAbsent) {
    return GroupsCompanion(
      id: Value(id),
      uuid: Value(uuid),
      remoteId: remoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(remoteId),
      name: Value(name),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      ownerUserId: ownerUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(ownerUserId),
      ownerRemoteId: ownerRemoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(ownerRemoteId),
      isDirty: Value(isDirty),
      isDeleted: Value(isDeleted),
      syncedAt: syncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Group.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Group(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      remoteId: serializer.fromJson<String?>(json['remoteId']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String?>(json['description']),
      ownerUserId: serializer.fromJson<int?>(json['ownerUserId']),
      ownerRemoteId: serializer.fromJson<String?>(json['ownerRemoteId']),
      isDirty: serializer.fromJson<bool>(json['isDirty']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      syncedAt: serializer.fromJson<DateTime?>(json['syncedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'remoteId': serializer.toJson<String?>(remoteId),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String?>(description),
      'ownerUserId': serializer.toJson<int?>(ownerUserId),
      'ownerRemoteId': serializer.toJson<String?>(ownerRemoteId),
      'isDirty': serializer.toJson<bool>(isDirty),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'syncedAt': serializer.toJson<DateTime?>(syncedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  Group copyWith(
          {int? id,
          String? uuid,
          Value<String?> remoteId = const Value.absent(),
          String? name,
          Value<String?> description = const Value.absent(),
          Value<int?> ownerUserId = const Value.absent(),
          Value<String?> ownerRemoteId = const Value.absent(),
          bool? isDirty,
          bool? isDeleted,
          Value<DateTime?> syncedAt = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      Group(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        remoteId: remoteId.present ? remoteId.value : this.remoteId,
        name: name ?? this.name,
        description: description.present ? description.value : this.description,
        ownerUserId: ownerUserId.present ? ownerUserId.value : this.ownerUserId,
        ownerRemoteId:
            ownerRemoteId.present ? ownerRemoteId.value : this.ownerRemoteId,
        isDirty: isDirty ?? this.isDirty,
        isDeleted: isDeleted ?? this.isDeleted,
        syncedAt: syncedAt.present ? syncedAt.value : this.syncedAt,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  Group copyWithCompanion(GroupsCompanion data) {
    return Group(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      remoteId: data.remoteId.present ? data.remoteId.value : this.remoteId,
      name: data.name.present ? data.name.value : this.name,
      description:
          data.description.present ? data.description.value : this.description,
      ownerUserId:
          data.ownerUserId.present ? data.ownerUserId.value : this.ownerUserId,
      ownerRemoteId: data.ownerRemoteId.present
          ? data.ownerRemoteId.value
          : this.ownerRemoteId,
      isDirty: data.isDirty.present ? data.isDirty.value : this.isDirty,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      syncedAt: data.syncedAt.present ? data.syncedAt.value : this.syncedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Group(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('ownerUserId: $ownerUserId, ')
          ..write('ownerRemoteId: $ownerRemoteId, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      remoteId,
      name,
      description,
      ownerUserId,
      ownerRemoteId,
      isDirty,
      isDeleted,
      syncedAt,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Group &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.remoteId == this.remoteId &&
          other.name == this.name &&
          other.description == this.description &&
          other.ownerUserId == this.ownerUserId &&
          other.ownerRemoteId == this.ownerRemoteId &&
          other.isDirty == this.isDirty &&
          other.isDeleted == this.isDeleted &&
          other.syncedAt == this.syncedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class GroupsCompanion extends UpdateCompanion<Group> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String?> remoteId;
  final Value<String> name;
  final Value<String?> description;
  final Value<int?> ownerUserId;
  final Value<String?> ownerRemoteId;
  final Value<bool> isDirty;
  final Value<bool> isDeleted;
  final Value<DateTime?> syncedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const GroupsCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.remoteId = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.ownerUserId = const Value.absent(),
    this.ownerRemoteId = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  GroupsCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    this.remoteId = const Value.absent(),
    required String name,
    this.description = const Value.absent(),
    this.ownerUserId = const Value.absent(),
    this.ownerRemoteId = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        name = Value(name);
  static Insertable<Group> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? remoteId,
    Expression<String>? name,
    Expression<String>? description,
    Expression<int>? ownerUserId,
    Expression<String>? ownerRemoteId,
    Expression<bool>? isDirty,
    Expression<bool>? isDeleted,
    Expression<DateTime>? syncedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (remoteId != null) 'remote_id': remoteId,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (ownerUserId != null) 'owner_user_id': ownerUserId,
      if (ownerRemoteId != null) 'owner_remote_id': ownerRemoteId,
      if (isDirty != null) 'is_dirty': isDirty,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (syncedAt != null) 'synced_at': syncedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  GroupsCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String?>? remoteId,
      Value<String>? name,
      Value<String?>? description,
      Value<int?>? ownerUserId,
      Value<String?>? ownerRemoteId,
      Value<bool>? isDirty,
      Value<bool>? isDeleted,
      Value<DateTime?>? syncedAt,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return GroupsCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      remoteId: remoteId ?? this.remoteId,
      name: name ?? this.name,
      description: description ?? this.description,
      ownerUserId: ownerUserId ?? this.ownerUserId,
      ownerRemoteId: ownerRemoteId ?? this.ownerRemoteId,
      isDirty: isDirty ?? this.isDirty,
      isDeleted: isDeleted ?? this.isDeleted,
      syncedAt: syncedAt ?? this.syncedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (remoteId.present) {
      map['remote_id'] = Variable<String>(remoteId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (ownerUserId.present) {
      map['owner_user_id'] = Variable<int>(ownerUserId.value);
    }
    if (ownerRemoteId.present) {
      map['owner_remote_id'] = Variable<String>(ownerRemoteId.value);
    }
    if (isDirty.present) {
      map['is_dirty'] = Variable<bool>(isDirty.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (syncedAt.present) {
      map['synced_at'] = Variable<DateTime>(syncedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GroupsCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('ownerUserId: $ownerUserId, ')
          ..write('ownerRemoteId: $ownerRemoteId, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $GroupMembersTable extends GroupMembers
    with TableInfo<$GroupMembersTable, GroupMember> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GroupMembersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _remoteIdMeta =
      const VerificationMeta('remoteId');
  @override
  late final GeneratedColumn<String> remoteId = GeneratedColumn<String>(
      'remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _groupIdMeta =
      const VerificationMeta('groupId');
  @override
  late final GeneratedColumn<int> groupId = GeneratedColumn<int>(
      'group_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES "groups" (id) ON DELETE CASCADE'));
  static const VerificationMeta _groupUuidMeta =
      const VerificationMeta('groupUuid');
  @override
  late final GeneratedColumn<String> groupUuid = GeneratedColumn<String>(
      'group_uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _memberUserIdMeta =
      const VerificationMeta('memberUserId');
  @override
  late final GeneratedColumn<int> memberUserId = GeneratedColumn<int>(
      'member_user_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES local_users (id)'));
  static const VerificationMeta _memberRemoteIdMeta =
      const VerificationMeta('memberRemoteId');
  @override
  late final GeneratedColumn<String> memberRemoteId = GeneratedColumn<String>(
      'member_remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _roleMeta = const VerificationMeta('role');
  @override
  late final GeneratedColumn<String> role = GeneratedColumn<String>(
      'role', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('member'));
  static const VerificationMeta _isDirtyMeta =
      const VerificationMeta('isDirty');
  @override
  late final GeneratedColumn<bool> isDirty = GeneratedColumn<bool>(
      'is_dirty', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_dirty" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _syncedAtMeta =
      const VerificationMeta('syncedAt');
  @override
  late final GeneratedColumn<DateTime> syncedAt = GeneratedColumn<DateTime>(
      'synced_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        remoteId,
        groupId,
        groupUuid,
        memberUserId,
        memberRemoteId,
        role,
        isDirty,
        isDeleted,
        syncedAt,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'group_members';
  @override
  VerificationContext validateIntegrity(Insertable<GroupMember> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('remote_id')) {
      context.handle(_remoteIdMeta,
          remoteId.isAcceptableOrUnknown(data['remote_id']!, _remoteIdMeta));
    }
    if (data.containsKey('group_id')) {
      context.handle(_groupIdMeta,
          groupId.isAcceptableOrUnknown(data['group_id']!, _groupIdMeta));
    } else if (isInserting) {
      context.missing(_groupIdMeta);
    }
    if (data.containsKey('group_uuid')) {
      context.handle(_groupUuidMeta,
          groupUuid.isAcceptableOrUnknown(data['group_uuid']!, _groupUuidMeta));
    } else if (isInserting) {
      context.missing(_groupUuidMeta);
    }
    if (data.containsKey('member_user_id')) {
      context.handle(
          _memberUserIdMeta,
          memberUserId.isAcceptableOrUnknown(
              data['member_user_id']!, _memberUserIdMeta));
    } else if (isInserting) {
      context.missing(_memberUserIdMeta);
    }
    if (data.containsKey('member_remote_id')) {
      context.handle(
          _memberRemoteIdMeta,
          memberRemoteId.isAcceptableOrUnknown(
              data['member_remote_id']!, _memberRemoteIdMeta));
    }
    if (data.containsKey('role')) {
      context.handle(
          _roleMeta, role.isAcceptableOrUnknown(data['role']!, _roleMeta));
    }
    if (data.containsKey('is_dirty')) {
      context.handle(_isDirtyMeta,
          isDirty.isAcceptableOrUnknown(data['is_dirty']!, _isDirtyMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('synced_at')) {
      context.handle(_syncedAtMeta,
          syncedAt.isAcceptableOrUnknown(data['synced_at']!, _syncedAtMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {groupId, memberUserId},
      ];
  @override
  GroupMember map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GroupMember(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      remoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}remote_id']),
      groupId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}group_id'])!,
      groupUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}group_uuid'])!,
      memberUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}member_user_id'])!,
      memberRemoteId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}member_remote_id']),
      role: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}role'])!,
      isDirty: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_dirty'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      syncedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}synced_at']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $GroupMembersTable createAlias(String alias) {
    return $GroupMembersTable(attachedDatabase, alias);
  }
}

class GroupMember extends DataClass implements Insertable<GroupMember> {
  final int id;
  final String uuid;
  final String? remoteId;
  final int groupId;
  final String groupUuid;
  final int memberUserId;
  final String? memberRemoteId;
  final String role;
  final bool isDirty;
  final bool isDeleted;
  final DateTime? syncedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const GroupMember(
      {required this.id,
      required this.uuid,
      this.remoteId,
      required this.groupId,
      required this.groupUuid,
      required this.memberUserId,
      this.memberRemoteId,
      required this.role,
      required this.isDirty,
      required this.isDeleted,
      this.syncedAt,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    if (!nullToAbsent || remoteId != null) {
      map['remote_id'] = Variable<String>(remoteId);
    }
    map['group_id'] = Variable<int>(groupId);
    map['group_uuid'] = Variable<String>(groupUuid);
    map['member_user_id'] = Variable<int>(memberUserId);
    if (!nullToAbsent || memberRemoteId != null) {
      map['member_remote_id'] = Variable<String>(memberRemoteId);
    }
    map['role'] = Variable<String>(role);
    map['is_dirty'] = Variable<bool>(isDirty);
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || syncedAt != null) {
      map['synced_at'] = Variable<DateTime>(syncedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  GroupMembersCompanion toCompanion(bool nullToAbsent) {
    return GroupMembersCompanion(
      id: Value(id),
      uuid: Value(uuid),
      remoteId: remoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(remoteId),
      groupId: Value(groupId),
      groupUuid: Value(groupUuid),
      memberUserId: Value(memberUserId),
      memberRemoteId: memberRemoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(memberRemoteId),
      role: Value(role),
      isDirty: Value(isDirty),
      isDeleted: Value(isDeleted),
      syncedAt: syncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory GroupMember.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GroupMember(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      remoteId: serializer.fromJson<String?>(json['remoteId']),
      groupId: serializer.fromJson<int>(json['groupId']),
      groupUuid: serializer.fromJson<String>(json['groupUuid']),
      memberUserId: serializer.fromJson<int>(json['memberUserId']),
      memberRemoteId: serializer.fromJson<String?>(json['memberRemoteId']),
      role: serializer.fromJson<String>(json['role']),
      isDirty: serializer.fromJson<bool>(json['isDirty']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      syncedAt: serializer.fromJson<DateTime?>(json['syncedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'remoteId': serializer.toJson<String?>(remoteId),
      'groupId': serializer.toJson<int>(groupId),
      'groupUuid': serializer.toJson<String>(groupUuid),
      'memberUserId': serializer.toJson<int>(memberUserId),
      'memberRemoteId': serializer.toJson<String?>(memberRemoteId),
      'role': serializer.toJson<String>(role),
      'isDirty': serializer.toJson<bool>(isDirty),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'syncedAt': serializer.toJson<DateTime?>(syncedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  GroupMember copyWith(
          {int? id,
          String? uuid,
          Value<String?> remoteId = const Value.absent(),
          int? groupId,
          String? groupUuid,
          int? memberUserId,
          Value<String?> memberRemoteId = const Value.absent(),
          String? role,
          bool? isDirty,
          bool? isDeleted,
          Value<DateTime?> syncedAt = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      GroupMember(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        remoteId: remoteId.present ? remoteId.value : this.remoteId,
        groupId: groupId ?? this.groupId,
        groupUuid: groupUuid ?? this.groupUuid,
        memberUserId: memberUserId ?? this.memberUserId,
        memberRemoteId:
            memberRemoteId.present ? memberRemoteId.value : this.memberRemoteId,
        role: role ?? this.role,
        isDirty: isDirty ?? this.isDirty,
        isDeleted: isDeleted ?? this.isDeleted,
        syncedAt: syncedAt.present ? syncedAt.value : this.syncedAt,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  GroupMember copyWithCompanion(GroupMembersCompanion data) {
    return GroupMember(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      remoteId: data.remoteId.present ? data.remoteId.value : this.remoteId,
      groupId: data.groupId.present ? data.groupId.value : this.groupId,
      groupUuid: data.groupUuid.present ? data.groupUuid.value : this.groupUuid,
      memberUserId: data.memberUserId.present
          ? data.memberUserId.value
          : this.memberUserId,
      memberRemoteId: data.memberRemoteId.present
          ? data.memberRemoteId.value
          : this.memberRemoteId,
      role: data.role.present ? data.role.value : this.role,
      isDirty: data.isDirty.present ? data.isDirty.value : this.isDirty,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      syncedAt: data.syncedAt.present ? data.syncedAt.value : this.syncedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GroupMember(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('groupId: $groupId, ')
          ..write('groupUuid: $groupUuid, ')
          ..write('memberUserId: $memberUserId, ')
          ..write('memberRemoteId: $memberRemoteId, ')
          ..write('role: $role, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      remoteId,
      groupId,
      groupUuid,
      memberUserId,
      memberRemoteId,
      role,
      isDirty,
      isDeleted,
      syncedAt,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GroupMember &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.remoteId == this.remoteId &&
          other.groupId == this.groupId &&
          other.groupUuid == this.groupUuid &&
          other.memberUserId == this.memberUserId &&
          other.memberRemoteId == this.memberRemoteId &&
          other.role == this.role &&
          other.isDirty == this.isDirty &&
          other.isDeleted == this.isDeleted &&
          other.syncedAt == this.syncedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class GroupMembersCompanion extends UpdateCompanion<GroupMember> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String?> remoteId;
  final Value<int> groupId;
  final Value<String> groupUuid;
  final Value<int> memberUserId;
  final Value<String?> memberRemoteId;
  final Value<String> role;
  final Value<bool> isDirty;
  final Value<bool> isDeleted;
  final Value<DateTime?> syncedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const GroupMembersCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.remoteId = const Value.absent(),
    this.groupId = const Value.absent(),
    this.groupUuid = const Value.absent(),
    this.memberUserId = const Value.absent(),
    this.memberRemoteId = const Value.absent(),
    this.role = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  GroupMembersCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    this.remoteId = const Value.absent(),
    required int groupId,
    required String groupUuid,
    required int memberUserId,
    this.memberRemoteId = const Value.absent(),
    this.role = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        groupId = Value(groupId),
        groupUuid = Value(groupUuid),
        memberUserId = Value(memberUserId);
  static Insertable<GroupMember> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? remoteId,
    Expression<int>? groupId,
    Expression<String>? groupUuid,
    Expression<int>? memberUserId,
    Expression<String>? memberRemoteId,
    Expression<String>? role,
    Expression<bool>? isDirty,
    Expression<bool>? isDeleted,
    Expression<DateTime>? syncedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (remoteId != null) 'remote_id': remoteId,
      if (groupId != null) 'group_id': groupId,
      if (groupUuid != null) 'group_uuid': groupUuid,
      if (memberUserId != null) 'member_user_id': memberUserId,
      if (memberRemoteId != null) 'member_remote_id': memberRemoteId,
      if (role != null) 'role': role,
      if (isDirty != null) 'is_dirty': isDirty,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (syncedAt != null) 'synced_at': syncedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  GroupMembersCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String?>? remoteId,
      Value<int>? groupId,
      Value<String>? groupUuid,
      Value<int>? memberUserId,
      Value<String?>? memberRemoteId,
      Value<String>? role,
      Value<bool>? isDirty,
      Value<bool>? isDeleted,
      Value<DateTime?>? syncedAt,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return GroupMembersCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      remoteId: remoteId ?? this.remoteId,
      groupId: groupId ?? this.groupId,
      groupUuid: groupUuid ?? this.groupUuid,
      memberUserId: memberUserId ?? this.memberUserId,
      memberRemoteId: memberRemoteId ?? this.memberRemoteId,
      role: role ?? this.role,
      isDirty: isDirty ?? this.isDirty,
      isDeleted: isDeleted ?? this.isDeleted,
      syncedAt: syncedAt ?? this.syncedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (remoteId.present) {
      map['remote_id'] = Variable<String>(remoteId.value);
    }
    if (groupId.present) {
      map['group_id'] = Variable<int>(groupId.value);
    }
    if (groupUuid.present) {
      map['group_uuid'] = Variable<String>(groupUuid.value);
    }
    if (memberUserId.present) {
      map['member_user_id'] = Variable<int>(memberUserId.value);
    }
    if (memberRemoteId.present) {
      map['member_remote_id'] = Variable<String>(memberRemoteId.value);
    }
    if (role.present) {
      map['role'] = Variable<String>(role.value);
    }
    if (isDirty.present) {
      map['is_dirty'] = Variable<bool>(isDirty.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (syncedAt.present) {
      map['synced_at'] = Variable<DateTime>(syncedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GroupMembersCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('groupId: $groupId, ')
          ..write('groupUuid: $groupUuid, ')
          ..write('memberUserId: $memberUserId, ')
          ..write('memberRemoteId: $memberRemoteId, ')
          ..write('role: $role, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $SharedBooksTable extends SharedBooks
    with TableInfo<$SharedBooksTable, SharedBook> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SharedBooksTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _remoteIdMeta =
      const VerificationMeta('remoteId');
  @override
  late final GeneratedColumn<String> remoteId = GeneratedColumn<String>(
      'remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _groupIdMeta =
      const VerificationMeta('groupId');
  @override
  late final GeneratedColumn<int> groupId = GeneratedColumn<int>(
      'group_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES "groups" (id) ON DELETE CASCADE'));
  static const VerificationMeta _groupUuidMeta =
      const VerificationMeta('groupUuid');
  @override
  late final GeneratedColumn<String> groupUuid = GeneratedColumn<String>(
      'group_uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _bookIdMeta = const VerificationMeta('bookId');
  @override
  late final GeneratedColumn<int> bookId = GeneratedColumn<int>(
      'book_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES books (id) ON DELETE CASCADE'));
  static const VerificationMeta _bookUuidMeta =
      const VerificationMeta('bookUuid');
  @override
  late final GeneratedColumn<String> bookUuid = GeneratedColumn<String>(
      'book_uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _ownerUserIdMeta =
      const VerificationMeta('ownerUserId');
  @override
  late final GeneratedColumn<int> ownerUserId = GeneratedColumn<int>(
      'owner_user_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES local_users (id)'));
  static const VerificationMeta _ownerRemoteIdMeta =
      const VerificationMeta('ownerRemoteId');
  @override
  late final GeneratedColumn<String> ownerRemoteId = GeneratedColumn<String>(
      'owner_remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _visibilityMeta =
      const VerificationMeta('visibility');
  @override
  late final GeneratedColumn<String> visibility = GeneratedColumn<String>(
      'visibility', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 32),
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('group'));
  static const VerificationMeta _isAvailableMeta =
      const VerificationMeta('isAvailable');
  @override
  late final GeneratedColumn<bool> isAvailable = GeneratedColumn<bool>(
      'is_available', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'CHECK ("is_available" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _genreMeta = const VerificationMeta('genre');
  @override
  late final GeneratedColumn<String> genre = GeneratedColumn<String>(
      'genre', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDirtyMeta =
      const VerificationMeta('isDirty');
  @override
  late final GeneratedColumn<bool> isDirty = GeneratedColumn<bool>(
      'is_dirty', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_dirty" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _syncedAtMeta =
      const VerificationMeta('syncedAt');
  @override
  late final GeneratedColumn<DateTime> syncedAt = GeneratedColumn<DateTime>(
      'synced_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        remoteId,
        groupId,
        groupUuid,
        bookId,
        bookUuid,
        ownerUserId,
        ownerRemoteId,
        visibility,
        isAvailable,
        genre,
        isDirty,
        isDeleted,
        syncedAt,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'shared_books';
  @override
  VerificationContext validateIntegrity(Insertable<SharedBook> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('remote_id')) {
      context.handle(_remoteIdMeta,
          remoteId.isAcceptableOrUnknown(data['remote_id']!, _remoteIdMeta));
    }
    if (data.containsKey('group_id')) {
      context.handle(_groupIdMeta,
          groupId.isAcceptableOrUnknown(data['group_id']!, _groupIdMeta));
    } else if (isInserting) {
      context.missing(_groupIdMeta);
    }
    if (data.containsKey('group_uuid')) {
      context.handle(_groupUuidMeta,
          groupUuid.isAcceptableOrUnknown(data['group_uuid']!, _groupUuidMeta));
    } else if (isInserting) {
      context.missing(_groupUuidMeta);
    }
    if (data.containsKey('book_id')) {
      context.handle(_bookIdMeta,
          bookId.isAcceptableOrUnknown(data['book_id']!, _bookIdMeta));
    } else if (isInserting) {
      context.missing(_bookIdMeta);
    }
    if (data.containsKey('book_uuid')) {
      context.handle(_bookUuidMeta,
          bookUuid.isAcceptableOrUnknown(data['book_uuid']!, _bookUuidMeta));
    } else if (isInserting) {
      context.missing(_bookUuidMeta);
    }
    if (data.containsKey('owner_user_id')) {
      context.handle(
          _ownerUserIdMeta,
          ownerUserId.isAcceptableOrUnknown(
              data['owner_user_id']!, _ownerUserIdMeta));
    } else if (isInserting) {
      context.missing(_ownerUserIdMeta);
    }
    if (data.containsKey('owner_remote_id')) {
      context.handle(
          _ownerRemoteIdMeta,
          ownerRemoteId.isAcceptableOrUnknown(
              data['owner_remote_id']!, _ownerRemoteIdMeta));
    }
    if (data.containsKey('visibility')) {
      context.handle(
          _visibilityMeta,
          visibility.isAcceptableOrUnknown(
              data['visibility']!, _visibilityMeta));
    }
    if (data.containsKey('is_available')) {
      context.handle(
          _isAvailableMeta,
          isAvailable.isAcceptableOrUnknown(
              data['is_available']!, _isAvailableMeta));
    }
    if (data.containsKey('genre')) {
      context.handle(
          _genreMeta, genre.isAcceptableOrUnknown(data['genre']!, _genreMeta));
    }
    if (data.containsKey('is_dirty')) {
      context.handle(_isDirtyMeta,
          isDirty.isAcceptableOrUnknown(data['is_dirty']!, _isDirtyMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('synced_at')) {
      context.handle(_syncedAtMeta,
          syncedAt.isAcceptableOrUnknown(data['synced_at']!, _syncedAtMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SharedBook map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SharedBook(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      remoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}remote_id']),
      groupId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}group_id'])!,
      groupUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}group_uuid'])!,
      bookId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}book_id'])!,
      bookUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}book_uuid'])!,
      ownerUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}owner_user_id'])!,
      ownerRemoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}owner_remote_id']),
      visibility: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}visibility'])!,
      isAvailable: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_available'])!,
      genre: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}genre']),
      isDirty: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_dirty'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      syncedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}synced_at']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $SharedBooksTable createAlias(String alias) {
    return $SharedBooksTable(attachedDatabase, alias);
  }
}

class SharedBook extends DataClass implements Insertable<SharedBook> {
  final int id;
  final String uuid;
  final String? remoteId;
  final int groupId;
  final String groupUuid;
  final int bookId;
  final String bookUuid;
  final int ownerUserId;
  final String? ownerRemoteId;
  final String visibility;
  final bool isAvailable;
  final String? genre;
  final bool isDirty;
  final bool isDeleted;
  final DateTime? syncedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const SharedBook(
      {required this.id,
      required this.uuid,
      this.remoteId,
      required this.groupId,
      required this.groupUuid,
      required this.bookId,
      required this.bookUuid,
      required this.ownerUserId,
      this.ownerRemoteId,
      required this.visibility,
      required this.isAvailable,
      this.genre,
      required this.isDirty,
      required this.isDeleted,
      this.syncedAt,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    if (!nullToAbsent || remoteId != null) {
      map['remote_id'] = Variable<String>(remoteId);
    }
    map['group_id'] = Variable<int>(groupId);
    map['group_uuid'] = Variable<String>(groupUuid);
    map['book_id'] = Variable<int>(bookId);
    map['book_uuid'] = Variable<String>(bookUuid);
    map['owner_user_id'] = Variable<int>(ownerUserId);
    if (!nullToAbsent || ownerRemoteId != null) {
      map['owner_remote_id'] = Variable<String>(ownerRemoteId);
    }
    map['visibility'] = Variable<String>(visibility);
    map['is_available'] = Variable<bool>(isAvailable);
    if (!nullToAbsent || genre != null) {
      map['genre'] = Variable<String>(genre);
    }
    map['is_dirty'] = Variable<bool>(isDirty);
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || syncedAt != null) {
      map['synced_at'] = Variable<DateTime>(syncedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  SharedBooksCompanion toCompanion(bool nullToAbsent) {
    return SharedBooksCompanion(
      id: Value(id),
      uuid: Value(uuid),
      remoteId: remoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(remoteId),
      groupId: Value(groupId),
      groupUuid: Value(groupUuid),
      bookId: Value(bookId),
      bookUuid: Value(bookUuid),
      ownerUserId: Value(ownerUserId),
      ownerRemoteId: ownerRemoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(ownerRemoteId),
      visibility: Value(visibility),
      isAvailable: Value(isAvailable),
      genre:
          genre == null && nullToAbsent ? const Value.absent() : Value(genre),
      isDirty: Value(isDirty),
      isDeleted: Value(isDeleted),
      syncedAt: syncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory SharedBook.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SharedBook(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      remoteId: serializer.fromJson<String?>(json['remoteId']),
      groupId: serializer.fromJson<int>(json['groupId']),
      groupUuid: serializer.fromJson<String>(json['groupUuid']),
      bookId: serializer.fromJson<int>(json['bookId']),
      bookUuid: serializer.fromJson<String>(json['bookUuid']),
      ownerUserId: serializer.fromJson<int>(json['ownerUserId']),
      ownerRemoteId: serializer.fromJson<String?>(json['ownerRemoteId']),
      visibility: serializer.fromJson<String>(json['visibility']),
      isAvailable: serializer.fromJson<bool>(json['isAvailable']),
      genre: serializer.fromJson<String?>(json['genre']),
      isDirty: serializer.fromJson<bool>(json['isDirty']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      syncedAt: serializer.fromJson<DateTime?>(json['syncedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'remoteId': serializer.toJson<String?>(remoteId),
      'groupId': serializer.toJson<int>(groupId),
      'groupUuid': serializer.toJson<String>(groupUuid),
      'bookId': serializer.toJson<int>(bookId),
      'bookUuid': serializer.toJson<String>(bookUuid),
      'ownerUserId': serializer.toJson<int>(ownerUserId),
      'ownerRemoteId': serializer.toJson<String?>(ownerRemoteId),
      'visibility': serializer.toJson<String>(visibility),
      'isAvailable': serializer.toJson<bool>(isAvailable),
      'genre': serializer.toJson<String?>(genre),
      'isDirty': serializer.toJson<bool>(isDirty),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'syncedAt': serializer.toJson<DateTime?>(syncedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  SharedBook copyWith(
          {int? id,
          String? uuid,
          Value<String?> remoteId = const Value.absent(),
          int? groupId,
          String? groupUuid,
          int? bookId,
          String? bookUuid,
          int? ownerUserId,
          Value<String?> ownerRemoteId = const Value.absent(),
          String? visibility,
          bool? isAvailable,
          Value<String?> genre = const Value.absent(),
          bool? isDirty,
          bool? isDeleted,
          Value<DateTime?> syncedAt = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      SharedBook(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        remoteId: remoteId.present ? remoteId.value : this.remoteId,
        groupId: groupId ?? this.groupId,
        groupUuid: groupUuid ?? this.groupUuid,
        bookId: bookId ?? this.bookId,
        bookUuid: bookUuid ?? this.bookUuid,
        ownerUserId: ownerUserId ?? this.ownerUserId,
        ownerRemoteId:
            ownerRemoteId.present ? ownerRemoteId.value : this.ownerRemoteId,
        visibility: visibility ?? this.visibility,
        isAvailable: isAvailable ?? this.isAvailable,
        genre: genre.present ? genre.value : this.genre,
        isDirty: isDirty ?? this.isDirty,
        isDeleted: isDeleted ?? this.isDeleted,
        syncedAt: syncedAt.present ? syncedAt.value : this.syncedAt,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  SharedBook copyWithCompanion(SharedBooksCompanion data) {
    return SharedBook(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      remoteId: data.remoteId.present ? data.remoteId.value : this.remoteId,
      groupId: data.groupId.present ? data.groupId.value : this.groupId,
      groupUuid: data.groupUuid.present ? data.groupUuid.value : this.groupUuid,
      bookId: data.bookId.present ? data.bookId.value : this.bookId,
      bookUuid: data.bookUuid.present ? data.bookUuid.value : this.bookUuid,
      ownerUserId:
          data.ownerUserId.present ? data.ownerUserId.value : this.ownerUserId,
      ownerRemoteId: data.ownerRemoteId.present
          ? data.ownerRemoteId.value
          : this.ownerRemoteId,
      visibility:
          data.visibility.present ? data.visibility.value : this.visibility,
      isAvailable:
          data.isAvailable.present ? data.isAvailable.value : this.isAvailable,
      genre: data.genre.present ? data.genre.value : this.genre,
      isDirty: data.isDirty.present ? data.isDirty.value : this.isDirty,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      syncedAt: data.syncedAt.present ? data.syncedAt.value : this.syncedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SharedBook(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('groupId: $groupId, ')
          ..write('groupUuid: $groupUuid, ')
          ..write('bookId: $bookId, ')
          ..write('bookUuid: $bookUuid, ')
          ..write('ownerUserId: $ownerUserId, ')
          ..write('ownerRemoteId: $ownerRemoteId, ')
          ..write('visibility: $visibility, ')
          ..write('isAvailable: $isAvailable, ')
          ..write('genre: $genre, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      remoteId,
      groupId,
      groupUuid,
      bookId,
      bookUuid,
      ownerUserId,
      ownerRemoteId,
      visibility,
      isAvailable,
      genre,
      isDirty,
      isDeleted,
      syncedAt,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SharedBook &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.remoteId == this.remoteId &&
          other.groupId == this.groupId &&
          other.groupUuid == this.groupUuid &&
          other.bookId == this.bookId &&
          other.bookUuid == this.bookUuid &&
          other.ownerUserId == this.ownerUserId &&
          other.ownerRemoteId == this.ownerRemoteId &&
          other.visibility == this.visibility &&
          other.isAvailable == this.isAvailable &&
          other.genre == this.genre &&
          other.isDirty == this.isDirty &&
          other.isDeleted == this.isDeleted &&
          other.syncedAt == this.syncedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class SharedBooksCompanion extends UpdateCompanion<SharedBook> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String?> remoteId;
  final Value<int> groupId;
  final Value<String> groupUuid;
  final Value<int> bookId;
  final Value<String> bookUuid;
  final Value<int> ownerUserId;
  final Value<String?> ownerRemoteId;
  final Value<String> visibility;
  final Value<bool> isAvailable;
  final Value<String?> genre;
  final Value<bool> isDirty;
  final Value<bool> isDeleted;
  final Value<DateTime?> syncedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const SharedBooksCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.remoteId = const Value.absent(),
    this.groupId = const Value.absent(),
    this.groupUuid = const Value.absent(),
    this.bookId = const Value.absent(),
    this.bookUuid = const Value.absent(),
    this.ownerUserId = const Value.absent(),
    this.ownerRemoteId = const Value.absent(),
    this.visibility = const Value.absent(),
    this.isAvailable = const Value.absent(),
    this.genre = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  SharedBooksCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    this.remoteId = const Value.absent(),
    required int groupId,
    required String groupUuid,
    required int bookId,
    required String bookUuid,
    required int ownerUserId,
    this.ownerRemoteId = const Value.absent(),
    this.visibility = const Value.absent(),
    this.isAvailable = const Value.absent(),
    this.genre = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        groupId = Value(groupId),
        groupUuid = Value(groupUuid),
        bookId = Value(bookId),
        bookUuid = Value(bookUuid),
        ownerUserId = Value(ownerUserId);
  static Insertable<SharedBook> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? remoteId,
    Expression<int>? groupId,
    Expression<String>? groupUuid,
    Expression<int>? bookId,
    Expression<String>? bookUuid,
    Expression<int>? ownerUserId,
    Expression<String>? ownerRemoteId,
    Expression<String>? visibility,
    Expression<bool>? isAvailable,
    Expression<String>? genre,
    Expression<bool>? isDirty,
    Expression<bool>? isDeleted,
    Expression<DateTime>? syncedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (remoteId != null) 'remote_id': remoteId,
      if (groupId != null) 'group_id': groupId,
      if (groupUuid != null) 'group_uuid': groupUuid,
      if (bookId != null) 'book_id': bookId,
      if (bookUuid != null) 'book_uuid': bookUuid,
      if (ownerUserId != null) 'owner_user_id': ownerUserId,
      if (ownerRemoteId != null) 'owner_remote_id': ownerRemoteId,
      if (visibility != null) 'visibility': visibility,
      if (isAvailable != null) 'is_available': isAvailable,
      if (genre != null) 'genre': genre,
      if (isDirty != null) 'is_dirty': isDirty,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (syncedAt != null) 'synced_at': syncedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  SharedBooksCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String?>? remoteId,
      Value<int>? groupId,
      Value<String>? groupUuid,
      Value<int>? bookId,
      Value<String>? bookUuid,
      Value<int>? ownerUserId,
      Value<String?>? ownerRemoteId,
      Value<String>? visibility,
      Value<bool>? isAvailable,
      Value<String?>? genre,
      Value<bool>? isDirty,
      Value<bool>? isDeleted,
      Value<DateTime?>? syncedAt,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return SharedBooksCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      remoteId: remoteId ?? this.remoteId,
      groupId: groupId ?? this.groupId,
      groupUuid: groupUuid ?? this.groupUuid,
      bookId: bookId ?? this.bookId,
      bookUuid: bookUuid ?? this.bookUuid,
      ownerUserId: ownerUserId ?? this.ownerUserId,
      ownerRemoteId: ownerRemoteId ?? this.ownerRemoteId,
      visibility: visibility ?? this.visibility,
      isAvailable: isAvailable ?? this.isAvailable,
      genre: genre ?? this.genre,
      isDirty: isDirty ?? this.isDirty,
      isDeleted: isDeleted ?? this.isDeleted,
      syncedAt: syncedAt ?? this.syncedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (remoteId.present) {
      map['remote_id'] = Variable<String>(remoteId.value);
    }
    if (groupId.present) {
      map['group_id'] = Variable<int>(groupId.value);
    }
    if (groupUuid.present) {
      map['group_uuid'] = Variable<String>(groupUuid.value);
    }
    if (bookId.present) {
      map['book_id'] = Variable<int>(bookId.value);
    }
    if (bookUuid.present) {
      map['book_uuid'] = Variable<String>(bookUuid.value);
    }
    if (ownerUserId.present) {
      map['owner_user_id'] = Variable<int>(ownerUserId.value);
    }
    if (ownerRemoteId.present) {
      map['owner_remote_id'] = Variable<String>(ownerRemoteId.value);
    }
    if (visibility.present) {
      map['visibility'] = Variable<String>(visibility.value);
    }
    if (isAvailable.present) {
      map['is_available'] = Variable<bool>(isAvailable.value);
    }
    if (genre.present) {
      map['genre'] = Variable<String>(genre.value);
    }
    if (isDirty.present) {
      map['is_dirty'] = Variable<bool>(isDirty.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (syncedAt.present) {
      map['synced_at'] = Variable<DateTime>(syncedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SharedBooksCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('groupId: $groupId, ')
          ..write('groupUuid: $groupUuid, ')
          ..write('bookId: $bookId, ')
          ..write('bookUuid: $bookUuid, ')
          ..write('ownerUserId: $ownerUserId, ')
          ..write('ownerRemoteId: $ownerRemoteId, ')
          ..write('visibility: $visibility, ')
          ..write('isAvailable: $isAvailable, ')
          ..write('genre: $genre, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $GroupInvitationsTable extends GroupInvitations
    with TableInfo<$GroupInvitationsTable, GroupInvitation> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GroupInvitationsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _remoteIdMeta =
      const VerificationMeta('remoteId');
  @override
  late final GeneratedColumn<String> remoteId = GeneratedColumn<String>(
      'remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _groupIdMeta =
      const VerificationMeta('groupId');
  @override
  late final GeneratedColumn<int> groupId = GeneratedColumn<int>(
      'group_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES "groups" (id) ON DELETE CASCADE'));
  static const VerificationMeta _groupUuidMeta =
      const VerificationMeta('groupUuid');
  @override
  late final GeneratedColumn<String> groupUuid = GeneratedColumn<String>(
      'group_uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _inviterUserIdMeta =
      const VerificationMeta('inviterUserId');
  @override
  late final GeneratedColumn<int> inviterUserId = GeneratedColumn<int>(
      'inviter_user_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES local_users (id)'));
  static const VerificationMeta _inviterRemoteIdMeta =
      const VerificationMeta('inviterRemoteId');
  @override
  late final GeneratedColumn<String> inviterRemoteId = GeneratedColumn<String>(
      'inviter_remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _acceptedUserIdMeta =
      const VerificationMeta('acceptedUserId');
  @override
  late final GeneratedColumn<int> acceptedUserId = GeneratedColumn<int>(
      'accepted_user_id', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES local_users (id)'));
  static const VerificationMeta _acceptedUserRemoteIdMeta =
      const VerificationMeta('acceptedUserRemoteId');
  @override
  late final GeneratedColumn<String> acceptedUserRemoteId =
      GeneratedColumn<String>('accepted_user_remote_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _roleMeta = const VerificationMeta('role');
  @override
  late final GeneratedColumn<String> role = GeneratedColumn<String>(
      'role', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 32),
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('member'));
  static const VerificationMeta _codeMeta = const VerificationMeta('code');
  @override
  late final GeneratedColumn<String> code = GeneratedColumn<String>(
      'code', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 64),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 32),
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('pending'));
  static const VerificationMeta _expiresAtMeta =
      const VerificationMeta('expiresAt');
  @override
  late final GeneratedColumn<DateTime> expiresAt = GeneratedColumn<DateTime>(
      'expires_at', aliasedName, false,
      type: DriftSqlType.dateTime, requiredDuringInsert: true);
  static const VerificationMeta _respondedAtMeta =
      const VerificationMeta('respondedAt');
  @override
  late final GeneratedColumn<DateTime> respondedAt = GeneratedColumn<DateTime>(
      'responded_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _isDirtyMeta =
      const VerificationMeta('isDirty');
  @override
  late final GeneratedColumn<bool> isDirty = GeneratedColumn<bool>(
      'is_dirty', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_dirty" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _syncedAtMeta =
      const VerificationMeta('syncedAt');
  @override
  late final GeneratedColumn<DateTime> syncedAt = GeneratedColumn<DateTime>(
      'synced_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        remoteId,
        groupId,
        groupUuid,
        inviterUserId,
        inviterRemoteId,
        acceptedUserId,
        acceptedUserRemoteId,
        role,
        code,
        status,
        expiresAt,
        respondedAt,
        isDirty,
        isDeleted,
        syncedAt,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'group_invitations';
  @override
  VerificationContext validateIntegrity(Insertable<GroupInvitation> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('remote_id')) {
      context.handle(_remoteIdMeta,
          remoteId.isAcceptableOrUnknown(data['remote_id']!, _remoteIdMeta));
    }
    if (data.containsKey('group_id')) {
      context.handle(_groupIdMeta,
          groupId.isAcceptableOrUnknown(data['group_id']!, _groupIdMeta));
    } else if (isInserting) {
      context.missing(_groupIdMeta);
    }
    if (data.containsKey('group_uuid')) {
      context.handle(_groupUuidMeta,
          groupUuid.isAcceptableOrUnknown(data['group_uuid']!, _groupUuidMeta));
    } else if (isInserting) {
      context.missing(_groupUuidMeta);
    }
    if (data.containsKey('inviter_user_id')) {
      context.handle(
          _inviterUserIdMeta,
          inviterUserId.isAcceptableOrUnknown(
              data['inviter_user_id']!, _inviterUserIdMeta));
    } else if (isInserting) {
      context.missing(_inviterUserIdMeta);
    }
    if (data.containsKey('inviter_remote_id')) {
      context.handle(
          _inviterRemoteIdMeta,
          inviterRemoteId.isAcceptableOrUnknown(
              data['inviter_remote_id']!, _inviterRemoteIdMeta));
    }
    if (data.containsKey('accepted_user_id')) {
      context.handle(
          _acceptedUserIdMeta,
          acceptedUserId.isAcceptableOrUnknown(
              data['accepted_user_id']!, _acceptedUserIdMeta));
    }
    if (data.containsKey('accepted_user_remote_id')) {
      context.handle(
          _acceptedUserRemoteIdMeta,
          acceptedUserRemoteId.isAcceptableOrUnknown(
              data['accepted_user_remote_id']!, _acceptedUserRemoteIdMeta));
    }
    if (data.containsKey('role')) {
      context.handle(
          _roleMeta, role.isAcceptableOrUnknown(data['role']!, _roleMeta));
    }
    if (data.containsKey('code')) {
      context.handle(
          _codeMeta, code.isAcceptableOrUnknown(data['code']!, _codeMeta));
    } else if (isInserting) {
      context.missing(_codeMeta);
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('expires_at')) {
      context.handle(_expiresAtMeta,
          expiresAt.isAcceptableOrUnknown(data['expires_at']!, _expiresAtMeta));
    } else if (isInserting) {
      context.missing(_expiresAtMeta);
    }
    if (data.containsKey('responded_at')) {
      context.handle(
          _respondedAtMeta,
          respondedAt.isAcceptableOrUnknown(
              data['responded_at']!, _respondedAtMeta));
    }
    if (data.containsKey('is_dirty')) {
      context.handle(_isDirtyMeta,
          isDirty.isAcceptableOrUnknown(data['is_dirty']!, _isDirtyMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('synced_at')) {
      context.handle(_syncedAtMeta,
          syncedAt.isAcceptableOrUnknown(data['synced_at']!, _syncedAtMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  GroupInvitation map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GroupInvitation(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      remoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}remote_id']),
      groupId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}group_id'])!,
      groupUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}group_uuid'])!,
      inviterUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}inviter_user_id'])!,
      inviterRemoteId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}inviter_remote_id']),
      acceptedUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}accepted_user_id']),
      acceptedUserRemoteId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}accepted_user_remote_id']),
      role: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}role'])!,
      code: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}code'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      expiresAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}expires_at'])!,
      respondedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}responded_at']),
      isDirty: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_dirty'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      syncedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}synced_at']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $GroupInvitationsTable createAlias(String alias) {
    return $GroupInvitationsTable(attachedDatabase, alias);
  }
}

class GroupInvitation extends DataClass implements Insertable<GroupInvitation> {
  final int id;
  final String uuid;
  final String? remoteId;
  final int groupId;
  final String groupUuid;
  final int inviterUserId;
  final String? inviterRemoteId;
  final int? acceptedUserId;
  final String? acceptedUserRemoteId;
  final String role;
  final String code;
  final String status;
  final DateTime expiresAt;
  final DateTime? respondedAt;
  final bool isDirty;
  final bool isDeleted;
  final DateTime? syncedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const GroupInvitation(
      {required this.id,
      required this.uuid,
      this.remoteId,
      required this.groupId,
      required this.groupUuid,
      required this.inviterUserId,
      this.inviterRemoteId,
      this.acceptedUserId,
      this.acceptedUserRemoteId,
      required this.role,
      required this.code,
      required this.status,
      required this.expiresAt,
      this.respondedAt,
      required this.isDirty,
      required this.isDeleted,
      this.syncedAt,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    if (!nullToAbsent || remoteId != null) {
      map['remote_id'] = Variable<String>(remoteId);
    }
    map['group_id'] = Variable<int>(groupId);
    map['group_uuid'] = Variable<String>(groupUuid);
    map['inviter_user_id'] = Variable<int>(inviterUserId);
    if (!nullToAbsent || inviterRemoteId != null) {
      map['inviter_remote_id'] = Variable<String>(inviterRemoteId);
    }
    if (!nullToAbsent || acceptedUserId != null) {
      map['accepted_user_id'] = Variable<int>(acceptedUserId);
    }
    if (!nullToAbsent || acceptedUserRemoteId != null) {
      map['accepted_user_remote_id'] = Variable<String>(acceptedUserRemoteId);
    }
    map['role'] = Variable<String>(role);
    map['code'] = Variable<String>(code);
    map['status'] = Variable<String>(status);
    map['expires_at'] = Variable<DateTime>(expiresAt);
    if (!nullToAbsent || respondedAt != null) {
      map['responded_at'] = Variable<DateTime>(respondedAt);
    }
    map['is_dirty'] = Variable<bool>(isDirty);
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || syncedAt != null) {
      map['synced_at'] = Variable<DateTime>(syncedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  GroupInvitationsCompanion toCompanion(bool nullToAbsent) {
    return GroupInvitationsCompanion(
      id: Value(id),
      uuid: Value(uuid),
      remoteId: remoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(remoteId),
      groupId: Value(groupId),
      groupUuid: Value(groupUuid),
      inviterUserId: Value(inviterUserId),
      inviterRemoteId: inviterRemoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(inviterRemoteId),
      acceptedUserId: acceptedUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(acceptedUserId),
      acceptedUserRemoteId: acceptedUserRemoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(acceptedUserRemoteId),
      role: Value(role),
      code: Value(code),
      status: Value(status),
      expiresAt: Value(expiresAt),
      respondedAt: respondedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(respondedAt),
      isDirty: Value(isDirty),
      isDeleted: Value(isDeleted),
      syncedAt: syncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory GroupInvitation.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GroupInvitation(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      remoteId: serializer.fromJson<String?>(json['remoteId']),
      groupId: serializer.fromJson<int>(json['groupId']),
      groupUuid: serializer.fromJson<String>(json['groupUuid']),
      inviterUserId: serializer.fromJson<int>(json['inviterUserId']),
      inviterRemoteId: serializer.fromJson<String?>(json['inviterRemoteId']),
      acceptedUserId: serializer.fromJson<int?>(json['acceptedUserId']),
      acceptedUserRemoteId:
          serializer.fromJson<String?>(json['acceptedUserRemoteId']),
      role: serializer.fromJson<String>(json['role']),
      code: serializer.fromJson<String>(json['code']),
      status: serializer.fromJson<String>(json['status']),
      expiresAt: serializer.fromJson<DateTime>(json['expiresAt']),
      respondedAt: serializer.fromJson<DateTime?>(json['respondedAt']),
      isDirty: serializer.fromJson<bool>(json['isDirty']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      syncedAt: serializer.fromJson<DateTime?>(json['syncedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'remoteId': serializer.toJson<String?>(remoteId),
      'groupId': serializer.toJson<int>(groupId),
      'groupUuid': serializer.toJson<String>(groupUuid),
      'inviterUserId': serializer.toJson<int>(inviterUserId),
      'inviterRemoteId': serializer.toJson<String?>(inviterRemoteId),
      'acceptedUserId': serializer.toJson<int?>(acceptedUserId),
      'acceptedUserRemoteId': serializer.toJson<String?>(acceptedUserRemoteId),
      'role': serializer.toJson<String>(role),
      'code': serializer.toJson<String>(code),
      'status': serializer.toJson<String>(status),
      'expiresAt': serializer.toJson<DateTime>(expiresAt),
      'respondedAt': serializer.toJson<DateTime?>(respondedAt),
      'isDirty': serializer.toJson<bool>(isDirty),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'syncedAt': serializer.toJson<DateTime?>(syncedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  GroupInvitation copyWith(
          {int? id,
          String? uuid,
          Value<String?> remoteId = const Value.absent(),
          int? groupId,
          String? groupUuid,
          int? inviterUserId,
          Value<String?> inviterRemoteId = const Value.absent(),
          Value<int?> acceptedUserId = const Value.absent(),
          Value<String?> acceptedUserRemoteId = const Value.absent(),
          String? role,
          String? code,
          String? status,
          DateTime? expiresAt,
          Value<DateTime?> respondedAt = const Value.absent(),
          bool? isDirty,
          bool? isDeleted,
          Value<DateTime?> syncedAt = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      GroupInvitation(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        remoteId: remoteId.present ? remoteId.value : this.remoteId,
        groupId: groupId ?? this.groupId,
        groupUuid: groupUuid ?? this.groupUuid,
        inviterUserId: inviterUserId ?? this.inviterUserId,
        inviterRemoteId: inviterRemoteId.present
            ? inviterRemoteId.value
            : this.inviterRemoteId,
        acceptedUserId:
            acceptedUserId.present ? acceptedUserId.value : this.acceptedUserId,
        acceptedUserRemoteId: acceptedUserRemoteId.present
            ? acceptedUserRemoteId.value
            : this.acceptedUserRemoteId,
        role: role ?? this.role,
        code: code ?? this.code,
        status: status ?? this.status,
        expiresAt: expiresAt ?? this.expiresAt,
        respondedAt: respondedAt.present ? respondedAt.value : this.respondedAt,
        isDirty: isDirty ?? this.isDirty,
        isDeleted: isDeleted ?? this.isDeleted,
        syncedAt: syncedAt.present ? syncedAt.value : this.syncedAt,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  GroupInvitation copyWithCompanion(GroupInvitationsCompanion data) {
    return GroupInvitation(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      remoteId: data.remoteId.present ? data.remoteId.value : this.remoteId,
      groupId: data.groupId.present ? data.groupId.value : this.groupId,
      groupUuid: data.groupUuid.present ? data.groupUuid.value : this.groupUuid,
      inviterUserId: data.inviterUserId.present
          ? data.inviterUserId.value
          : this.inviterUserId,
      inviterRemoteId: data.inviterRemoteId.present
          ? data.inviterRemoteId.value
          : this.inviterRemoteId,
      acceptedUserId: data.acceptedUserId.present
          ? data.acceptedUserId.value
          : this.acceptedUserId,
      acceptedUserRemoteId: data.acceptedUserRemoteId.present
          ? data.acceptedUserRemoteId.value
          : this.acceptedUserRemoteId,
      role: data.role.present ? data.role.value : this.role,
      code: data.code.present ? data.code.value : this.code,
      status: data.status.present ? data.status.value : this.status,
      expiresAt: data.expiresAt.present ? data.expiresAt.value : this.expiresAt,
      respondedAt:
          data.respondedAt.present ? data.respondedAt.value : this.respondedAt,
      isDirty: data.isDirty.present ? data.isDirty.value : this.isDirty,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      syncedAt: data.syncedAt.present ? data.syncedAt.value : this.syncedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GroupInvitation(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('groupId: $groupId, ')
          ..write('groupUuid: $groupUuid, ')
          ..write('inviterUserId: $inviterUserId, ')
          ..write('inviterRemoteId: $inviterRemoteId, ')
          ..write('acceptedUserId: $acceptedUserId, ')
          ..write('acceptedUserRemoteId: $acceptedUserRemoteId, ')
          ..write('role: $role, ')
          ..write('code: $code, ')
          ..write('status: $status, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('respondedAt: $respondedAt, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      remoteId,
      groupId,
      groupUuid,
      inviterUserId,
      inviterRemoteId,
      acceptedUserId,
      acceptedUserRemoteId,
      role,
      code,
      status,
      expiresAt,
      respondedAt,
      isDirty,
      isDeleted,
      syncedAt,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GroupInvitation &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.remoteId == this.remoteId &&
          other.groupId == this.groupId &&
          other.groupUuid == this.groupUuid &&
          other.inviterUserId == this.inviterUserId &&
          other.inviterRemoteId == this.inviterRemoteId &&
          other.acceptedUserId == this.acceptedUserId &&
          other.acceptedUserRemoteId == this.acceptedUserRemoteId &&
          other.role == this.role &&
          other.code == this.code &&
          other.status == this.status &&
          other.expiresAt == this.expiresAt &&
          other.respondedAt == this.respondedAt &&
          other.isDirty == this.isDirty &&
          other.isDeleted == this.isDeleted &&
          other.syncedAt == this.syncedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class GroupInvitationsCompanion extends UpdateCompanion<GroupInvitation> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String?> remoteId;
  final Value<int> groupId;
  final Value<String> groupUuid;
  final Value<int> inviterUserId;
  final Value<String?> inviterRemoteId;
  final Value<int?> acceptedUserId;
  final Value<String?> acceptedUserRemoteId;
  final Value<String> role;
  final Value<String> code;
  final Value<String> status;
  final Value<DateTime> expiresAt;
  final Value<DateTime?> respondedAt;
  final Value<bool> isDirty;
  final Value<bool> isDeleted;
  final Value<DateTime?> syncedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const GroupInvitationsCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.remoteId = const Value.absent(),
    this.groupId = const Value.absent(),
    this.groupUuid = const Value.absent(),
    this.inviterUserId = const Value.absent(),
    this.inviterRemoteId = const Value.absent(),
    this.acceptedUserId = const Value.absent(),
    this.acceptedUserRemoteId = const Value.absent(),
    this.role = const Value.absent(),
    this.code = const Value.absent(),
    this.status = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.respondedAt = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  GroupInvitationsCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    this.remoteId = const Value.absent(),
    required int groupId,
    required String groupUuid,
    required int inviterUserId,
    this.inviterRemoteId = const Value.absent(),
    this.acceptedUserId = const Value.absent(),
    this.acceptedUserRemoteId = const Value.absent(),
    this.role = const Value.absent(),
    required String code,
    this.status = const Value.absent(),
    required DateTime expiresAt,
    this.respondedAt = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        groupId = Value(groupId),
        groupUuid = Value(groupUuid),
        inviterUserId = Value(inviterUserId),
        code = Value(code),
        expiresAt = Value(expiresAt);
  static Insertable<GroupInvitation> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? remoteId,
    Expression<int>? groupId,
    Expression<String>? groupUuid,
    Expression<int>? inviterUserId,
    Expression<String>? inviterRemoteId,
    Expression<int>? acceptedUserId,
    Expression<String>? acceptedUserRemoteId,
    Expression<String>? role,
    Expression<String>? code,
    Expression<String>? status,
    Expression<DateTime>? expiresAt,
    Expression<DateTime>? respondedAt,
    Expression<bool>? isDirty,
    Expression<bool>? isDeleted,
    Expression<DateTime>? syncedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (remoteId != null) 'remote_id': remoteId,
      if (groupId != null) 'group_id': groupId,
      if (groupUuid != null) 'group_uuid': groupUuid,
      if (inviterUserId != null) 'inviter_user_id': inviterUserId,
      if (inviterRemoteId != null) 'inviter_remote_id': inviterRemoteId,
      if (acceptedUserId != null) 'accepted_user_id': acceptedUserId,
      if (acceptedUserRemoteId != null)
        'accepted_user_remote_id': acceptedUserRemoteId,
      if (role != null) 'role': role,
      if (code != null) 'code': code,
      if (status != null) 'status': status,
      if (expiresAt != null) 'expires_at': expiresAt,
      if (respondedAt != null) 'responded_at': respondedAt,
      if (isDirty != null) 'is_dirty': isDirty,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (syncedAt != null) 'synced_at': syncedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  GroupInvitationsCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String?>? remoteId,
      Value<int>? groupId,
      Value<String>? groupUuid,
      Value<int>? inviterUserId,
      Value<String?>? inviterRemoteId,
      Value<int?>? acceptedUserId,
      Value<String?>? acceptedUserRemoteId,
      Value<String>? role,
      Value<String>? code,
      Value<String>? status,
      Value<DateTime>? expiresAt,
      Value<DateTime?>? respondedAt,
      Value<bool>? isDirty,
      Value<bool>? isDeleted,
      Value<DateTime?>? syncedAt,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return GroupInvitationsCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      remoteId: remoteId ?? this.remoteId,
      groupId: groupId ?? this.groupId,
      groupUuid: groupUuid ?? this.groupUuid,
      inviterUserId: inviterUserId ?? this.inviterUserId,
      inviterRemoteId: inviterRemoteId ?? this.inviterRemoteId,
      acceptedUserId: acceptedUserId ?? this.acceptedUserId,
      acceptedUserRemoteId: acceptedUserRemoteId ?? this.acceptedUserRemoteId,
      role: role ?? this.role,
      code: code ?? this.code,
      status: status ?? this.status,
      expiresAt: expiresAt ?? this.expiresAt,
      respondedAt: respondedAt ?? this.respondedAt,
      isDirty: isDirty ?? this.isDirty,
      isDeleted: isDeleted ?? this.isDeleted,
      syncedAt: syncedAt ?? this.syncedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (remoteId.present) {
      map['remote_id'] = Variable<String>(remoteId.value);
    }
    if (groupId.present) {
      map['group_id'] = Variable<int>(groupId.value);
    }
    if (groupUuid.present) {
      map['group_uuid'] = Variable<String>(groupUuid.value);
    }
    if (inviterUserId.present) {
      map['inviter_user_id'] = Variable<int>(inviterUserId.value);
    }
    if (inviterRemoteId.present) {
      map['inviter_remote_id'] = Variable<String>(inviterRemoteId.value);
    }
    if (acceptedUserId.present) {
      map['accepted_user_id'] = Variable<int>(acceptedUserId.value);
    }
    if (acceptedUserRemoteId.present) {
      map['accepted_user_remote_id'] =
          Variable<String>(acceptedUserRemoteId.value);
    }
    if (role.present) {
      map['role'] = Variable<String>(role.value);
    }
    if (code.present) {
      map['code'] = Variable<String>(code.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (expiresAt.present) {
      map['expires_at'] = Variable<DateTime>(expiresAt.value);
    }
    if (respondedAt.present) {
      map['responded_at'] = Variable<DateTime>(respondedAt.value);
    }
    if (isDirty.present) {
      map['is_dirty'] = Variable<bool>(isDirty.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (syncedAt.present) {
      map['synced_at'] = Variable<DateTime>(syncedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GroupInvitationsCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('groupId: $groupId, ')
          ..write('groupUuid: $groupUuid, ')
          ..write('inviterUserId: $inviterUserId, ')
          ..write('inviterRemoteId: $inviterRemoteId, ')
          ..write('acceptedUserId: $acceptedUserId, ')
          ..write('acceptedUserRemoteId: $acceptedUserRemoteId, ')
          ..write('role: $role, ')
          ..write('code: $code, ')
          ..write('status: $status, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('respondedAt: $respondedAt, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $LoansTable extends Loans with TableInfo<$LoansTable, Loan> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LoansTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _remoteIdMeta =
      const VerificationMeta('remoteId');
  @override
  late final GeneratedColumn<String> remoteId = GeneratedColumn<String>(
      'remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _sharedBookIdMeta =
      const VerificationMeta('sharedBookId');
  @override
  late final GeneratedColumn<int> sharedBookId = GeneratedColumn<int>(
      'shared_book_id', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES shared_books (id) ON DELETE CASCADE'));
  static const VerificationMeta _bookIdMeta = const VerificationMeta('bookId');
  @override
  late final GeneratedColumn<int> bookId = GeneratedColumn<int>(
      'book_id', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES books (id) ON DELETE CASCADE'));
  static const VerificationMeta _borrowerUserIdMeta =
      const VerificationMeta('borrowerUserId');
  @override
  late final GeneratedColumn<int> borrowerUserId = GeneratedColumn<int>(
      'borrower_user_id', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES local_users (id)'));
  static const VerificationMeta _lenderUserIdMeta =
      const VerificationMeta('lenderUserId');
  @override
  late final GeneratedColumn<int> lenderUserId = GeneratedColumn<int>(
      'lender_user_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES local_users (id)'));
  static const VerificationMeta _externalBorrowerNameMeta =
      const VerificationMeta('externalBorrowerName');
  @override
  late final GeneratedColumn<String> externalBorrowerName =
      GeneratedColumn<String>('external_borrower_name', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _externalBorrowerContactMeta =
      const VerificationMeta('externalBorrowerContact');
  @override
  late final GeneratedColumn<String> externalBorrowerContact =
      GeneratedColumn<String>('external_borrower_contact', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 32),
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('requested'));
  static const VerificationMeta _requestedAtMeta =
      const VerificationMeta('requestedAt');
  @override
  late final GeneratedColumn<DateTime> requestedAt = GeneratedColumn<DateTime>(
      'requested_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _approvedAtMeta =
      const VerificationMeta('approvedAt');
  @override
  late final GeneratedColumn<DateTime> approvedAt = GeneratedColumn<DateTime>(
      'approved_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _dueDateMeta =
      const VerificationMeta('dueDate');
  @override
  late final GeneratedColumn<DateTime> dueDate = GeneratedColumn<DateTime>(
      'due_date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _borrowerReturnedAtMeta =
      const VerificationMeta('borrowerReturnedAt');
  @override
  late final GeneratedColumn<DateTime> borrowerReturnedAt =
      GeneratedColumn<DateTime>('borrower_returned_at', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _lenderReturnedAtMeta =
      const VerificationMeta('lenderReturnedAt');
  @override
  late final GeneratedColumn<DateTime> lenderReturnedAt =
      GeneratedColumn<DateTime>('lender_returned_at', aliasedName, true,
          type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _returnedAtMeta =
      const VerificationMeta('returnedAt');
  @override
  late final GeneratedColumn<DateTime> returnedAt = GeneratedColumn<DateTime>(
      'returned_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _wasReadMeta =
      const VerificationMeta('wasRead');
  @override
  late final GeneratedColumn<bool> wasRead = GeneratedColumn<bool>(
      'was_read', aliasedName, true,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("was_read" IN (0, 1))'));
  static const VerificationMeta _markedReadAtMeta =
      const VerificationMeta('markedReadAt');
  @override
  late final GeneratedColumn<DateTime> markedReadAt = GeneratedColumn<DateTime>(
      'marked_read_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _isDirtyMeta =
      const VerificationMeta('isDirty');
  @override
  late final GeneratedColumn<bool> isDirty = GeneratedColumn<bool>(
      'is_dirty', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_dirty" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _syncedAtMeta =
      const VerificationMeta('syncedAt');
  @override
  late final GeneratedColumn<DateTime> syncedAt = GeneratedColumn<DateTime>(
      'synced_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        remoteId,
        sharedBookId,
        bookId,
        borrowerUserId,
        lenderUserId,
        externalBorrowerName,
        externalBorrowerContact,
        status,
        requestedAt,
        approvedAt,
        dueDate,
        borrowerReturnedAt,
        lenderReturnedAt,
        returnedAt,
        wasRead,
        markedReadAt,
        isDirty,
        isDeleted,
        syncedAt,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'loans';
  @override
  VerificationContext validateIntegrity(Insertable<Loan> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('remote_id')) {
      context.handle(_remoteIdMeta,
          remoteId.isAcceptableOrUnknown(data['remote_id']!, _remoteIdMeta));
    }
    if (data.containsKey('shared_book_id')) {
      context.handle(
          _sharedBookIdMeta,
          sharedBookId.isAcceptableOrUnknown(
              data['shared_book_id']!, _sharedBookIdMeta));
    }
    if (data.containsKey('book_id')) {
      context.handle(_bookIdMeta,
          bookId.isAcceptableOrUnknown(data['book_id']!, _bookIdMeta));
    }
    if (data.containsKey('borrower_user_id')) {
      context.handle(
          _borrowerUserIdMeta,
          borrowerUserId.isAcceptableOrUnknown(
              data['borrower_user_id']!, _borrowerUserIdMeta));
    }
    if (data.containsKey('lender_user_id')) {
      context.handle(
          _lenderUserIdMeta,
          lenderUserId.isAcceptableOrUnknown(
              data['lender_user_id']!, _lenderUserIdMeta));
    } else if (isInserting) {
      context.missing(_lenderUserIdMeta);
    }
    if (data.containsKey('external_borrower_name')) {
      context.handle(
          _externalBorrowerNameMeta,
          externalBorrowerName.isAcceptableOrUnknown(
              data['external_borrower_name']!, _externalBorrowerNameMeta));
    }
    if (data.containsKey('external_borrower_contact')) {
      context.handle(
          _externalBorrowerContactMeta,
          externalBorrowerContact.isAcceptableOrUnknown(
              data['external_borrower_contact']!,
              _externalBorrowerContactMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('requested_at')) {
      context.handle(
          _requestedAtMeta,
          requestedAt.isAcceptableOrUnknown(
              data['requested_at']!, _requestedAtMeta));
    }
    if (data.containsKey('approved_at')) {
      context.handle(
          _approvedAtMeta,
          approvedAt.isAcceptableOrUnknown(
              data['approved_at']!, _approvedAtMeta));
    }
    if (data.containsKey('due_date')) {
      context.handle(_dueDateMeta,
          dueDate.isAcceptableOrUnknown(data['due_date']!, _dueDateMeta));
    }
    if (data.containsKey('borrower_returned_at')) {
      context.handle(
          _borrowerReturnedAtMeta,
          borrowerReturnedAt.isAcceptableOrUnknown(
              data['borrower_returned_at']!, _borrowerReturnedAtMeta));
    }
    if (data.containsKey('lender_returned_at')) {
      context.handle(
          _lenderReturnedAtMeta,
          lenderReturnedAt.isAcceptableOrUnknown(
              data['lender_returned_at']!, _lenderReturnedAtMeta));
    }
    if (data.containsKey('returned_at')) {
      context.handle(
          _returnedAtMeta,
          returnedAt.isAcceptableOrUnknown(
              data['returned_at']!, _returnedAtMeta));
    }
    if (data.containsKey('was_read')) {
      context.handle(_wasReadMeta,
          wasRead.isAcceptableOrUnknown(data['was_read']!, _wasReadMeta));
    }
    if (data.containsKey('marked_read_at')) {
      context.handle(
          _markedReadAtMeta,
          markedReadAt.isAcceptableOrUnknown(
              data['marked_read_at']!, _markedReadAtMeta));
    }
    if (data.containsKey('is_dirty')) {
      context.handle(_isDirtyMeta,
          isDirty.isAcceptableOrUnknown(data['is_dirty']!, _isDirtyMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('synced_at')) {
      context.handle(_syncedAtMeta,
          syncedAt.isAcceptableOrUnknown(data['synced_at']!, _syncedAtMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Loan map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Loan(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      remoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}remote_id']),
      sharedBookId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}shared_book_id']),
      bookId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}book_id']),
      borrowerUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}borrower_user_id']),
      lenderUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}lender_user_id'])!,
      externalBorrowerName: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}external_borrower_name']),
      externalBorrowerContact: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}external_borrower_contact']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      requestedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}requested_at'])!,
      approvedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}approved_at']),
      dueDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}due_date']),
      borrowerReturnedAt: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime,
          data['${effectivePrefix}borrower_returned_at']),
      lenderReturnedAt: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}lender_returned_at']),
      returnedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}returned_at']),
      wasRead: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}was_read']),
      markedReadAt: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}marked_read_at']),
      isDirty: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_dirty'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      syncedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}synced_at']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $LoansTable createAlias(String alias) {
    return $LoansTable(attachedDatabase, alias);
  }
}

class Loan extends DataClass implements Insertable<Loan> {
  final int id;
  final String uuid;
  final String? remoteId;
  final int? sharedBookId;
  final int? bookId;
  final int? borrowerUserId;
  final int lenderUserId;
  final String? externalBorrowerName;
  final String? externalBorrowerContact;
  final String status;
  final DateTime requestedAt;
  final DateTime? approvedAt;
  final DateTime? dueDate;
  final DateTime? borrowerReturnedAt;
  final DateTime? lenderReturnedAt;
  final DateTime? returnedAt;
  final bool? wasRead;
  final DateTime? markedReadAt;
  final bool isDirty;
  final bool isDeleted;
  final DateTime? syncedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Loan(
      {required this.id,
      required this.uuid,
      this.remoteId,
      this.sharedBookId,
      this.bookId,
      this.borrowerUserId,
      required this.lenderUserId,
      this.externalBorrowerName,
      this.externalBorrowerContact,
      required this.status,
      required this.requestedAt,
      this.approvedAt,
      this.dueDate,
      this.borrowerReturnedAt,
      this.lenderReturnedAt,
      this.returnedAt,
      this.wasRead,
      this.markedReadAt,
      required this.isDirty,
      required this.isDeleted,
      this.syncedAt,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    if (!nullToAbsent || remoteId != null) {
      map['remote_id'] = Variable<String>(remoteId);
    }
    if (!nullToAbsent || sharedBookId != null) {
      map['shared_book_id'] = Variable<int>(sharedBookId);
    }
    if (!nullToAbsent || bookId != null) {
      map['book_id'] = Variable<int>(bookId);
    }
    if (!nullToAbsent || borrowerUserId != null) {
      map['borrower_user_id'] = Variable<int>(borrowerUserId);
    }
    map['lender_user_id'] = Variable<int>(lenderUserId);
    if (!nullToAbsent || externalBorrowerName != null) {
      map['external_borrower_name'] = Variable<String>(externalBorrowerName);
    }
    if (!nullToAbsent || externalBorrowerContact != null) {
      map['external_borrower_contact'] =
          Variable<String>(externalBorrowerContact);
    }
    map['status'] = Variable<String>(status);
    map['requested_at'] = Variable<DateTime>(requestedAt);
    if (!nullToAbsent || approvedAt != null) {
      map['approved_at'] = Variable<DateTime>(approvedAt);
    }
    if (!nullToAbsent || dueDate != null) {
      map['due_date'] = Variable<DateTime>(dueDate);
    }
    if (!nullToAbsent || borrowerReturnedAt != null) {
      map['borrower_returned_at'] = Variable<DateTime>(borrowerReturnedAt);
    }
    if (!nullToAbsent || lenderReturnedAt != null) {
      map['lender_returned_at'] = Variable<DateTime>(lenderReturnedAt);
    }
    if (!nullToAbsent || returnedAt != null) {
      map['returned_at'] = Variable<DateTime>(returnedAt);
    }
    if (!nullToAbsent || wasRead != null) {
      map['was_read'] = Variable<bool>(wasRead);
    }
    if (!nullToAbsent || markedReadAt != null) {
      map['marked_read_at'] = Variable<DateTime>(markedReadAt);
    }
    map['is_dirty'] = Variable<bool>(isDirty);
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || syncedAt != null) {
      map['synced_at'] = Variable<DateTime>(syncedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  LoansCompanion toCompanion(bool nullToAbsent) {
    return LoansCompanion(
      id: Value(id),
      uuid: Value(uuid),
      remoteId: remoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(remoteId),
      sharedBookId: sharedBookId == null && nullToAbsent
          ? const Value.absent()
          : Value(sharedBookId),
      bookId:
          bookId == null && nullToAbsent ? const Value.absent() : Value(bookId),
      borrowerUserId: borrowerUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(borrowerUserId),
      lenderUserId: Value(lenderUserId),
      externalBorrowerName: externalBorrowerName == null && nullToAbsent
          ? const Value.absent()
          : Value(externalBorrowerName),
      externalBorrowerContact: externalBorrowerContact == null && nullToAbsent
          ? const Value.absent()
          : Value(externalBorrowerContact),
      status: Value(status),
      requestedAt: Value(requestedAt),
      approvedAt: approvedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(approvedAt),
      dueDate: dueDate == null && nullToAbsent
          ? const Value.absent()
          : Value(dueDate),
      borrowerReturnedAt: borrowerReturnedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(borrowerReturnedAt),
      lenderReturnedAt: lenderReturnedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lenderReturnedAt),
      returnedAt: returnedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(returnedAt),
      wasRead: wasRead == null && nullToAbsent
          ? const Value.absent()
          : Value(wasRead),
      markedReadAt: markedReadAt == null && nullToAbsent
          ? const Value.absent()
          : Value(markedReadAt),
      isDirty: Value(isDirty),
      isDeleted: Value(isDeleted),
      syncedAt: syncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Loan.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Loan(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      remoteId: serializer.fromJson<String?>(json['remoteId']),
      sharedBookId: serializer.fromJson<int?>(json['sharedBookId']),
      bookId: serializer.fromJson<int?>(json['bookId']),
      borrowerUserId: serializer.fromJson<int?>(json['borrowerUserId']),
      lenderUserId: serializer.fromJson<int>(json['lenderUserId']),
      externalBorrowerName:
          serializer.fromJson<String?>(json['externalBorrowerName']),
      externalBorrowerContact:
          serializer.fromJson<String?>(json['externalBorrowerContact']),
      status: serializer.fromJson<String>(json['status']),
      requestedAt: serializer.fromJson<DateTime>(json['requestedAt']),
      approvedAt: serializer.fromJson<DateTime?>(json['approvedAt']),
      dueDate: serializer.fromJson<DateTime?>(json['dueDate']),
      borrowerReturnedAt:
          serializer.fromJson<DateTime?>(json['borrowerReturnedAt']),
      lenderReturnedAt:
          serializer.fromJson<DateTime?>(json['lenderReturnedAt']),
      returnedAt: serializer.fromJson<DateTime?>(json['returnedAt']),
      wasRead: serializer.fromJson<bool?>(json['wasRead']),
      markedReadAt: serializer.fromJson<DateTime?>(json['markedReadAt']),
      isDirty: serializer.fromJson<bool>(json['isDirty']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      syncedAt: serializer.fromJson<DateTime?>(json['syncedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'remoteId': serializer.toJson<String?>(remoteId),
      'sharedBookId': serializer.toJson<int?>(sharedBookId),
      'bookId': serializer.toJson<int?>(bookId),
      'borrowerUserId': serializer.toJson<int?>(borrowerUserId),
      'lenderUserId': serializer.toJson<int>(lenderUserId),
      'externalBorrowerName': serializer.toJson<String?>(externalBorrowerName),
      'externalBorrowerContact':
          serializer.toJson<String?>(externalBorrowerContact),
      'status': serializer.toJson<String>(status),
      'requestedAt': serializer.toJson<DateTime>(requestedAt),
      'approvedAt': serializer.toJson<DateTime?>(approvedAt),
      'dueDate': serializer.toJson<DateTime?>(dueDate),
      'borrowerReturnedAt': serializer.toJson<DateTime?>(borrowerReturnedAt),
      'lenderReturnedAt': serializer.toJson<DateTime?>(lenderReturnedAt),
      'returnedAt': serializer.toJson<DateTime?>(returnedAt),
      'wasRead': serializer.toJson<bool?>(wasRead),
      'markedReadAt': serializer.toJson<DateTime?>(markedReadAt),
      'isDirty': serializer.toJson<bool>(isDirty),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'syncedAt': serializer.toJson<DateTime?>(syncedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  Loan copyWith(
          {int? id,
          String? uuid,
          Value<String?> remoteId = const Value.absent(),
          Value<int?> sharedBookId = const Value.absent(),
          Value<int?> bookId = const Value.absent(),
          Value<int?> borrowerUserId = const Value.absent(),
          int? lenderUserId,
          Value<String?> externalBorrowerName = const Value.absent(),
          Value<String?> externalBorrowerContact = const Value.absent(),
          String? status,
          DateTime? requestedAt,
          Value<DateTime?> approvedAt = const Value.absent(),
          Value<DateTime?> dueDate = const Value.absent(),
          Value<DateTime?> borrowerReturnedAt = const Value.absent(),
          Value<DateTime?> lenderReturnedAt = const Value.absent(),
          Value<DateTime?> returnedAt = const Value.absent(),
          Value<bool?> wasRead = const Value.absent(),
          Value<DateTime?> markedReadAt = const Value.absent(),
          bool? isDirty,
          bool? isDeleted,
          Value<DateTime?> syncedAt = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      Loan(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        remoteId: remoteId.present ? remoteId.value : this.remoteId,
        sharedBookId:
            sharedBookId.present ? sharedBookId.value : this.sharedBookId,
        bookId: bookId.present ? bookId.value : this.bookId,
        borrowerUserId:
            borrowerUserId.present ? borrowerUserId.value : this.borrowerUserId,
        lenderUserId: lenderUserId ?? this.lenderUserId,
        externalBorrowerName: externalBorrowerName.present
            ? externalBorrowerName.value
            : this.externalBorrowerName,
        externalBorrowerContact: externalBorrowerContact.present
            ? externalBorrowerContact.value
            : this.externalBorrowerContact,
        status: status ?? this.status,
        requestedAt: requestedAt ?? this.requestedAt,
        approvedAt: approvedAt.present ? approvedAt.value : this.approvedAt,
        dueDate: dueDate.present ? dueDate.value : this.dueDate,
        borrowerReturnedAt: borrowerReturnedAt.present
            ? borrowerReturnedAt.value
            : this.borrowerReturnedAt,
        lenderReturnedAt: lenderReturnedAt.present
            ? lenderReturnedAt.value
            : this.lenderReturnedAt,
        returnedAt: returnedAt.present ? returnedAt.value : this.returnedAt,
        wasRead: wasRead.present ? wasRead.value : this.wasRead,
        markedReadAt:
            markedReadAt.present ? markedReadAt.value : this.markedReadAt,
        isDirty: isDirty ?? this.isDirty,
        isDeleted: isDeleted ?? this.isDeleted,
        syncedAt: syncedAt.present ? syncedAt.value : this.syncedAt,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  Loan copyWithCompanion(LoansCompanion data) {
    return Loan(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      remoteId: data.remoteId.present ? data.remoteId.value : this.remoteId,
      sharedBookId: data.sharedBookId.present
          ? data.sharedBookId.value
          : this.sharedBookId,
      bookId: data.bookId.present ? data.bookId.value : this.bookId,
      borrowerUserId: data.borrowerUserId.present
          ? data.borrowerUserId.value
          : this.borrowerUserId,
      lenderUserId: data.lenderUserId.present
          ? data.lenderUserId.value
          : this.lenderUserId,
      externalBorrowerName: data.externalBorrowerName.present
          ? data.externalBorrowerName.value
          : this.externalBorrowerName,
      externalBorrowerContact: data.externalBorrowerContact.present
          ? data.externalBorrowerContact.value
          : this.externalBorrowerContact,
      status: data.status.present ? data.status.value : this.status,
      requestedAt:
          data.requestedAt.present ? data.requestedAt.value : this.requestedAt,
      approvedAt:
          data.approvedAt.present ? data.approvedAt.value : this.approvedAt,
      dueDate: data.dueDate.present ? data.dueDate.value : this.dueDate,
      borrowerReturnedAt: data.borrowerReturnedAt.present
          ? data.borrowerReturnedAt.value
          : this.borrowerReturnedAt,
      lenderReturnedAt: data.lenderReturnedAt.present
          ? data.lenderReturnedAt.value
          : this.lenderReturnedAt,
      returnedAt:
          data.returnedAt.present ? data.returnedAt.value : this.returnedAt,
      wasRead: data.wasRead.present ? data.wasRead.value : this.wasRead,
      markedReadAt: data.markedReadAt.present
          ? data.markedReadAt.value
          : this.markedReadAt,
      isDirty: data.isDirty.present ? data.isDirty.value : this.isDirty,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      syncedAt: data.syncedAt.present ? data.syncedAt.value : this.syncedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Loan(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('sharedBookId: $sharedBookId, ')
          ..write('bookId: $bookId, ')
          ..write('borrowerUserId: $borrowerUserId, ')
          ..write('lenderUserId: $lenderUserId, ')
          ..write('externalBorrowerName: $externalBorrowerName, ')
          ..write('externalBorrowerContact: $externalBorrowerContact, ')
          ..write('status: $status, ')
          ..write('requestedAt: $requestedAt, ')
          ..write('approvedAt: $approvedAt, ')
          ..write('dueDate: $dueDate, ')
          ..write('borrowerReturnedAt: $borrowerReturnedAt, ')
          ..write('lenderReturnedAt: $lenderReturnedAt, ')
          ..write('returnedAt: $returnedAt, ')
          ..write('wasRead: $wasRead, ')
          ..write('markedReadAt: $markedReadAt, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        uuid,
        remoteId,
        sharedBookId,
        bookId,
        borrowerUserId,
        lenderUserId,
        externalBorrowerName,
        externalBorrowerContact,
        status,
        requestedAt,
        approvedAt,
        dueDate,
        borrowerReturnedAt,
        lenderReturnedAt,
        returnedAt,
        wasRead,
        markedReadAt,
        isDirty,
        isDeleted,
        syncedAt,
        createdAt,
        updatedAt
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Loan &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.remoteId == this.remoteId &&
          other.sharedBookId == this.sharedBookId &&
          other.bookId == this.bookId &&
          other.borrowerUserId == this.borrowerUserId &&
          other.lenderUserId == this.lenderUserId &&
          other.externalBorrowerName == this.externalBorrowerName &&
          other.externalBorrowerContact == this.externalBorrowerContact &&
          other.status == this.status &&
          other.requestedAt == this.requestedAt &&
          other.approvedAt == this.approvedAt &&
          other.dueDate == this.dueDate &&
          other.borrowerReturnedAt == this.borrowerReturnedAt &&
          other.lenderReturnedAt == this.lenderReturnedAt &&
          other.returnedAt == this.returnedAt &&
          other.wasRead == this.wasRead &&
          other.markedReadAt == this.markedReadAt &&
          other.isDirty == this.isDirty &&
          other.isDeleted == this.isDeleted &&
          other.syncedAt == this.syncedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class LoansCompanion extends UpdateCompanion<Loan> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String?> remoteId;
  final Value<int?> sharedBookId;
  final Value<int?> bookId;
  final Value<int?> borrowerUserId;
  final Value<int> lenderUserId;
  final Value<String?> externalBorrowerName;
  final Value<String?> externalBorrowerContact;
  final Value<String> status;
  final Value<DateTime> requestedAt;
  final Value<DateTime?> approvedAt;
  final Value<DateTime?> dueDate;
  final Value<DateTime?> borrowerReturnedAt;
  final Value<DateTime?> lenderReturnedAt;
  final Value<DateTime?> returnedAt;
  final Value<bool?> wasRead;
  final Value<DateTime?> markedReadAt;
  final Value<bool> isDirty;
  final Value<bool> isDeleted;
  final Value<DateTime?> syncedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const LoansCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.remoteId = const Value.absent(),
    this.sharedBookId = const Value.absent(),
    this.bookId = const Value.absent(),
    this.borrowerUserId = const Value.absent(),
    this.lenderUserId = const Value.absent(),
    this.externalBorrowerName = const Value.absent(),
    this.externalBorrowerContact = const Value.absent(),
    this.status = const Value.absent(),
    this.requestedAt = const Value.absent(),
    this.approvedAt = const Value.absent(),
    this.dueDate = const Value.absent(),
    this.borrowerReturnedAt = const Value.absent(),
    this.lenderReturnedAt = const Value.absent(),
    this.returnedAt = const Value.absent(),
    this.wasRead = const Value.absent(),
    this.markedReadAt = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  LoansCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    this.remoteId = const Value.absent(),
    this.sharedBookId = const Value.absent(),
    this.bookId = const Value.absent(),
    this.borrowerUserId = const Value.absent(),
    required int lenderUserId,
    this.externalBorrowerName = const Value.absent(),
    this.externalBorrowerContact = const Value.absent(),
    this.status = const Value.absent(),
    this.requestedAt = const Value.absent(),
    this.approvedAt = const Value.absent(),
    this.dueDate = const Value.absent(),
    this.borrowerReturnedAt = const Value.absent(),
    this.lenderReturnedAt = const Value.absent(),
    this.returnedAt = const Value.absent(),
    this.wasRead = const Value.absent(),
    this.markedReadAt = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        lenderUserId = Value(lenderUserId);
  static Insertable<Loan> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? remoteId,
    Expression<int>? sharedBookId,
    Expression<int>? bookId,
    Expression<int>? borrowerUserId,
    Expression<int>? lenderUserId,
    Expression<String>? externalBorrowerName,
    Expression<String>? externalBorrowerContact,
    Expression<String>? status,
    Expression<DateTime>? requestedAt,
    Expression<DateTime>? approvedAt,
    Expression<DateTime>? dueDate,
    Expression<DateTime>? borrowerReturnedAt,
    Expression<DateTime>? lenderReturnedAt,
    Expression<DateTime>? returnedAt,
    Expression<bool>? wasRead,
    Expression<DateTime>? markedReadAt,
    Expression<bool>? isDirty,
    Expression<bool>? isDeleted,
    Expression<DateTime>? syncedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (remoteId != null) 'remote_id': remoteId,
      if (sharedBookId != null) 'shared_book_id': sharedBookId,
      if (bookId != null) 'book_id': bookId,
      if (borrowerUserId != null) 'borrower_user_id': borrowerUserId,
      if (lenderUserId != null) 'lender_user_id': lenderUserId,
      if (externalBorrowerName != null)
        'external_borrower_name': externalBorrowerName,
      if (externalBorrowerContact != null)
        'external_borrower_contact': externalBorrowerContact,
      if (status != null) 'status': status,
      if (requestedAt != null) 'requested_at': requestedAt,
      if (approvedAt != null) 'approved_at': approvedAt,
      if (dueDate != null) 'due_date': dueDate,
      if (borrowerReturnedAt != null)
        'borrower_returned_at': borrowerReturnedAt,
      if (lenderReturnedAt != null) 'lender_returned_at': lenderReturnedAt,
      if (returnedAt != null) 'returned_at': returnedAt,
      if (wasRead != null) 'was_read': wasRead,
      if (markedReadAt != null) 'marked_read_at': markedReadAt,
      if (isDirty != null) 'is_dirty': isDirty,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (syncedAt != null) 'synced_at': syncedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  LoansCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String?>? remoteId,
      Value<int?>? sharedBookId,
      Value<int?>? bookId,
      Value<int?>? borrowerUserId,
      Value<int>? lenderUserId,
      Value<String?>? externalBorrowerName,
      Value<String?>? externalBorrowerContact,
      Value<String>? status,
      Value<DateTime>? requestedAt,
      Value<DateTime?>? approvedAt,
      Value<DateTime?>? dueDate,
      Value<DateTime?>? borrowerReturnedAt,
      Value<DateTime?>? lenderReturnedAt,
      Value<DateTime?>? returnedAt,
      Value<bool?>? wasRead,
      Value<DateTime?>? markedReadAt,
      Value<bool>? isDirty,
      Value<bool>? isDeleted,
      Value<DateTime?>? syncedAt,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return LoansCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      remoteId: remoteId ?? this.remoteId,
      sharedBookId: sharedBookId ?? this.sharedBookId,
      bookId: bookId ?? this.bookId,
      borrowerUserId: borrowerUserId ?? this.borrowerUserId,
      lenderUserId: lenderUserId ?? this.lenderUserId,
      externalBorrowerName: externalBorrowerName ?? this.externalBorrowerName,
      externalBorrowerContact:
          externalBorrowerContact ?? this.externalBorrowerContact,
      status: status ?? this.status,
      requestedAt: requestedAt ?? this.requestedAt,
      approvedAt: approvedAt ?? this.approvedAt,
      dueDate: dueDate ?? this.dueDate,
      borrowerReturnedAt: borrowerReturnedAt ?? this.borrowerReturnedAt,
      lenderReturnedAt: lenderReturnedAt ?? this.lenderReturnedAt,
      returnedAt: returnedAt ?? this.returnedAt,
      wasRead: wasRead ?? this.wasRead,
      markedReadAt: markedReadAt ?? this.markedReadAt,
      isDirty: isDirty ?? this.isDirty,
      isDeleted: isDeleted ?? this.isDeleted,
      syncedAt: syncedAt ?? this.syncedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (remoteId.present) {
      map['remote_id'] = Variable<String>(remoteId.value);
    }
    if (sharedBookId.present) {
      map['shared_book_id'] = Variable<int>(sharedBookId.value);
    }
    if (bookId.present) {
      map['book_id'] = Variable<int>(bookId.value);
    }
    if (borrowerUserId.present) {
      map['borrower_user_id'] = Variable<int>(borrowerUserId.value);
    }
    if (lenderUserId.present) {
      map['lender_user_id'] = Variable<int>(lenderUserId.value);
    }
    if (externalBorrowerName.present) {
      map['external_borrower_name'] =
          Variable<String>(externalBorrowerName.value);
    }
    if (externalBorrowerContact.present) {
      map['external_borrower_contact'] =
          Variable<String>(externalBorrowerContact.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (requestedAt.present) {
      map['requested_at'] = Variable<DateTime>(requestedAt.value);
    }
    if (approvedAt.present) {
      map['approved_at'] = Variable<DateTime>(approvedAt.value);
    }
    if (dueDate.present) {
      map['due_date'] = Variable<DateTime>(dueDate.value);
    }
    if (borrowerReturnedAt.present) {
      map['borrower_returned_at'] =
          Variable<DateTime>(borrowerReturnedAt.value);
    }
    if (lenderReturnedAt.present) {
      map['lender_returned_at'] = Variable<DateTime>(lenderReturnedAt.value);
    }
    if (returnedAt.present) {
      map['returned_at'] = Variable<DateTime>(returnedAt.value);
    }
    if (wasRead.present) {
      map['was_read'] = Variable<bool>(wasRead.value);
    }
    if (markedReadAt.present) {
      map['marked_read_at'] = Variable<DateTime>(markedReadAt.value);
    }
    if (isDirty.present) {
      map['is_dirty'] = Variable<bool>(isDirty.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (syncedAt.present) {
      map['synced_at'] = Variable<DateTime>(syncedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LoansCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('sharedBookId: $sharedBookId, ')
          ..write('bookId: $bookId, ')
          ..write('borrowerUserId: $borrowerUserId, ')
          ..write('lenderUserId: $lenderUserId, ')
          ..write('externalBorrowerName: $externalBorrowerName, ')
          ..write('externalBorrowerContact: $externalBorrowerContact, ')
          ..write('status: $status, ')
          ..write('requestedAt: $requestedAt, ')
          ..write('approvedAt: $approvedAt, ')
          ..write('dueDate: $dueDate, ')
          ..write('borrowerReturnedAt: $borrowerReturnedAt, ')
          ..write('lenderReturnedAt: $lenderReturnedAt, ')
          ..write('returnedAt: $returnedAt, ')
          ..write('wasRead: $wasRead, ')
          ..write('markedReadAt: $markedReadAt, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $InAppNotificationsTable extends InAppNotifications
    with TableInfo<$InAppNotificationsTable, InAppNotification> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $InAppNotificationsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
      'type', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 64),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _loanIdMeta = const VerificationMeta('loanId');
  @override
  late final GeneratedColumn<int> loanId = GeneratedColumn<int>(
      'loan_id', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES loans (id)'));
  static const VerificationMeta _loanUuidMeta =
      const VerificationMeta('loanUuid');
  @override
  late final GeneratedColumn<String> loanUuid = GeneratedColumn<String>(
      'loan_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _sharedBookIdMeta =
      const VerificationMeta('sharedBookId');
  @override
  late final GeneratedColumn<int> sharedBookId = GeneratedColumn<int>(
      'shared_book_id', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES shared_books (id)'));
  static const VerificationMeta _sharedBookUuidMeta =
      const VerificationMeta('sharedBookUuid');
  @override
  late final GeneratedColumn<String> sharedBookUuid = GeneratedColumn<String>(
      'shared_book_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _actorUserIdMeta =
      const VerificationMeta('actorUserId');
  @override
  late final GeneratedColumn<int> actorUserId = GeneratedColumn<int>(
      'actor_user_id', aliasedName, true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES local_users (id)'));
  static const VerificationMeta _targetUserIdMeta =
      const VerificationMeta('targetUserId');
  @override
  late final GeneratedColumn<int> targetUserId = GeneratedColumn<int>(
      'target_user_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES local_users (id)'));
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
      'title', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _messageMeta =
      const VerificationMeta('message');
  @override
  late final GeneratedColumn<String> message = GeneratedColumn<String>(
      'message', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 32),
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('unread'));
  static const VerificationMeta _isDirtyMeta =
      const VerificationMeta('isDirty');
  @override
  late final GeneratedColumn<bool> isDirty = GeneratedColumn<bool>(
      'is_dirty', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_dirty" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _syncedAtMeta =
      const VerificationMeta('syncedAt');
  @override
  late final GeneratedColumn<DateTime> syncedAt = GeneratedColumn<DateTime>(
      'synced_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        type,
        loanId,
        loanUuid,
        sharedBookId,
        sharedBookUuid,
        actorUserId,
        targetUserId,
        title,
        message,
        status,
        isDirty,
        isDeleted,
        syncedAt,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'in_app_notifications';
  @override
  VerificationContext validateIntegrity(Insertable<InAppNotification> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
          _typeMeta, type.isAcceptableOrUnknown(data['type']!, _typeMeta));
    } else if (isInserting) {
      context.missing(_typeMeta);
    }
    if (data.containsKey('loan_id')) {
      context.handle(_loanIdMeta,
          loanId.isAcceptableOrUnknown(data['loan_id']!, _loanIdMeta));
    }
    if (data.containsKey('loan_uuid')) {
      context.handle(_loanUuidMeta,
          loanUuid.isAcceptableOrUnknown(data['loan_uuid']!, _loanUuidMeta));
    }
    if (data.containsKey('shared_book_id')) {
      context.handle(
          _sharedBookIdMeta,
          sharedBookId.isAcceptableOrUnknown(
              data['shared_book_id']!, _sharedBookIdMeta));
    }
    if (data.containsKey('shared_book_uuid')) {
      context.handle(
          _sharedBookUuidMeta,
          sharedBookUuid.isAcceptableOrUnknown(
              data['shared_book_uuid']!, _sharedBookUuidMeta));
    }
    if (data.containsKey('actor_user_id')) {
      context.handle(
          _actorUserIdMeta,
          actorUserId.isAcceptableOrUnknown(
              data['actor_user_id']!, _actorUserIdMeta));
    }
    if (data.containsKey('target_user_id')) {
      context.handle(
          _targetUserIdMeta,
          targetUserId.isAcceptableOrUnknown(
              data['target_user_id']!, _targetUserIdMeta));
    } else if (isInserting) {
      context.missing(_targetUserIdMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
          _titleMeta, title.isAcceptableOrUnknown(data['title']!, _titleMeta));
    }
    if (data.containsKey('message')) {
      context.handle(_messageMeta,
          message.isAcceptableOrUnknown(data['message']!, _messageMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('is_dirty')) {
      context.handle(_isDirtyMeta,
          isDirty.isAcceptableOrUnknown(data['is_dirty']!, _isDirtyMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('synced_at')) {
      context.handle(_syncedAtMeta,
          syncedAt.isAcceptableOrUnknown(data['synced_at']!, _syncedAtMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  InAppNotification map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return InAppNotification(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      type: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}type'])!,
      loanId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}loan_id']),
      loanUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}loan_uuid']),
      sharedBookId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}shared_book_id']),
      sharedBookUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}shared_book_uuid']),
      actorUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}actor_user_id']),
      targetUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}target_user_id'])!,
      title: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}title']),
      message: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}message']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      isDirty: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_dirty'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      syncedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}synced_at']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $InAppNotificationsTable createAlias(String alias) {
    return $InAppNotificationsTable(attachedDatabase, alias);
  }
}

class InAppNotification extends DataClass
    implements Insertable<InAppNotification> {
  final int id;
  final String uuid;
  final String type;
  final int? loanId;
  final String? loanUuid;
  final int? sharedBookId;
  final String? sharedBookUuid;
  final int? actorUserId;
  final int targetUserId;
  final String? title;
  final String? message;
  final String status;
  final bool isDirty;
  final bool isDeleted;
  final DateTime? syncedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const InAppNotification(
      {required this.id,
      required this.uuid,
      required this.type,
      this.loanId,
      this.loanUuid,
      this.sharedBookId,
      this.sharedBookUuid,
      this.actorUserId,
      required this.targetUserId,
      this.title,
      this.message,
      required this.status,
      required this.isDirty,
      required this.isDeleted,
      this.syncedAt,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['type'] = Variable<String>(type);
    if (!nullToAbsent || loanId != null) {
      map['loan_id'] = Variable<int>(loanId);
    }
    if (!nullToAbsent || loanUuid != null) {
      map['loan_uuid'] = Variable<String>(loanUuid);
    }
    if (!nullToAbsent || sharedBookId != null) {
      map['shared_book_id'] = Variable<int>(sharedBookId);
    }
    if (!nullToAbsent || sharedBookUuid != null) {
      map['shared_book_uuid'] = Variable<String>(sharedBookUuid);
    }
    if (!nullToAbsent || actorUserId != null) {
      map['actor_user_id'] = Variable<int>(actorUserId);
    }
    map['target_user_id'] = Variable<int>(targetUserId);
    if (!nullToAbsent || title != null) {
      map['title'] = Variable<String>(title);
    }
    if (!nullToAbsent || message != null) {
      map['message'] = Variable<String>(message);
    }
    map['status'] = Variable<String>(status);
    map['is_dirty'] = Variable<bool>(isDirty);
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || syncedAt != null) {
      map['synced_at'] = Variable<DateTime>(syncedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  InAppNotificationsCompanion toCompanion(bool nullToAbsent) {
    return InAppNotificationsCompanion(
      id: Value(id),
      uuid: Value(uuid),
      type: Value(type),
      loanId:
          loanId == null && nullToAbsent ? const Value.absent() : Value(loanId),
      loanUuid: loanUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(loanUuid),
      sharedBookId: sharedBookId == null && nullToAbsent
          ? const Value.absent()
          : Value(sharedBookId),
      sharedBookUuid: sharedBookUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(sharedBookUuid),
      actorUserId: actorUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(actorUserId),
      targetUserId: Value(targetUserId),
      title:
          title == null && nullToAbsent ? const Value.absent() : Value(title),
      message: message == null && nullToAbsent
          ? const Value.absent()
          : Value(message),
      status: Value(status),
      isDirty: Value(isDirty),
      isDeleted: Value(isDeleted),
      syncedAt: syncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory InAppNotification.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return InAppNotification(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      type: serializer.fromJson<String>(json['type']),
      loanId: serializer.fromJson<int?>(json['loanId']),
      loanUuid: serializer.fromJson<String?>(json['loanUuid']),
      sharedBookId: serializer.fromJson<int?>(json['sharedBookId']),
      sharedBookUuid: serializer.fromJson<String?>(json['sharedBookUuid']),
      actorUserId: serializer.fromJson<int?>(json['actorUserId']),
      targetUserId: serializer.fromJson<int>(json['targetUserId']),
      title: serializer.fromJson<String?>(json['title']),
      message: serializer.fromJson<String?>(json['message']),
      status: serializer.fromJson<String>(json['status']),
      isDirty: serializer.fromJson<bool>(json['isDirty']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      syncedAt: serializer.fromJson<DateTime?>(json['syncedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'type': serializer.toJson<String>(type),
      'loanId': serializer.toJson<int?>(loanId),
      'loanUuid': serializer.toJson<String?>(loanUuid),
      'sharedBookId': serializer.toJson<int?>(sharedBookId),
      'sharedBookUuid': serializer.toJson<String?>(sharedBookUuid),
      'actorUserId': serializer.toJson<int?>(actorUserId),
      'targetUserId': serializer.toJson<int>(targetUserId),
      'title': serializer.toJson<String?>(title),
      'message': serializer.toJson<String?>(message),
      'status': serializer.toJson<String>(status),
      'isDirty': serializer.toJson<bool>(isDirty),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'syncedAt': serializer.toJson<DateTime?>(syncedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  InAppNotification copyWith(
          {int? id,
          String? uuid,
          String? type,
          Value<int?> loanId = const Value.absent(),
          Value<String?> loanUuid = const Value.absent(),
          Value<int?> sharedBookId = const Value.absent(),
          Value<String?> sharedBookUuid = const Value.absent(),
          Value<int?> actorUserId = const Value.absent(),
          int? targetUserId,
          Value<String?> title = const Value.absent(),
          Value<String?> message = const Value.absent(),
          String? status,
          bool? isDirty,
          bool? isDeleted,
          Value<DateTime?> syncedAt = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      InAppNotification(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        type: type ?? this.type,
        loanId: loanId.present ? loanId.value : this.loanId,
        loanUuid: loanUuid.present ? loanUuid.value : this.loanUuid,
        sharedBookId:
            sharedBookId.present ? sharedBookId.value : this.sharedBookId,
        sharedBookUuid:
            sharedBookUuid.present ? sharedBookUuid.value : this.sharedBookUuid,
        actorUserId: actorUserId.present ? actorUserId.value : this.actorUserId,
        targetUserId: targetUserId ?? this.targetUserId,
        title: title.present ? title.value : this.title,
        message: message.present ? message.value : this.message,
        status: status ?? this.status,
        isDirty: isDirty ?? this.isDirty,
        isDeleted: isDeleted ?? this.isDeleted,
        syncedAt: syncedAt.present ? syncedAt.value : this.syncedAt,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  InAppNotification copyWithCompanion(InAppNotificationsCompanion data) {
    return InAppNotification(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      type: data.type.present ? data.type.value : this.type,
      loanId: data.loanId.present ? data.loanId.value : this.loanId,
      loanUuid: data.loanUuid.present ? data.loanUuid.value : this.loanUuid,
      sharedBookId: data.sharedBookId.present
          ? data.sharedBookId.value
          : this.sharedBookId,
      sharedBookUuid: data.sharedBookUuid.present
          ? data.sharedBookUuid.value
          : this.sharedBookUuid,
      actorUserId:
          data.actorUserId.present ? data.actorUserId.value : this.actorUserId,
      targetUserId: data.targetUserId.present
          ? data.targetUserId.value
          : this.targetUserId,
      title: data.title.present ? data.title.value : this.title,
      message: data.message.present ? data.message.value : this.message,
      status: data.status.present ? data.status.value : this.status,
      isDirty: data.isDirty.present ? data.isDirty.value : this.isDirty,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      syncedAt: data.syncedAt.present ? data.syncedAt.value : this.syncedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('InAppNotification(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('type: $type, ')
          ..write('loanId: $loanId, ')
          ..write('loanUuid: $loanUuid, ')
          ..write('sharedBookId: $sharedBookId, ')
          ..write('sharedBookUuid: $sharedBookUuid, ')
          ..write('actorUserId: $actorUserId, ')
          ..write('targetUserId: $targetUserId, ')
          ..write('title: $title, ')
          ..write('message: $message, ')
          ..write('status: $status, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      type,
      loanId,
      loanUuid,
      sharedBookId,
      sharedBookUuid,
      actorUserId,
      targetUserId,
      title,
      message,
      status,
      isDirty,
      isDeleted,
      syncedAt,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is InAppNotification &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.type == this.type &&
          other.loanId == this.loanId &&
          other.loanUuid == this.loanUuid &&
          other.sharedBookId == this.sharedBookId &&
          other.sharedBookUuid == this.sharedBookUuid &&
          other.actorUserId == this.actorUserId &&
          other.targetUserId == this.targetUserId &&
          other.title == this.title &&
          other.message == this.message &&
          other.status == this.status &&
          other.isDirty == this.isDirty &&
          other.isDeleted == this.isDeleted &&
          other.syncedAt == this.syncedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class InAppNotificationsCompanion extends UpdateCompanion<InAppNotification> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String> type;
  final Value<int?> loanId;
  final Value<String?> loanUuid;
  final Value<int?> sharedBookId;
  final Value<String?> sharedBookUuid;
  final Value<int?> actorUserId;
  final Value<int> targetUserId;
  final Value<String?> title;
  final Value<String?> message;
  final Value<String> status;
  final Value<bool> isDirty;
  final Value<bool> isDeleted;
  final Value<DateTime?> syncedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const InAppNotificationsCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.type = const Value.absent(),
    this.loanId = const Value.absent(),
    this.loanUuid = const Value.absent(),
    this.sharedBookId = const Value.absent(),
    this.sharedBookUuid = const Value.absent(),
    this.actorUserId = const Value.absent(),
    this.targetUserId = const Value.absent(),
    this.title = const Value.absent(),
    this.message = const Value.absent(),
    this.status = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  InAppNotificationsCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required String type,
    this.loanId = const Value.absent(),
    this.loanUuid = const Value.absent(),
    this.sharedBookId = const Value.absent(),
    this.sharedBookUuid = const Value.absent(),
    this.actorUserId = const Value.absent(),
    required int targetUserId,
    this.title = const Value.absent(),
    this.message = const Value.absent(),
    this.status = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        type = Value(type),
        targetUserId = Value(targetUserId);
  static Insertable<InAppNotification> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? type,
    Expression<int>? loanId,
    Expression<String>? loanUuid,
    Expression<int>? sharedBookId,
    Expression<String>? sharedBookUuid,
    Expression<int>? actorUserId,
    Expression<int>? targetUserId,
    Expression<String>? title,
    Expression<String>? message,
    Expression<String>? status,
    Expression<bool>? isDirty,
    Expression<bool>? isDeleted,
    Expression<DateTime>? syncedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (type != null) 'type': type,
      if (loanId != null) 'loan_id': loanId,
      if (loanUuid != null) 'loan_uuid': loanUuid,
      if (sharedBookId != null) 'shared_book_id': sharedBookId,
      if (sharedBookUuid != null) 'shared_book_uuid': sharedBookUuid,
      if (actorUserId != null) 'actor_user_id': actorUserId,
      if (targetUserId != null) 'target_user_id': targetUserId,
      if (title != null) 'title': title,
      if (message != null) 'message': message,
      if (status != null) 'status': status,
      if (isDirty != null) 'is_dirty': isDirty,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (syncedAt != null) 'synced_at': syncedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  InAppNotificationsCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String>? type,
      Value<int?>? loanId,
      Value<String?>? loanUuid,
      Value<int?>? sharedBookId,
      Value<String?>? sharedBookUuid,
      Value<int?>? actorUserId,
      Value<int>? targetUserId,
      Value<String?>? title,
      Value<String?>? message,
      Value<String>? status,
      Value<bool>? isDirty,
      Value<bool>? isDeleted,
      Value<DateTime?>? syncedAt,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return InAppNotificationsCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      type: type ?? this.type,
      loanId: loanId ?? this.loanId,
      loanUuid: loanUuid ?? this.loanUuid,
      sharedBookId: sharedBookId ?? this.sharedBookId,
      sharedBookUuid: sharedBookUuid ?? this.sharedBookUuid,
      actorUserId: actorUserId ?? this.actorUserId,
      targetUserId: targetUserId ?? this.targetUserId,
      title: title ?? this.title,
      message: message ?? this.message,
      status: status ?? this.status,
      isDirty: isDirty ?? this.isDirty,
      isDeleted: isDeleted ?? this.isDeleted,
      syncedAt: syncedAt ?? this.syncedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (loanId.present) {
      map['loan_id'] = Variable<int>(loanId.value);
    }
    if (loanUuid.present) {
      map['loan_uuid'] = Variable<String>(loanUuid.value);
    }
    if (sharedBookId.present) {
      map['shared_book_id'] = Variable<int>(sharedBookId.value);
    }
    if (sharedBookUuid.present) {
      map['shared_book_uuid'] = Variable<String>(sharedBookUuid.value);
    }
    if (actorUserId.present) {
      map['actor_user_id'] = Variable<int>(actorUserId.value);
    }
    if (targetUserId.present) {
      map['target_user_id'] = Variable<int>(targetUserId.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (message.present) {
      map['message'] = Variable<String>(message.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (isDirty.present) {
      map['is_dirty'] = Variable<bool>(isDirty.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (syncedAt.present) {
      map['synced_at'] = Variable<DateTime>(syncedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('InAppNotificationsCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('type: $type, ')
          ..write('loanId: $loanId, ')
          ..write('loanUuid: $loanUuid, ')
          ..write('sharedBookId: $sharedBookId, ')
          ..write('sharedBookUuid: $sharedBookUuid, ')
          ..write('actorUserId: $actorUserId, ')
          ..write('targetUserId: $targetUserId, ')
          ..write('title: $title, ')
          ..write('message: $message, ')
          ..write('status: $status, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $WishlistItemsTable extends WishlistItems
    with TableInfo<$WishlistItemsTable, WishlistItem> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $WishlistItemsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<int> userId = GeneratedColumn<int>(
      'user_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES local_users (id)'));
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
      'title', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 255),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _authorMeta = const VerificationMeta('author');
  @override
  late final GeneratedColumn<String> author = GeneratedColumn<String>(
      'author', aliasedName, true,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 255),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _isbnMeta = const VerificationMeta('isbn');
  @override
  late final GeneratedColumn<String> isbn = GeneratedColumn<String>(
      'isbn', aliasedName, true,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 10, maxTextLength: 20),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
      'notes', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns =>
      [id, uuid, userId, title, author, isbn, notes, createdAt, updatedAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'wishlist_items';
  @override
  VerificationContext validateIntegrity(Insertable<WishlistItem> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta));
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
          _titleMeta, title.isAcceptableOrUnknown(data['title']!, _titleMeta));
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('author')) {
      context.handle(_authorMeta,
          author.isAcceptableOrUnknown(data['author']!, _authorMeta));
    }
    if (data.containsKey('isbn')) {
      context.handle(
          _isbnMeta, isbn.isAcceptableOrUnknown(data['isbn']!, _isbnMeta));
    }
    if (data.containsKey('notes')) {
      context.handle(
          _notesMeta, notes.isAcceptableOrUnknown(data['notes']!, _notesMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  WishlistItem map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return WishlistItem(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}user_id'])!,
      title: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}title'])!,
      author: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}author']),
      isbn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}isbn']),
      notes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}notes']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $WishlistItemsTable createAlias(String alias) {
    return $WishlistItemsTable(attachedDatabase, alias);
  }
}

class WishlistItem extends DataClass implements Insertable<WishlistItem> {
  final int id;
  final String uuid;
  final int userId;
  final String title;
  final String? author;
  final String? isbn;
  final String? notes;
  final DateTime createdAt;
  final DateTime updatedAt;
  const WishlistItem(
      {required this.id,
      required this.uuid,
      required this.userId,
      required this.title,
      this.author,
      this.isbn,
      this.notes,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['user_id'] = Variable<int>(userId);
    map['title'] = Variable<String>(title);
    if (!nullToAbsent || author != null) {
      map['author'] = Variable<String>(author);
    }
    if (!nullToAbsent || isbn != null) {
      map['isbn'] = Variable<String>(isbn);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  WishlistItemsCompanion toCompanion(bool nullToAbsent) {
    return WishlistItemsCompanion(
      id: Value(id),
      uuid: Value(uuid),
      userId: Value(userId),
      title: Value(title),
      author:
          author == null && nullToAbsent ? const Value.absent() : Value(author),
      isbn: isbn == null && nullToAbsent ? const Value.absent() : Value(isbn),
      notes:
          notes == null && nullToAbsent ? const Value.absent() : Value(notes),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory WishlistItem.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return WishlistItem(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      userId: serializer.fromJson<int>(json['userId']),
      title: serializer.fromJson<String>(json['title']),
      author: serializer.fromJson<String?>(json['author']),
      isbn: serializer.fromJson<String?>(json['isbn']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'userId': serializer.toJson<int>(userId),
      'title': serializer.toJson<String>(title),
      'author': serializer.toJson<String?>(author),
      'isbn': serializer.toJson<String?>(isbn),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  WishlistItem copyWith(
          {int? id,
          String? uuid,
          int? userId,
          String? title,
          Value<String?> author = const Value.absent(),
          Value<String?> isbn = const Value.absent(),
          Value<String?> notes = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      WishlistItem(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        userId: userId ?? this.userId,
        title: title ?? this.title,
        author: author.present ? author.value : this.author,
        isbn: isbn.present ? isbn.value : this.isbn,
        notes: notes.present ? notes.value : this.notes,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  WishlistItem copyWithCompanion(WishlistItemsCompanion data) {
    return WishlistItem(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      userId: data.userId.present ? data.userId.value : this.userId,
      title: data.title.present ? data.title.value : this.title,
      author: data.author.present ? data.author.value : this.author,
      isbn: data.isbn.present ? data.isbn.value : this.isbn,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('WishlistItem(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('userId: $userId, ')
          ..write('title: $title, ')
          ..write('author: $author, ')
          ..write('isbn: $isbn, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id, uuid, userId, title, author, isbn, notes, createdAt, updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is WishlistItem &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.userId == this.userId &&
          other.title == this.title &&
          other.author == this.author &&
          other.isbn == this.isbn &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class WishlistItemsCompanion extends UpdateCompanion<WishlistItem> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<int> userId;
  final Value<String> title;
  final Value<String?> author;
  final Value<String?> isbn;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const WishlistItemsCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.userId = const Value.absent(),
    this.title = const Value.absent(),
    this.author = const Value.absent(),
    this.isbn = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  WishlistItemsCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required int userId,
    required String title,
    this.author = const Value.absent(),
    this.isbn = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        userId = Value(userId),
        title = Value(title);
  static Insertable<WishlistItem> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<int>? userId,
    Expression<String>? title,
    Expression<String>? author,
    Expression<String>? isbn,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (userId != null) 'user_id': userId,
      if (title != null) 'title': title,
      if (author != null) 'author': author,
      if (isbn != null) 'isbn': isbn,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  WishlistItemsCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<int>? userId,
      Value<String>? title,
      Value<String?>? author,
      Value<String?>? isbn,
      Value<String?>? notes,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return WishlistItemsCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      userId: userId ?? this.userId,
      title: title ?? this.title,
      author: author ?? this.author,
      isbn: isbn ?? this.isbn,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<int>(userId.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (author.present) {
      map['author'] = Variable<String>(author.value);
    }
    if (isbn.present) {
      map['isbn'] = Variable<String>(isbn.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('WishlistItemsCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('userId: $userId, ')
          ..write('title: $title, ')
          ..write('author: $author, ')
          ..write('isbn: $isbn, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $ReadingClubsTable extends ReadingClubs
    with TableInfo<$ReadingClubsTable, ReadingClub> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ReadingClubsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _remoteIdMeta =
      const VerificationMeta('remoteId');
  @override
  late final GeneratedColumn<String> remoteId = GeneratedColumn<String>(
      'remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
      'name', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 128),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _descriptionMeta =
      const VerificationMeta('description');
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
      'description', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 512),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _cityMeta = const VerificationMeta('city');
  @override
  late final GeneratedColumn<String> city = GeneratedColumn<String>(
      'city', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 128),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _meetingPlaceMeta =
      const VerificationMeta('meetingPlace');
  @override
  late final GeneratedColumn<String> meetingPlace = GeneratedColumn<String>(
      'meeting_place', aliasedName, true,
      additionalChecks: GeneratedColumn.checkTextLength(maxTextLength: 256),
      type: DriftSqlType.string,
      requiredDuringInsert: false);
  static const VerificationMeta _frequencyMeta =
      const VerificationMeta('frequency');
  @override
  late final GeneratedColumn<String> frequency = GeneratedColumn<String>(
      'frequency', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 32),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _frequencyDaysMeta =
      const VerificationMeta('frequencyDays');
  @override
  late final GeneratedColumn<int> frequencyDays = GeneratedColumn<int>(
      'frequency_days', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _visibilityMeta =
      const VerificationMeta('visibility');
  @override
  late final GeneratedColumn<String> visibility = GeneratedColumn<String>(
      'visibility', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 32),
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('privado'));
  static const VerificationMeta _nextBooksVisibleMeta =
      const VerificationMeta('nextBooksVisible');
  @override
  late final GeneratedColumn<int> nextBooksVisible = GeneratedColumn<int>(
      'next_books_visible', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(1));
  static const VerificationMeta _ownerUserIdMeta =
      const VerificationMeta('ownerUserId');
  @override
  late final GeneratedColumn<int> ownerUserId = GeneratedColumn<int>(
      'owner_user_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES local_users (id)'));
  static const VerificationMeta _ownerRemoteIdMeta =
      const VerificationMeta('ownerRemoteId');
  @override
  late final GeneratedColumn<String> ownerRemoteId = GeneratedColumn<String>(
      'owner_remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _currentBookIdMeta =
      const VerificationMeta('currentBookId');
  @override
  late final GeneratedColumn<int> currentBookId = GeneratedColumn<int>(
      'current_book_id', aliasedName, true,
      type: DriftSqlType.int, requiredDuringInsert: false);
  static const VerificationMeta _currentBookUuidMeta =
      const VerificationMeta('currentBookUuid');
  @override
  late final GeneratedColumn<String> currentBookUuid = GeneratedColumn<String>(
      'current_book_uuid', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDirtyMeta =
      const VerificationMeta('isDirty');
  @override
  late final GeneratedColumn<bool> isDirty = GeneratedColumn<bool>(
      'is_dirty', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_dirty" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _syncedAtMeta =
      const VerificationMeta('syncedAt');
  @override
  late final GeneratedColumn<DateTime> syncedAt = GeneratedColumn<DateTime>(
      'synced_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        remoteId,
        name,
        description,
        city,
        meetingPlace,
        frequency,
        frequencyDays,
        visibility,
        nextBooksVisible,
        ownerUserId,
        ownerRemoteId,
        currentBookId,
        currentBookUuid,
        isDirty,
        isDeleted,
        syncedAt,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'reading_clubs';
  @override
  VerificationContext validateIntegrity(Insertable<ReadingClub> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('remote_id')) {
      context.handle(_remoteIdMeta,
          remoteId.isAcceptableOrUnknown(data['remote_id']!, _remoteIdMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
          _nameMeta, name.isAcceptableOrUnknown(data['name']!, _nameMeta));
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
          _descriptionMeta,
          description.isAcceptableOrUnknown(
              data['description']!, _descriptionMeta));
    } else if (isInserting) {
      context.missing(_descriptionMeta);
    }
    if (data.containsKey('city')) {
      context.handle(
          _cityMeta, city.isAcceptableOrUnknown(data['city']!, _cityMeta));
    } else if (isInserting) {
      context.missing(_cityMeta);
    }
    if (data.containsKey('meeting_place')) {
      context.handle(
          _meetingPlaceMeta,
          meetingPlace.isAcceptableOrUnknown(
              data['meeting_place']!, _meetingPlaceMeta));
    }
    if (data.containsKey('frequency')) {
      context.handle(_frequencyMeta,
          frequency.isAcceptableOrUnknown(data['frequency']!, _frequencyMeta));
    } else if (isInserting) {
      context.missing(_frequencyMeta);
    }
    if (data.containsKey('frequency_days')) {
      context.handle(
          _frequencyDaysMeta,
          frequencyDays.isAcceptableOrUnknown(
              data['frequency_days']!, _frequencyDaysMeta));
    }
    if (data.containsKey('visibility')) {
      context.handle(
          _visibilityMeta,
          visibility.isAcceptableOrUnknown(
              data['visibility']!, _visibilityMeta));
    }
    if (data.containsKey('next_books_visible')) {
      context.handle(
          _nextBooksVisibleMeta,
          nextBooksVisible.isAcceptableOrUnknown(
              data['next_books_visible']!, _nextBooksVisibleMeta));
    }
    if (data.containsKey('owner_user_id')) {
      context.handle(
          _ownerUserIdMeta,
          ownerUserId.isAcceptableOrUnknown(
              data['owner_user_id']!, _ownerUserIdMeta));
    } else if (isInserting) {
      context.missing(_ownerUserIdMeta);
    }
    if (data.containsKey('owner_remote_id')) {
      context.handle(
          _ownerRemoteIdMeta,
          ownerRemoteId.isAcceptableOrUnknown(
              data['owner_remote_id']!, _ownerRemoteIdMeta));
    }
    if (data.containsKey('current_book_id')) {
      context.handle(
          _currentBookIdMeta,
          currentBookId.isAcceptableOrUnknown(
              data['current_book_id']!, _currentBookIdMeta));
    }
    if (data.containsKey('current_book_uuid')) {
      context.handle(
          _currentBookUuidMeta,
          currentBookUuid.isAcceptableOrUnknown(
              data['current_book_uuid']!, _currentBookUuidMeta));
    }
    if (data.containsKey('is_dirty')) {
      context.handle(_isDirtyMeta,
          isDirty.isAcceptableOrUnknown(data['is_dirty']!, _isDirtyMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('synced_at')) {
      context.handle(_syncedAtMeta,
          syncedAt.isAcceptableOrUnknown(data['synced_at']!, _syncedAtMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ReadingClub map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ReadingClub(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      remoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}remote_id']),
      name: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}name'])!,
      description: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}description'])!,
      city: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}city'])!,
      meetingPlace: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}meeting_place']),
      frequency: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}frequency'])!,
      frequencyDays: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}frequency_days']),
      visibility: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}visibility'])!,
      nextBooksVisible: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}next_books_visible'])!,
      ownerUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}owner_user_id'])!,
      ownerRemoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}owner_remote_id']),
      currentBookId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}current_book_id']),
      currentBookUuid: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}current_book_uuid']),
      isDirty: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_dirty'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      syncedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}synced_at']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $ReadingClubsTable createAlias(String alias) {
    return $ReadingClubsTable(attachedDatabase, alias);
  }
}

class ReadingClub extends DataClass implements Insertable<ReadingClub> {
  final int id;
  final String uuid;
  final String? remoteId;
  final String name;
  final String description;
  final String city;
  final String? meetingPlace;
  final String frequency;
  final int? frequencyDays;
  final String visibility;
  final int nextBooksVisible;
  final int ownerUserId;
  final String? ownerRemoteId;
  final int? currentBookId;
  final String? currentBookUuid;
  final bool isDirty;
  final bool isDeleted;
  final DateTime? syncedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const ReadingClub(
      {required this.id,
      required this.uuid,
      this.remoteId,
      required this.name,
      required this.description,
      required this.city,
      this.meetingPlace,
      required this.frequency,
      this.frequencyDays,
      required this.visibility,
      required this.nextBooksVisible,
      required this.ownerUserId,
      this.ownerRemoteId,
      this.currentBookId,
      this.currentBookUuid,
      required this.isDirty,
      required this.isDeleted,
      this.syncedAt,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    if (!nullToAbsent || remoteId != null) {
      map['remote_id'] = Variable<String>(remoteId);
    }
    map['name'] = Variable<String>(name);
    map['description'] = Variable<String>(description);
    map['city'] = Variable<String>(city);
    if (!nullToAbsent || meetingPlace != null) {
      map['meeting_place'] = Variable<String>(meetingPlace);
    }
    map['frequency'] = Variable<String>(frequency);
    if (!nullToAbsent || frequencyDays != null) {
      map['frequency_days'] = Variable<int>(frequencyDays);
    }
    map['visibility'] = Variable<String>(visibility);
    map['next_books_visible'] = Variable<int>(nextBooksVisible);
    map['owner_user_id'] = Variable<int>(ownerUserId);
    if (!nullToAbsent || ownerRemoteId != null) {
      map['owner_remote_id'] = Variable<String>(ownerRemoteId);
    }
    if (!nullToAbsent || currentBookId != null) {
      map['current_book_id'] = Variable<int>(currentBookId);
    }
    if (!nullToAbsent || currentBookUuid != null) {
      map['current_book_uuid'] = Variable<String>(currentBookUuid);
    }
    map['is_dirty'] = Variable<bool>(isDirty);
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || syncedAt != null) {
      map['synced_at'] = Variable<DateTime>(syncedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  ReadingClubsCompanion toCompanion(bool nullToAbsent) {
    return ReadingClubsCompanion(
      id: Value(id),
      uuid: Value(uuid),
      remoteId: remoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(remoteId),
      name: Value(name),
      description: Value(description),
      city: Value(city),
      meetingPlace: meetingPlace == null && nullToAbsent
          ? const Value.absent()
          : Value(meetingPlace),
      frequency: Value(frequency),
      frequencyDays: frequencyDays == null && nullToAbsent
          ? const Value.absent()
          : Value(frequencyDays),
      visibility: Value(visibility),
      nextBooksVisible: Value(nextBooksVisible),
      ownerUserId: Value(ownerUserId),
      ownerRemoteId: ownerRemoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(ownerRemoteId),
      currentBookId: currentBookId == null && nullToAbsent
          ? const Value.absent()
          : Value(currentBookId),
      currentBookUuid: currentBookUuid == null && nullToAbsent
          ? const Value.absent()
          : Value(currentBookUuid),
      isDirty: Value(isDirty),
      isDeleted: Value(isDeleted),
      syncedAt: syncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ReadingClub.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ReadingClub(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      remoteId: serializer.fromJson<String?>(json['remoteId']),
      name: serializer.fromJson<String>(json['name']),
      description: serializer.fromJson<String>(json['description']),
      city: serializer.fromJson<String>(json['city']),
      meetingPlace: serializer.fromJson<String?>(json['meetingPlace']),
      frequency: serializer.fromJson<String>(json['frequency']),
      frequencyDays: serializer.fromJson<int?>(json['frequencyDays']),
      visibility: serializer.fromJson<String>(json['visibility']),
      nextBooksVisible: serializer.fromJson<int>(json['nextBooksVisible']),
      ownerUserId: serializer.fromJson<int>(json['ownerUserId']),
      ownerRemoteId: serializer.fromJson<String?>(json['ownerRemoteId']),
      currentBookId: serializer.fromJson<int?>(json['currentBookId']),
      currentBookUuid: serializer.fromJson<String?>(json['currentBookUuid']),
      isDirty: serializer.fromJson<bool>(json['isDirty']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      syncedAt: serializer.fromJson<DateTime?>(json['syncedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'remoteId': serializer.toJson<String?>(remoteId),
      'name': serializer.toJson<String>(name),
      'description': serializer.toJson<String>(description),
      'city': serializer.toJson<String>(city),
      'meetingPlace': serializer.toJson<String?>(meetingPlace),
      'frequency': serializer.toJson<String>(frequency),
      'frequencyDays': serializer.toJson<int?>(frequencyDays),
      'visibility': serializer.toJson<String>(visibility),
      'nextBooksVisible': serializer.toJson<int>(nextBooksVisible),
      'ownerUserId': serializer.toJson<int>(ownerUserId),
      'ownerRemoteId': serializer.toJson<String?>(ownerRemoteId),
      'currentBookId': serializer.toJson<int?>(currentBookId),
      'currentBookUuid': serializer.toJson<String?>(currentBookUuid),
      'isDirty': serializer.toJson<bool>(isDirty),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'syncedAt': serializer.toJson<DateTime?>(syncedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  ReadingClub copyWith(
          {int? id,
          String? uuid,
          Value<String?> remoteId = const Value.absent(),
          String? name,
          String? description,
          String? city,
          Value<String?> meetingPlace = const Value.absent(),
          String? frequency,
          Value<int?> frequencyDays = const Value.absent(),
          String? visibility,
          int? nextBooksVisible,
          int? ownerUserId,
          Value<String?> ownerRemoteId = const Value.absent(),
          Value<int?> currentBookId = const Value.absent(),
          Value<String?> currentBookUuid = const Value.absent(),
          bool? isDirty,
          bool? isDeleted,
          Value<DateTime?> syncedAt = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      ReadingClub(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        remoteId: remoteId.present ? remoteId.value : this.remoteId,
        name: name ?? this.name,
        description: description ?? this.description,
        city: city ?? this.city,
        meetingPlace:
            meetingPlace.present ? meetingPlace.value : this.meetingPlace,
        frequency: frequency ?? this.frequency,
        frequencyDays:
            frequencyDays.present ? frequencyDays.value : this.frequencyDays,
        visibility: visibility ?? this.visibility,
        nextBooksVisible: nextBooksVisible ?? this.nextBooksVisible,
        ownerUserId: ownerUserId ?? this.ownerUserId,
        ownerRemoteId:
            ownerRemoteId.present ? ownerRemoteId.value : this.ownerRemoteId,
        currentBookId:
            currentBookId.present ? currentBookId.value : this.currentBookId,
        currentBookUuid: currentBookUuid.present
            ? currentBookUuid.value
            : this.currentBookUuid,
        isDirty: isDirty ?? this.isDirty,
        isDeleted: isDeleted ?? this.isDeleted,
        syncedAt: syncedAt.present ? syncedAt.value : this.syncedAt,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  ReadingClub copyWithCompanion(ReadingClubsCompanion data) {
    return ReadingClub(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      remoteId: data.remoteId.present ? data.remoteId.value : this.remoteId,
      name: data.name.present ? data.name.value : this.name,
      description:
          data.description.present ? data.description.value : this.description,
      city: data.city.present ? data.city.value : this.city,
      meetingPlace: data.meetingPlace.present
          ? data.meetingPlace.value
          : this.meetingPlace,
      frequency: data.frequency.present ? data.frequency.value : this.frequency,
      frequencyDays: data.frequencyDays.present
          ? data.frequencyDays.value
          : this.frequencyDays,
      visibility:
          data.visibility.present ? data.visibility.value : this.visibility,
      nextBooksVisible: data.nextBooksVisible.present
          ? data.nextBooksVisible.value
          : this.nextBooksVisible,
      ownerUserId:
          data.ownerUserId.present ? data.ownerUserId.value : this.ownerUserId,
      ownerRemoteId: data.ownerRemoteId.present
          ? data.ownerRemoteId.value
          : this.ownerRemoteId,
      currentBookId: data.currentBookId.present
          ? data.currentBookId.value
          : this.currentBookId,
      currentBookUuid: data.currentBookUuid.present
          ? data.currentBookUuid.value
          : this.currentBookUuid,
      isDirty: data.isDirty.present ? data.isDirty.value : this.isDirty,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      syncedAt: data.syncedAt.present ? data.syncedAt.value : this.syncedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ReadingClub(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('city: $city, ')
          ..write('meetingPlace: $meetingPlace, ')
          ..write('frequency: $frequency, ')
          ..write('frequencyDays: $frequencyDays, ')
          ..write('visibility: $visibility, ')
          ..write('nextBooksVisible: $nextBooksVisible, ')
          ..write('ownerUserId: $ownerUserId, ')
          ..write('ownerRemoteId: $ownerRemoteId, ')
          ..write('currentBookId: $currentBookId, ')
          ..write('currentBookUuid: $currentBookUuid, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      remoteId,
      name,
      description,
      city,
      meetingPlace,
      frequency,
      frequencyDays,
      visibility,
      nextBooksVisible,
      ownerUserId,
      ownerRemoteId,
      currentBookId,
      currentBookUuid,
      isDirty,
      isDeleted,
      syncedAt,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ReadingClub &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.remoteId == this.remoteId &&
          other.name == this.name &&
          other.description == this.description &&
          other.city == this.city &&
          other.meetingPlace == this.meetingPlace &&
          other.frequency == this.frequency &&
          other.frequencyDays == this.frequencyDays &&
          other.visibility == this.visibility &&
          other.nextBooksVisible == this.nextBooksVisible &&
          other.ownerUserId == this.ownerUserId &&
          other.ownerRemoteId == this.ownerRemoteId &&
          other.currentBookId == this.currentBookId &&
          other.currentBookUuid == this.currentBookUuid &&
          other.isDirty == this.isDirty &&
          other.isDeleted == this.isDeleted &&
          other.syncedAt == this.syncedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ReadingClubsCompanion extends UpdateCompanion<ReadingClub> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String?> remoteId;
  final Value<String> name;
  final Value<String> description;
  final Value<String> city;
  final Value<String?> meetingPlace;
  final Value<String> frequency;
  final Value<int?> frequencyDays;
  final Value<String> visibility;
  final Value<int> nextBooksVisible;
  final Value<int> ownerUserId;
  final Value<String?> ownerRemoteId;
  final Value<int?> currentBookId;
  final Value<String?> currentBookUuid;
  final Value<bool> isDirty;
  final Value<bool> isDeleted;
  final Value<DateTime?> syncedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const ReadingClubsCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.remoteId = const Value.absent(),
    this.name = const Value.absent(),
    this.description = const Value.absent(),
    this.city = const Value.absent(),
    this.meetingPlace = const Value.absent(),
    this.frequency = const Value.absent(),
    this.frequencyDays = const Value.absent(),
    this.visibility = const Value.absent(),
    this.nextBooksVisible = const Value.absent(),
    this.ownerUserId = const Value.absent(),
    this.ownerRemoteId = const Value.absent(),
    this.currentBookId = const Value.absent(),
    this.currentBookUuid = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  ReadingClubsCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    this.remoteId = const Value.absent(),
    required String name,
    required String description,
    required String city,
    this.meetingPlace = const Value.absent(),
    required String frequency,
    this.frequencyDays = const Value.absent(),
    this.visibility = const Value.absent(),
    this.nextBooksVisible = const Value.absent(),
    required int ownerUserId,
    this.ownerRemoteId = const Value.absent(),
    this.currentBookId = const Value.absent(),
    this.currentBookUuid = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        name = Value(name),
        description = Value(description),
        city = Value(city),
        frequency = Value(frequency),
        ownerUserId = Value(ownerUserId);
  static Insertable<ReadingClub> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? remoteId,
    Expression<String>? name,
    Expression<String>? description,
    Expression<String>? city,
    Expression<String>? meetingPlace,
    Expression<String>? frequency,
    Expression<int>? frequencyDays,
    Expression<String>? visibility,
    Expression<int>? nextBooksVisible,
    Expression<int>? ownerUserId,
    Expression<String>? ownerRemoteId,
    Expression<int>? currentBookId,
    Expression<String>? currentBookUuid,
    Expression<bool>? isDirty,
    Expression<bool>? isDeleted,
    Expression<DateTime>? syncedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (remoteId != null) 'remote_id': remoteId,
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (city != null) 'city': city,
      if (meetingPlace != null) 'meeting_place': meetingPlace,
      if (frequency != null) 'frequency': frequency,
      if (frequencyDays != null) 'frequency_days': frequencyDays,
      if (visibility != null) 'visibility': visibility,
      if (nextBooksVisible != null) 'next_books_visible': nextBooksVisible,
      if (ownerUserId != null) 'owner_user_id': ownerUserId,
      if (ownerRemoteId != null) 'owner_remote_id': ownerRemoteId,
      if (currentBookId != null) 'current_book_id': currentBookId,
      if (currentBookUuid != null) 'current_book_uuid': currentBookUuid,
      if (isDirty != null) 'is_dirty': isDirty,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (syncedAt != null) 'synced_at': syncedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  ReadingClubsCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String?>? remoteId,
      Value<String>? name,
      Value<String>? description,
      Value<String>? city,
      Value<String?>? meetingPlace,
      Value<String>? frequency,
      Value<int?>? frequencyDays,
      Value<String>? visibility,
      Value<int>? nextBooksVisible,
      Value<int>? ownerUserId,
      Value<String?>? ownerRemoteId,
      Value<int?>? currentBookId,
      Value<String?>? currentBookUuid,
      Value<bool>? isDirty,
      Value<bool>? isDeleted,
      Value<DateTime?>? syncedAt,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return ReadingClubsCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      remoteId: remoteId ?? this.remoteId,
      name: name ?? this.name,
      description: description ?? this.description,
      city: city ?? this.city,
      meetingPlace: meetingPlace ?? this.meetingPlace,
      frequency: frequency ?? this.frequency,
      frequencyDays: frequencyDays ?? this.frequencyDays,
      visibility: visibility ?? this.visibility,
      nextBooksVisible: nextBooksVisible ?? this.nextBooksVisible,
      ownerUserId: ownerUserId ?? this.ownerUserId,
      ownerRemoteId: ownerRemoteId ?? this.ownerRemoteId,
      currentBookId: currentBookId ?? this.currentBookId,
      currentBookUuid: currentBookUuid ?? this.currentBookUuid,
      isDirty: isDirty ?? this.isDirty,
      isDeleted: isDeleted ?? this.isDeleted,
      syncedAt: syncedAt ?? this.syncedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (remoteId.present) {
      map['remote_id'] = Variable<String>(remoteId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (city.present) {
      map['city'] = Variable<String>(city.value);
    }
    if (meetingPlace.present) {
      map['meeting_place'] = Variable<String>(meetingPlace.value);
    }
    if (frequency.present) {
      map['frequency'] = Variable<String>(frequency.value);
    }
    if (frequencyDays.present) {
      map['frequency_days'] = Variable<int>(frequencyDays.value);
    }
    if (visibility.present) {
      map['visibility'] = Variable<String>(visibility.value);
    }
    if (nextBooksVisible.present) {
      map['next_books_visible'] = Variable<int>(nextBooksVisible.value);
    }
    if (ownerUserId.present) {
      map['owner_user_id'] = Variable<int>(ownerUserId.value);
    }
    if (ownerRemoteId.present) {
      map['owner_remote_id'] = Variable<String>(ownerRemoteId.value);
    }
    if (currentBookId.present) {
      map['current_book_id'] = Variable<int>(currentBookId.value);
    }
    if (currentBookUuid.present) {
      map['current_book_uuid'] = Variable<String>(currentBookUuid.value);
    }
    if (isDirty.present) {
      map['is_dirty'] = Variable<bool>(isDirty.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (syncedAt.present) {
      map['synced_at'] = Variable<DateTime>(syncedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ReadingClubsCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('name: $name, ')
          ..write('description: $description, ')
          ..write('city: $city, ')
          ..write('meetingPlace: $meetingPlace, ')
          ..write('frequency: $frequency, ')
          ..write('frequencyDays: $frequencyDays, ')
          ..write('visibility: $visibility, ')
          ..write('nextBooksVisible: $nextBooksVisible, ')
          ..write('ownerUserId: $ownerUserId, ')
          ..write('ownerRemoteId: $ownerRemoteId, ')
          ..write('currentBookId: $currentBookId, ')
          ..write('currentBookUuid: $currentBookUuid, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $ClubMembersTable extends ClubMembers
    with TableInfo<$ClubMembersTable, ClubMember> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ClubMembersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _remoteIdMeta =
      const VerificationMeta('remoteId');
  @override
  late final GeneratedColumn<String> remoteId = GeneratedColumn<String>(
      'remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clubIdMeta = const VerificationMeta('clubId');
  @override
  late final GeneratedColumn<int> clubId = GeneratedColumn<int>(
      'club_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES reading_clubs (id) ON DELETE CASCADE'));
  static const VerificationMeta _clubUuidMeta =
      const VerificationMeta('clubUuid');
  @override
  late final GeneratedColumn<String> clubUuid = GeneratedColumn<String>(
      'club_uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _memberUserIdMeta =
      const VerificationMeta('memberUserId');
  @override
  late final GeneratedColumn<int> memberUserId = GeneratedColumn<int>(
      'member_user_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES local_users (id)'));
  static const VerificationMeta _memberRemoteIdMeta =
      const VerificationMeta('memberRemoteId');
  @override
  late final GeneratedColumn<String> memberRemoteId = GeneratedColumn<String>(
      'member_remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _roleMeta = const VerificationMeta('role');
  @override
  late final GeneratedColumn<String> role = GeneratedColumn<String>(
      'role', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 32),
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('miembro'));
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 32),
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('activo'));
  static const VerificationMeta _joinedAtMeta =
      const VerificationMeta('joinedAt');
  @override
  late final GeneratedColumn<DateTime> joinedAt = GeneratedColumn<DateTime>(
      'joined_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _lastActivityMeta =
      const VerificationMeta('lastActivity');
  @override
  late final GeneratedColumn<DateTime> lastActivity = GeneratedColumn<DateTime>(
      'last_activity', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _isDirtyMeta =
      const VerificationMeta('isDirty');
  @override
  late final GeneratedColumn<bool> isDirty = GeneratedColumn<bool>(
      'is_dirty', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_dirty" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _syncedAtMeta =
      const VerificationMeta('syncedAt');
  @override
  late final GeneratedColumn<DateTime> syncedAt = GeneratedColumn<DateTime>(
      'synced_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        remoteId,
        clubId,
        clubUuid,
        memberUserId,
        memberRemoteId,
        role,
        status,
        joinedAt,
        lastActivity,
        isDirty,
        isDeleted,
        syncedAt,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'club_members';
  @override
  VerificationContext validateIntegrity(Insertable<ClubMember> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('remote_id')) {
      context.handle(_remoteIdMeta,
          remoteId.isAcceptableOrUnknown(data['remote_id']!, _remoteIdMeta));
    }
    if (data.containsKey('club_id')) {
      context.handle(_clubIdMeta,
          clubId.isAcceptableOrUnknown(data['club_id']!, _clubIdMeta));
    } else if (isInserting) {
      context.missing(_clubIdMeta);
    }
    if (data.containsKey('club_uuid')) {
      context.handle(_clubUuidMeta,
          clubUuid.isAcceptableOrUnknown(data['club_uuid']!, _clubUuidMeta));
    } else if (isInserting) {
      context.missing(_clubUuidMeta);
    }
    if (data.containsKey('member_user_id')) {
      context.handle(
          _memberUserIdMeta,
          memberUserId.isAcceptableOrUnknown(
              data['member_user_id']!, _memberUserIdMeta));
    } else if (isInserting) {
      context.missing(_memberUserIdMeta);
    }
    if (data.containsKey('member_remote_id')) {
      context.handle(
          _memberRemoteIdMeta,
          memberRemoteId.isAcceptableOrUnknown(
              data['member_remote_id']!, _memberRemoteIdMeta));
    }
    if (data.containsKey('role')) {
      context.handle(
          _roleMeta, role.isAcceptableOrUnknown(data['role']!, _roleMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('joined_at')) {
      context.handle(_joinedAtMeta,
          joinedAt.isAcceptableOrUnknown(data['joined_at']!, _joinedAtMeta));
    }
    if (data.containsKey('last_activity')) {
      context.handle(
          _lastActivityMeta,
          lastActivity.isAcceptableOrUnknown(
              data['last_activity']!, _lastActivityMeta));
    }
    if (data.containsKey('is_dirty')) {
      context.handle(_isDirtyMeta,
          isDirty.isAcceptableOrUnknown(data['is_dirty']!, _isDirtyMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('synced_at')) {
      context.handle(_syncedAtMeta,
          syncedAt.isAcceptableOrUnknown(data['synced_at']!, _syncedAtMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {clubId, memberUserId},
      ];
  @override
  ClubMember map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ClubMember(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      remoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}remote_id']),
      clubId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}club_id'])!,
      clubUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}club_uuid'])!,
      memberUserId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}member_user_id'])!,
      memberRemoteId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}member_remote_id']),
      role: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}role'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      joinedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}joined_at'])!,
      lastActivity: attachedDatabase.typeMapping.read(
          DriftSqlType.dateTime, data['${effectivePrefix}last_activity'])!,
      isDirty: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_dirty'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      syncedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}synced_at']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $ClubMembersTable createAlias(String alias) {
    return $ClubMembersTable(attachedDatabase, alias);
  }
}

class ClubMember extends DataClass implements Insertable<ClubMember> {
  final int id;
  final String uuid;
  final String? remoteId;
  final int clubId;
  final String clubUuid;
  final int memberUserId;
  final String? memberRemoteId;
  final String role;
  final String status;
  final DateTime joinedAt;
  final DateTime lastActivity;
  final bool isDirty;
  final bool isDeleted;
  final DateTime? syncedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const ClubMember(
      {required this.id,
      required this.uuid,
      this.remoteId,
      required this.clubId,
      required this.clubUuid,
      required this.memberUserId,
      this.memberRemoteId,
      required this.role,
      required this.status,
      required this.joinedAt,
      required this.lastActivity,
      required this.isDirty,
      required this.isDeleted,
      this.syncedAt,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    if (!nullToAbsent || remoteId != null) {
      map['remote_id'] = Variable<String>(remoteId);
    }
    map['club_id'] = Variable<int>(clubId);
    map['club_uuid'] = Variable<String>(clubUuid);
    map['member_user_id'] = Variable<int>(memberUserId);
    if (!nullToAbsent || memberRemoteId != null) {
      map['member_remote_id'] = Variable<String>(memberRemoteId);
    }
    map['role'] = Variable<String>(role);
    map['status'] = Variable<String>(status);
    map['joined_at'] = Variable<DateTime>(joinedAt);
    map['last_activity'] = Variable<DateTime>(lastActivity);
    map['is_dirty'] = Variable<bool>(isDirty);
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || syncedAt != null) {
      map['synced_at'] = Variable<DateTime>(syncedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  ClubMembersCompanion toCompanion(bool nullToAbsent) {
    return ClubMembersCompanion(
      id: Value(id),
      uuid: Value(uuid),
      remoteId: remoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(remoteId),
      clubId: Value(clubId),
      clubUuid: Value(clubUuid),
      memberUserId: Value(memberUserId),
      memberRemoteId: memberRemoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(memberRemoteId),
      role: Value(role),
      status: Value(status),
      joinedAt: Value(joinedAt),
      lastActivity: Value(lastActivity),
      isDirty: Value(isDirty),
      isDeleted: Value(isDeleted),
      syncedAt: syncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ClubMember.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ClubMember(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      remoteId: serializer.fromJson<String?>(json['remoteId']),
      clubId: serializer.fromJson<int>(json['clubId']),
      clubUuid: serializer.fromJson<String>(json['clubUuid']),
      memberUserId: serializer.fromJson<int>(json['memberUserId']),
      memberRemoteId: serializer.fromJson<String?>(json['memberRemoteId']),
      role: serializer.fromJson<String>(json['role']),
      status: serializer.fromJson<String>(json['status']),
      joinedAt: serializer.fromJson<DateTime>(json['joinedAt']),
      lastActivity: serializer.fromJson<DateTime>(json['lastActivity']),
      isDirty: serializer.fromJson<bool>(json['isDirty']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      syncedAt: serializer.fromJson<DateTime?>(json['syncedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'remoteId': serializer.toJson<String?>(remoteId),
      'clubId': serializer.toJson<int>(clubId),
      'clubUuid': serializer.toJson<String>(clubUuid),
      'memberUserId': serializer.toJson<int>(memberUserId),
      'memberRemoteId': serializer.toJson<String?>(memberRemoteId),
      'role': serializer.toJson<String>(role),
      'status': serializer.toJson<String>(status),
      'joinedAt': serializer.toJson<DateTime>(joinedAt),
      'lastActivity': serializer.toJson<DateTime>(lastActivity),
      'isDirty': serializer.toJson<bool>(isDirty),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'syncedAt': serializer.toJson<DateTime?>(syncedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  ClubMember copyWith(
          {int? id,
          String? uuid,
          Value<String?> remoteId = const Value.absent(),
          int? clubId,
          String? clubUuid,
          int? memberUserId,
          Value<String?> memberRemoteId = const Value.absent(),
          String? role,
          String? status,
          DateTime? joinedAt,
          DateTime? lastActivity,
          bool? isDirty,
          bool? isDeleted,
          Value<DateTime?> syncedAt = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      ClubMember(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        remoteId: remoteId.present ? remoteId.value : this.remoteId,
        clubId: clubId ?? this.clubId,
        clubUuid: clubUuid ?? this.clubUuid,
        memberUserId: memberUserId ?? this.memberUserId,
        memberRemoteId:
            memberRemoteId.present ? memberRemoteId.value : this.memberRemoteId,
        role: role ?? this.role,
        status: status ?? this.status,
        joinedAt: joinedAt ?? this.joinedAt,
        lastActivity: lastActivity ?? this.lastActivity,
        isDirty: isDirty ?? this.isDirty,
        isDeleted: isDeleted ?? this.isDeleted,
        syncedAt: syncedAt.present ? syncedAt.value : this.syncedAt,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  ClubMember copyWithCompanion(ClubMembersCompanion data) {
    return ClubMember(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      remoteId: data.remoteId.present ? data.remoteId.value : this.remoteId,
      clubId: data.clubId.present ? data.clubId.value : this.clubId,
      clubUuid: data.clubUuid.present ? data.clubUuid.value : this.clubUuid,
      memberUserId: data.memberUserId.present
          ? data.memberUserId.value
          : this.memberUserId,
      memberRemoteId: data.memberRemoteId.present
          ? data.memberRemoteId.value
          : this.memberRemoteId,
      role: data.role.present ? data.role.value : this.role,
      status: data.status.present ? data.status.value : this.status,
      joinedAt: data.joinedAt.present ? data.joinedAt.value : this.joinedAt,
      lastActivity: data.lastActivity.present
          ? data.lastActivity.value
          : this.lastActivity,
      isDirty: data.isDirty.present ? data.isDirty.value : this.isDirty,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      syncedAt: data.syncedAt.present ? data.syncedAt.value : this.syncedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ClubMember(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('clubId: $clubId, ')
          ..write('clubUuid: $clubUuid, ')
          ..write('memberUserId: $memberUserId, ')
          ..write('memberRemoteId: $memberRemoteId, ')
          ..write('role: $role, ')
          ..write('status: $status, ')
          ..write('joinedAt: $joinedAt, ')
          ..write('lastActivity: $lastActivity, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      remoteId,
      clubId,
      clubUuid,
      memberUserId,
      memberRemoteId,
      role,
      status,
      joinedAt,
      lastActivity,
      isDirty,
      isDeleted,
      syncedAt,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ClubMember &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.remoteId == this.remoteId &&
          other.clubId == this.clubId &&
          other.clubUuid == this.clubUuid &&
          other.memberUserId == this.memberUserId &&
          other.memberRemoteId == this.memberRemoteId &&
          other.role == this.role &&
          other.status == this.status &&
          other.joinedAt == this.joinedAt &&
          other.lastActivity == this.lastActivity &&
          other.isDirty == this.isDirty &&
          other.isDeleted == this.isDeleted &&
          other.syncedAt == this.syncedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ClubMembersCompanion extends UpdateCompanion<ClubMember> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String?> remoteId;
  final Value<int> clubId;
  final Value<String> clubUuid;
  final Value<int> memberUserId;
  final Value<String?> memberRemoteId;
  final Value<String> role;
  final Value<String> status;
  final Value<DateTime> joinedAt;
  final Value<DateTime> lastActivity;
  final Value<bool> isDirty;
  final Value<bool> isDeleted;
  final Value<DateTime?> syncedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const ClubMembersCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.remoteId = const Value.absent(),
    this.clubId = const Value.absent(),
    this.clubUuid = const Value.absent(),
    this.memberUserId = const Value.absent(),
    this.memberRemoteId = const Value.absent(),
    this.role = const Value.absent(),
    this.status = const Value.absent(),
    this.joinedAt = const Value.absent(),
    this.lastActivity = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  ClubMembersCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    this.remoteId = const Value.absent(),
    required int clubId,
    required String clubUuid,
    required int memberUserId,
    this.memberRemoteId = const Value.absent(),
    this.role = const Value.absent(),
    this.status = const Value.absent(),
    this.joinedAt = const Value.absent(),
    this.lastActivity = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        clubId = Value(clubId),
        clubUuid = Value(clubUuid),
        memberUserId = Value(memberUserId);
  static Insertable<ClubMember> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? remoteId,
    Expression<int>? clubId,
    Expression<String>? clubUuid,
    Expression<int>? memberUserId,
    Expression<String>? memberRemoteId,
    Expression<String>? role,
    Expression<String>? status,
    Expression<DateTime>? joinedAt,
    Expression<DateTime>? lastActivity,
    Expression<bool>? isDirty,
    Expression<bool>? isDeleted,
    Expression<DateTime>? syncedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (remoteId != null) 'remote_id': remoteId,
      if (clubId != null) 'club_id': clubId,
      if (clubUuid != null) 'club_uuid': clubUuid,
      if (memberUserId != null) 'member_user_id': memberUserId,
      if (memberRemoteId != null) 'member_remote_id': memberRemoteId,
      if (role != null) 'role': role,
      if (status != null) 'status': status,
      if (joinedAt != null) 'joined_at': joinedAt,
      if (lastActivity != null) 'last_activity': lastActivity,
      if (isDirty != null) 'is_dirty': isDirty,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (syncedAt != null) 'synced_at': syncedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  ClubMembersCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String?>? remoteId,
      Value<int>? clubId,
      Value<String>? clubUuid,
      Value<int>? memberUserId,
      Value<String?>? memberRemoteId,
      Value<String>? role,
      Value<String>? status,
      Value<DateTime>? joinedAt,
      Value<DateTime>? lastActivity,
      Value<bool>? isDirty,
      Value<bool>? isDeleted,
      Value<DateTime?>? syncedAt,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return ClubMembersCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      remoteId: remoteId ?? this.remoteId,
      clubId: clubId ?? this.clubId,
      clubUuid: clubUuid ?? this.clubUuid,
      memberUserId: memberUserId ?? this.memberUserId,
      memberRemoteId: memberRemoteId ?? this.memberRemoteId,
      role: role ?? this.role,
      status: status ?? this.status,
      joinedAt: joinedAt ?? this.joinedAt,
      lastActivity: lastActivity ?? this.lastActivity,
      isDirty: isDirty ?? this.isDirty,
      isDeleted: isDeleted ?? this.isDeleted,
      syncedAt: syncedAt ?? this.syncedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (remoteId.present) {
      map['remote_id'] = Variable<String>(remoteId.value);
    }
    if (clubId.present) {
      map['club_id'] = Variable<int>(clubId.value);
    }
    if (clubUuid.present) {
      map['club_uuid'] = Variable<String>(clubUuid.value);
    }
    if (memberUserId.present) {
      map['member_user_id'] = Variable<int>(memberUserId.value);
    }
    if (memberRemoteId.present) {
      map['member_remote_id'] = Variable<String>(memberRemoteId.value);
    }
    if (role.present) {
      map['role'] = Variable<String>(role.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (joinedAt.present) {
      map['joined_at'] = Variable<DateTime>(joinedAt.value);
    }
    if (lastActivity.present) {
      map['last_activity'] = Variable<DateTime>(lastActivity.value);
    }
    if (isDirty.present) {
      map['is_dirty'] = Variable<bool>(isDirty.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (syncedAt.present) {
      map['synced_at'] = Variable<DateTime>(syncedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ClubMembersCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('clubId: $clubId, ')
          ..write('clubUuid: $clubUuid, ')
          ..write('memberUserId: $memberUserId, ')
          ..write('memberRemoteId: $memberRemoteId, ')
          ..write('role: $role, ')
          ..write('status: $status, ')
          ..write('joinedAt: $joinedAt, ')
          ..write('lastActivity: $lastActivity, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $ClubBooksTable extends ClubBooks
    with TableInfo<$ClubBooksTable, ClubBook> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ClubBooksTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _remoteIdMeta =
      const VerificationMeta('remoteId');
  @override
  late final GeneratedColumn<String> remoteId = GeneratedColumn<String>(
      'remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clubIdMeta = const VerificationMeta('clubId');
  @override
  late final GeneratedColumn<int> clubId = GeneratedColumn<int>(
      'club_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES reading_clubs (id) ON DELETE CASCADE'));
  static const VerificationMeta _clubUuidMeta =
      const VerificationMeta('clubUuid');
  @override
  late final GeneratedColumn<String> clubUuid = GeneratedColumn<String>(
      'club_uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _bookUuidMeta =
      const VerificationMeta('bookUuid');
  @override
  late final GeneratedColumn<String> bookUuid = GeneratedColumn<String>(
      'book_uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _orderPositionMeta =
      const VerificationMeta('orderPosition');
  @override
  late final GeneratedColumn<int> orderPosition = GeneratedColumn<int>(
      'order_position', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 32),
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('propuesto'));
  static const VerificationMeta _sectionModeMeta =
      const VerificationMeta('sectionMode');
  @override
  late final GeneratedColumn<String> sectionMode = GeneratedColumn<String>(
      'section_mode', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 32),
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('automatico'));
  static const VerificationMeta _totalChaptersMeta =
      const VerificationMeta('totalChapters');
  @override
  late final GeneratedColumn<int> totalChapters = GeneratedColumn<int>(
      'total_chapters', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _sectionsMeta =
      const VerificationMeta('sections');
  @override
  late final GeneratedColumn<String> sections = GeneratedColumn<String>(
      'sections', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _startDateMeta =
      const VerificationMeta('startDate');
  @override
  late final GeneratedColumn<DateTime> startDate = GeneratedColumn<DateTime>(
      'start_date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _endDateMeta =
      const VerificationMeta('endDate');
  @override
  late final GeneratedColumn<DateTime> endDate = GeneratedColumn<DateTime>(
      'end_date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _isDirtyMeta =
      const VerificationMeta('isDirty');
  @override
  late final GeneratedColumn<bool> isDirty = GeneratedColumn<bool>(
      'is_dirty', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_dirty" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _syncedAtMeta =
      const VerificationMeta('syncedAt');
  @override
  late final GeneratedColumn<DateTime> syncedAt = GeneratedColumn<DateTime>(
      'synced_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        remoteId,
        clubId,
        clubUuid,
        bookUuid,
        orderPosition,
        status,
        sectionMode,
        totalChapters,
        sections,
        startDate,
        endDate,
        isDirty,
        isDeleted,
        syncedAt,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'club_books';
  @override
  VerificationContext validateIntegrity(Insertable<ClubBook> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('remote_id')) {
      context.handle(_remoteIdMeta,
          remoteId.isAcceptableOrUnknown(data['remote_id']!, _remoteIdMeta));
    }
    if (data.containsKey('club_id')) {
      context.handle(_clubIdMeta,
          clubId.isAcceptableOrUnknown(data['club_id']!, _clubIdMeta));
    } else if (isInserting) {
      context.missing(_clubIdMeta);
    }
    if (data.containsKey('club_uuid')) {
      context.handle(_clubUuidMeta,
          clubUuid.isAcceptableOrUnknown(data['club_uuid']!, _clubUuidMeta));
    } else if (isInserting) {
      context.missing(_clubUuidMeta);
    }
    if (data.containsKey('book_uuid')) {
      context.handle(_bookUuidMeta,
          bookUuid.isAcceptableOrUnknown(data['book_uuid']!, _bookUuidMeta));
    } else if (isInserting) {
      context.missing(_bookUuidMeta);
    }
    if (data.containsKey('order_position')) {
      context.handle(
          _orderPositionMeta,
          orderPosition.isAcceptableOrUnknown(
              data['order_position']!, _orderPositionMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('section_mode')) {
      context.handle(
          _sectionModeMeta,
          sectionMode.isAcceptableOrUnknown(
              data['section_mode']!, _sectionModeMeta));
    }
    if (data.containsKey('total_chapters')) {
      context.handle(
          _totalChaptersMeta,
          totalChapters.isAcceptableOrUnknown(
              data['total_chapters']!, _totalChaptersMeta));
    } else if (isInserting) {
      context.missing(_totalChaptersMeta);
    }
    if (data.containsKey('sections')) {
      context.handle(_sectionsMeta,
          sections.isAcceptableOrUnknown(data['sections']!, _sectionsMeta));
    } else if (isInserting) {
      context.missing(_sectionsMeta);
    }
    if (data.containsKey('start_date')) {
      context.handle(_startDateMeta,
          startDate.isAcceptableOrUnknown(data['start_date']!, _startDateMeta));
    }
    if (data.containsKey('end_date')) {
      context.handle(_endDateMeta,
          endDate.isAcceptableOrUnknown(data['end_date']!, _endDateMeta));
    }
    if (data.containsKey('is_dirty')) {
      context.handle(_isDirtyMeta,
          isDirty.isAcceptableOrUnknown(data['is_dirty']!, _isDirtyMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('synced_at')) {
      context.handle(_syncedAtMeta,
          syncedAt.isAcceptableOrUnknown(data['synced_at']!, _syncedAtMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ClubBook map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ClubBook(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      remoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}remote_id']),
      clubId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}club_id'])!,
      clubUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}club_uuid'])!,
      bookUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}book_uuid'])!,
      orderPosition: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}order_position'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      sectionMode: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}section_mode'])!,
      totalChapters: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}total_chapters'])!,
      sections: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}sections'])!,
      startDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}start_date']),
      endDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}end_date']),
      isDirty: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_dirty'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      syncedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}synced_at']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $ClubBooksTable createAlias(String alias) {
    return $ClubBooksTable(attachedDatabase, alias);
  }
}

class ClubBook extends DataClass implements Insertable<ClubBook> {
  final int id;
  final String uuid;
  final String? remoteId;
  final int clubId;
  final String clubUuid;
  final String bookUuid;
  final int orderPosition;
  final String status;
  final String sectionMode;
  final int totalChapters;
  final String sections;
  final DateTime? startDate;
  final DateTime? endDate;
  final bool isDirty;
  final bool isDeleted;
  final DateTime? syncedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const ClubBook(
      {required this.id,
      required this.uuid,
      this.remoteId,
      required this.clubId,
      required this.clubUuid,
      required this.bookUuid,
      required this.orderPosition,
      required this.status,
      required this.sectionMode,
      required this.totalChapters,
      required this.sections,
      this.startDate,
      this.endDate,
      required this.isDirty,
      required this.isDeleted,
      this.syncedAt,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    if (!nullToAbsent || remoteId != null) {
      map['remote_id'] = Variable<String>(remoteId);
    }
    map['club_id'] = Variable<int>(clubId);
    map['club_uuid'] = Variable<String>(clubUuid);
    map['book_uuid'] = Variable<String>(bookUuid);
    map['order_position'] = Variable<int>(orderPosition);
    map['status'] = Variable<String>(status);
    map['section_mode'] = Variable<String>(sectionMode);
    map['total_chapters'] = Variable<int>(totalChapters);
    map['sections'] = Variable<String>(sections);
    if (!nullToAbsent || startDate != null) {
      map['start_date'] = Variable<DateTime>(startDate);
    }
    if (!nullToAbsent || endDate != null) {
      map['end_date'] = Variable<DateTime>(endDate);
    }
    map['is_dirty'] = Variable<bool>(isDirty);
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || syncedAt != null) {
      map['synced_at'] = Variable<DateTime>(syncedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  ClubBooksCompanion toCompanion(bool nullToAbsent) {
    return ClubBooksCompanion(
      id: Value(id),
      uuid: Value(uuid),
      remoteId: remoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(remoteId),
      clubId: Value(clubId),
      clubUuid: Value(clubUuid),
      bookUuid: Value(bookUuid),
      orderPosition: Value(orderPosition),
      status: Value(status),
      sectionMode: Value(sectionMode),
      totalChapters: Value(totalChapters),
      sections: Value(sections),
      startDate: startDate == null && nullToAbsent
          ? const Value.absent()
          : Value(startDate),
      endDate: endDate == null && nullToAbsent
          ? const Value.absent()
          : Value(endDate),
      isDirty: Value(isDirty),
      isDeleted: Value(isDeleted),
      syncedAt: syncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ClubBook.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ClubBook(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      remoteId: serializer.fromJson<String?>(json['remoteId']),
      clubId: serializer.fromJson<int>(json['clubId']),
      clubUuid: serializer.fromJson<String>(json['clubUuid']),
      bookUuid: serializer.fromJson<String>(json['bookUuid']),
      orderPosition: serializer.fromJson<int>(json['orderPosition']),
      status: serializer.fromJson<String>(json['status']),
      sectionMode: serializer.fromJson<String>(json['sectionMode']),
      totalChapters: serializer.fromJson<int>(json['totalChapters']),
      sections: serializer.fromJson<String>(json['sections']),
      startDate: serializer.fromJson<DateTime?>(json['startDate']),
      endDate: serializer.fromJson<DateTime?>(json['endDate']),
      isDirty: serializer.fromJson<bool>(json['isDirty']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      syncedAt: serializer.fromJson<DateTime?>(json['syncedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'remoteId': serializer.toJson<String?>(remoteId),
      'clubId': serializer.toJson<int>(clubId),
      'clubUuid': serializer.toJson<String>(clubUuid),
      'bookUuid': serializer.toJson<String>(bookUuid),
      'orderPosition': serializer.toJson<int>(orderPosition),
      'status': serializer.toJson<String>(status),
      'sectionMode': serializer.toJson<String>(sectionMode),
      'totalChapters': serializer.toJson<int>(totalChapters),
      'sections': serializer.toJson<String>(sections),
      'startDate': serializer.toJson<DateTime?>(startDate),
      'endDate': serializer.toJson<DateTime?>(endDate),
      'isDirty': serializer.toJson<bool>(isDirty),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'syncedAt': serializer.toJson<DateTime?>(syncedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  ClubBook copyWith(
          {int? id,
          String? uuid,
          Value<String?> remoteId = const Value.absent(),
          int? clubId,
          String? clubUuid,
          String? bookUuid,
          int? orderPosition,
          String? status,
          String? sectionMode,
          int? totalChapters,
          String? sections,
          Value<DateTime?> startDate = const Value.absent(),
          Value<DateTime?> endDate = const Value.absent(),
          bool? isDirty,
          bool? isDeleted,
          Value<DateTime?> syncedAt = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      ClubBook(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        remoteId: remoteId.present ? remoteId.value : this.remoteId,
        clubId: clubId ?? this.clubId,
        clubUuid: clubUuid ?? this.clubUuid,
        bookUuid: bookUuid ?? this.bookUuid,
        orderPosition: orderPosition ?? this.orderPosition,
        status: status ?? this.status,
        sectionMode: sectionMode ?? this.sectionMode,
        totalChapters: totalChapters ?? this.totalChapters,
        sections: sections ?? this.sections,
        startDate: startDate.present ? startDate.value : this.startDate,
        endDate: endDate.present ? endDate.value : this.endDate,
        isDirty: isDirty ?? this.isDirty,
        isDeleted: isDeleted ?? this.isDeleted,
        syncedAt: syncedAt.present ? syncedAt.value : this.syncedAt,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  ClubBook copyWithCompanion(ClubBooksCompanion data) {
    return ClubBook(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      remoteId: data.remoteId.present ? data.remoteId.value : this.remoteId,
      clubId: data.clubId.present ? data.clubId.value : this.clubId,
      clubUuid: data.clubUuid.present ? data.clubUuid.value : this.clubUuid,
      bookUuid: data.bookUuid.present ? data.bookUuid.value : this.bookUuid,
      orderPosition: data.orderPosition.present
          ? data.orderPosition.value
          : this.orderPosition,
      status: data.status.present ? data.status.value : this.status,
      sectionMode:
          data.sectionMode.present ? data.sectionMode.value : this.sectionMode,
      totalChapters: data.totalChapters.present
          ? data.totalChapters.value
          : this.totalChapters,
      sections: data.sections.present ? data.sections.value : this.sections,
      startDate: data.startDate.present ? data.startDate.value : this.startDate,
      endDate: data.endDate.present ? data.endDate.value : this.endDate,
      isDirty: data.isDirty.present ? data.isDirty.value : this.isDirty,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      syncedAt: data.syncedAt.present ? data.syncedAt.value : this.syncedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ClubBook(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('clubId: $clubId, ')
          ..write('clubUuid: $clubUuid, ')
          ..write('bookUuid: $bookUuid, ')
          ..write('orderPosition: $orderPosition, ')
          ..write('status: $status, ')
          ..write('sectionMode: $sectionMode, ')
          ..write('totalChapters: $totalChapters, ')
          ..write('sections: $sections, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      remoteId,
      clubId,
      clubUuid,
      bookUuid,
      orderPosition,
      status,
      sectionMode,
      totalChapters,
      sections,
      startDate,
      endDate,
      isDirty,
      isDeleted,
      syncedAt,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ClubBook &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.remoteId == this.remoteId &&
          other.clubId == this.clubId &&
          other.clubUuid == this.clubUuid &&
          other.bookUuid == this.bookUuid &&
          other.orderPosition == this.orderPosition &&
          other.status == this.status &&
          other.sectionMode == this.sectionMode &&
          other.totalChapters == this.totalChapters &&
          other.sections == this.sections &&
          other.startDate == this.startDate &&
          other.endDate == this.endDate &&
          other.isDirty == this.isDirty &&
          other.isDeleted == this.isDeleted &&
          other.syncedAt == this.syncedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ClubBooksCompanion extends UpdateCompanion<ClubBook> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String?> remoteId;
  final Value<int> clubId;
  final Value<String> clubUuid;
  final Value<String> bookUuid;
  final Value<int> orderPosition;
  final Value<String> status;
  final Value<String> sectionMode;
  final Value<int> totalChapters;
  final Value<String> sections;
  final Value<DateTime?> startDate;
  final Value<DateTime?> endDate;
  final Value<bool> isDirty;
  final Value<bool> isDeleted;
  final Value<DateTime?> syncedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const ClubBooksCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.remoteId = const Value.absent(),
    this.clubId = const Value.absent(),
    this.clubUuid = const Value.absent(),
    this.bookUuid = const Value.absent(),
    this.orderPosition = const Value.absent(),
    this.status = const Value.absent(),
    this.sectionMode = const Value.absent(),
    this.totalChapters = const Value.absent(),
    this.sections = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  ClubBooksCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    this.remoteId = const Value.absent(),
    required int clubId,
    required String clubUuid,
    required String bookUuid,
    this.orderPosition = const Value.absent(),
    this.status = const Value.absent(),
    this.sectionMode = const Value.absent(),
    required int totalChapters,
    required String sections,
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        clubId = Value(clubId),
        clubUuid = Value(clubUuid),
        bookUuid = Value(bookUuid),
        totalChapters = Value(totalChapters),
        sections = Value(sections);
  static Insertable<ClubBook> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? remoteId,
    Expression<int>? clubId,
    Expression<String>? clubUuid,
    Expression<String>? bookUuid,
    Expression<int>? orderPosition,
    Expression<String>? status,
    Expression<String>? sectionMode,
    Expression<int>? totalChapters,
    Expression<String>? sections,
    Expression<DateTime>? startDate,
    Expression<DateTime>? endDate,
    Expression<bool>? isDirty,
    Expression<bool>? isDeleted,
    Expression<DateTime>? syncedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (remoteId != null) 'remote_id': remoteId,
      if (clubId != null) 'club_id': clubId,
      if (clubUuid != null) 'club_uuid': clubUuid,
      if (bookUuid != null) 'book_uuid': bookUuid,
      if (orderPosition != null) 'order_position': orderPosition,
      if (status != null) 'status': status,
      if (sectionMode != null) 'section_mode': sectionMode,
      if (totalChapters != null) 'total_chapters': totalChapters,
      if (sections != null) 'sections': sections,
      if (startDate != null) 'start_date': startDate,
      if (endDate != null) 'end_date': endDate,
      if (isDirty != null) 'is_dirty': isDirty,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (syncedAt != null) 'synced_at': syncedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  ClubBooksCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String?>? remoteId,
      Value<int>? clubId,
      Value<String>? clubUuid,
      Value<String>? bookUuid,
      Value<int>? orderPosition,
      Value<String>? status,
      Value<String>? sectionMode,
      Value<int>? totalChapters,
      Value<String>? sections,
      Value<DateTime?>? startDate,
      Value<DateTime?>? endDate,
      Value<bool>? isDirty,
      Value<bool>? isDeleted,
      Value<DateTime?>? syncedAt,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return ClubBooksCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      remoteId: remoteId ?? this.remoteId,
      clubId: clubId ?? this.clubId,
      clubUuid: clubUuid ?? this.clubUuid,
      bookUuid: bookUuid ?? this.bookUuid,
      orderPosition: orderPosition ?? this.orderPosition,
      status: status ?? this.status,
      sectionMode: sectionMode ?? this.sectionMode,
      totalChapters: totalChapters ?? this.totalChapters,
      sections: sections ?? this.sections,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      isDirty: isDirty ?? this.isDirty,
      isDeleted: isDeleted ?? this.isDeleted,
      syncedAt: syncedAt ?? this.syncedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (remoteId.present) {
      map['remote_id'] = Variable<String>(remoteId.value);
    }
    if (clubId.present) {
      map['club_id'] = Variable<int>(clubId.value);
    }
    if (clubUuid.present) {
      map['club_uuid'] = Variable<String>(clubUuid.value);
    }
    if (bookUuid.present) {
      map['book_uuid'] = Variable<String>(bookUuid.value);
    }
    if (orderPosition.present) {
      map['order_position'] = Variable<int>(orderPosition.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (sectionMode.present) {
      map['section_mode'] = Variable<String>(sectionMode.value);
    }
    if (totalChapters.present) {
      map['total_chapters'] = Variable<int>(totalChapters.value);
    }
    if (sections.present) {
      map['sections'] = Variable<String>(sections.value);
    }
    if (startDate.present) {
      map['start_date'] = Variable<DateTime>(startDate.value);
    }
    if (endDate.present) {
      map['end_date'] = Variable<DateTime>(endDate.value);
    }
    if (isDirty.present) {
      map['is_dirty'] = Variable<bool>(isDirty.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (syncedAt.present) {
      map['synced_at'] = Variable<DateTime>(syncedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ClubBooksCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('clubId: $clubId, ')
          ..write('clubUuid: $clubUuid, ')
          ..write('bookUuid: $bookUuid, ')
          ..write('orderPosition: $orderPosition, ')
          ..write('status: $status, ')
          ..write('sectionMode: $sectionMode, ')
          ..write('totalChapters: $totalChapters, ')
          ..write('sections: $sections, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $ClubReadingProgressTable extends ClubReadingProgress
    with TableInfo<$ClubReadingProgressTable, ClubReadingProgressData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ClubReadingProgressTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _clubIdMeta = const VerificationMeta('clubId');
  @override
  late final GeneratedColumn<int> clubId = GeneratedColumn<int>(
      'club_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES reading_clubs (id) ON DELETE CASCADE'));
  static const VerificationMeta _clubUuidMeta =
      const VerificationMeta('clubUuid');
  @override
  late final GeneratedColumn<String> clubUuid = GeneratedColumn<String>(
      'club_uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _bookIdMeta = const VerificationMeta('bookId');
  @override
  late final GeneratedColumn<int> bookId = GeneratedColumn<int>(
      'book_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES club_books (id) ON DELETE CASCADE'));
  static const VerificationMeta _bookUuidMeta =
      const VerificationMeta('bookUuid');
  @override
  late final GeneratedColumn<String> bookUuid = GeneratedColumn<String>(
      'book_uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<int> userId = GeneratedColumn<int>(
      'user_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES local_users (id)'));
  static const VerificationMeta _userRemoteIdMeta =
      const VerificationMeta('userRemoteId');
  @override
  late final GeneratedColumn<String> userRemoteId = GeneratedColumn<String>(
      'user_remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _remoteIdMeta =
      const VerificationMeta('remoteId');
  @override
  late final GeneratedColumn<String> remoteId = GeneratedColumn<String>(
      'remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 32),
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('no_empezado'));
  static const VerificationMeta _currentChapterMeta =
      const VerificationMeta('currentChapter');
  @override
  late final GeneratedColumn<int> currentChapter = GeneratedColumn<int>(
      'current_chapter', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _currentSectionMeta =
      const VerificationMeta('currentSection');
  @override
  late final GeneratedColumn<int> currentSection = GeneratedColumn<int>(
      'current_section', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _isDirtyMeta =
      const VerificationMeta('isDirty');
  @override
  late final GeneratedColumn<bool> isDirty = GeneratedColumn<bool>(
      'is_dirty', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_dirty" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _syncedAtMeta =
      const VerificationMeta('syncedAt');
  @override
  late final GeneratedColumn<DateTime> syncedAt = GeneratedColumn<DateTime>(
      'synced_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        clubId,
        clubUuid,
        bookId,
        bookUuid,
        userId,
        userRemoteId,
        remoteId,
        status,
        currentChapter,
        currentSection,
        isDirty,
        syncedAt,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'club_reading_progress';
  @override
  VerificationContext validateIntegrity(
      Insertable<ClubReadingProgressData> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('club_id')) {
      context.handle(_clubIdMeta,
          clubId.isAcceptableOrUnknown(data['club_id']!, _clubIdMeta));
    } else if (isInserting) {
      context.missing(_clubIdMeta);
    }
    if (data.containsKey('club_uuid')) {
      context.handle(_clubUuidMeta,
          clubUuid.isAcceptableOrUnknown(data['club_uuid']!, _clubUuidMeta));
    } else if (isInserting) {
      context.missing(_clubUuidMeta);
    }
    if (data.containsKey('book_id')) {
      context.handle(_bookIdMeta,
          bookId.isAcceptableOrUnknown(data['book_id']!, _bookIdMeta));
    } else if (isInserting) {
      context.missing(_bookIdMeta);
    }
    if (data.containsKey('book_uuid')) {
      context.handle(_bookUuidMeta,
          bookUuid.isAcceptableOrUnknown(data['book_uuid']!, _bookUuidMeta));
    } else if (isInserting) {
      context.missing(_bookUuidMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta));
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('user_remote_id')) {
      context.handle(
          _userRemoteIdMeta,
          userRemoteId.isAcceptableOrUnknown(
              data['user_remote_id']!, _userRemoteIdMeta));
    }
    if (data.containsKey('remote_id')) {
      context.handle(_remoteIdMeta,
          remoteId.isAcceptableOrUnknown(data['remote_id']!, _remoteIdMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('current_chapter')) {
      context.handle(
          _currentChapterMeta,
          currentChapter.isAcceptableOrUnknown(
              data['current_chapter']!, _currentChapterMeta));
    }
    if (data.containsKey('current_section')) {
      context.handle(
          _currentSectionMeta,
          currentSection.isAcceptableOrUnknown(
              data['current_section']!, _currentSectionMeta));
    }
    if (data.containsKey('is_dirty')) {
      context.handle(_isDirtyMeta,
          isDirty.isAcceptableOrUnknown(data['is_dirty']!, _isDirtyMeta));
    }
    if (data.containsKey('synced_at')) {
      context.handle(_syncedAtMeta,
          syncedAt.isAcceptableOrUnknown(data['synced_at']!, _syncedAtMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {clubId, bookId, userId},
      ];
  @override
  ClubReadingProgressData map(Map<String, dynamic> data,
      {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ClubReadingProgressData(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      clubId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}club_id'])!,
      clubUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}club_uuid'])!,
      bookId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}book_id'])!,
      bookUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}book_uuid'])!,
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}user_id'])!,
      userRemoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_remote_id']),
      remoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}remote_id']),
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      currentChapter: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}current_chapter'])!,
      currentSection: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}current_section'])!,
      isDirty: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_dirty'])!,
      syncedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}synced_at']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $ClubReadingProgressTable createAlias(String alias) {
    return $ClubReadingProgressTable(attachedDatabase, alias);
  }
}

class ClubReadingProgressData extends DataClass
    implements Insertable<ClubReadingProgressData> {
  final int id;
  final String uuid;
  final int clubId;
  final String clubUuid;
  final int bookId;
  final String bookUuid;
  final int userId;
  final String? userRemoteId;
  final String? remoteId;
  final String status;
  final int currentChapter;
  final int currentSection;
  final bool isDirty;
  final DateTime? syncedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const ClubReadingProgressData(
      {required this.id,
      required this.uuid,
      required this.clubId,
      required this.clubUuid,
      required this.bookId,
      required this.bookUuid,
      required this.userId,
      this.userRemoteId,
      this.remoteId,
      required this.status,
      required this.currentChapter,
      required this.currentSection,
      required this.isDirty,
      this.syncedAt,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    map['club_id'] = Variable<int>(clubId);
    map['club_uuid'] = Variable<String>(clubUuid);
    map['book_id'] = Variable<int>(bookId);
    map['book_uuid'] = Variable<String>(bookUuid);
    map['user_id'] = Variable<int>(userId);
    if (!nullToAbsent || userRemoteId != null) {
      map['user_remote_id'] = Variable<String>(userRemoteId);
    }
    if (!nullToAbsent || remoteId != null) {
      map['remote_id'] = Variable<String>(remoteId);
    }
    map['status'] = Variable<String>(status);
    map['current_chapter'] = Variable<int>(currentChapter);
    map['current_section'] = Variable<int>(currentSection);
    map['is_dirty'] = Variable<bool>(isDirty);
    if (!nullToAbsent || syncedAt != null) {
      map['synced_at'] = Variable<DateTime>(syncedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  ClubReadingProgressCompanion toCompanion(bool nullToAbsent) {
    return ClubReadingProgressCompanion(
      id: Value(id),
      uuid: Value(uuid),
      clubId: Value(clubId),
      clubUuid: Value(clubUuid),
      bookId: Value(bookId),
      bookUuid: Value(bookUuid),
      userId: Value(userId),
      userRemoteId: userRemoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(userRemoteId),
      remoteId: remoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(remoteId),
      status: Value(status),
      currentChapter: Value(currentChapter),
      currentSection: Value(currentSection),
      isDirty: Value(isDirty),
      syncedAt: syncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory ClubReadingProgressData.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ClubReadingProgressData(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      clubId: serializer.fromJson<int>(json['clubId']),
      clubUuid: serializer.fromJson<String>(json['clubUuid']),
      bookId: serializer.fromJson<int>(json['bookId']),
      bookUuid: serializer.fromJson<String>(json['bookUuid']),
      userId: serializer.fromJson<int>(json['userId']),
      userRemoteId: serializer.fromJson<String?>(json['userRemoteId']),
      remoteId: serializer.fromJson<String?>(json['remoteId']),
      status: serializer.fromJson<String>(json['status']),
      currentChapter: serializer.fromJson<int>(json['currentChapter']),
      currentSection: serializer.fromJson<int>(json['currentSection']),
      isDirty: serializer.fromJson<bool>(json['isDirty']),
      syncedAt: serializer.fromJson<DateTime?>(json['syncedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'clubId': serializer.toJson<int>(clubId),
      'clubUuid': serializer.toJson<String>(clubUuid),
      'bookId': serializer.toJson<int>(bookId),
      'bookUuid': serializer.toJson<String>(bookUuid),
      'userId': serializer.toJson<int>(userId),
      'userRemoteId': serializer.toJson<String?>(userRemoteId),
      'remoteId': serializer.toJson<String?>(remoteId),
      'status': serializer.toJson<String>(status),
      'currentChapter': serializer.toJson<int>(currentChapter),
      'currentSection': serializer.toJson<int>(currentSection),
      'isDirty': serializer.toJson<bool>(isDirty),
      'syncedAt': serializer.toJson<DateTime?>(syncedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  ClubReadingProgressData copyWith(
          {int? id,
          String? uuid,
          int? clubId,
          String? clubUuid,
          int? bookId,
          String? bookUuid,
          int? userId,
          Value<String?> userRemoteId = const Value.absent(),
          Value<String?> remoteId = const Value.absent(),
          String? status,
          int? currentChapter,
          int? currentSection,
          bool? isDirty,
          Value<DateTime?> syncedAt = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      ClubReadingProgressData(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        clubId: clubId ?? this.clubId,
        clubUuid: clubUuid ?? this.clubUuid,
        bookId: bookId ?? this.bookId,
        bookUuid: bookUuid ?? this.bookUuid,
        userId: userId ?? this.userId,
        userRemoteId:
            userRemoteId.present ? userRemoteId.value : this.userRemoteId,
        remoteId: remoteId.present ? remoteId.value : this.remoteId,
        status: status ?? this.status,
        currentChapter: currentChapter ?? this.currentChapter,
        currentSection: currentSection ?? this.currentSection,
        isDirty: isDirty ?? this.isDirty,
        syncedAt: syncedAt.present ? syncedAt.value : this.syncedAt,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  ClubReadingProgressData copyWithCompanion(ClubReadingProgressCompanion data) {
    return ClubReadingProgressData(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      clubId: data.clubId.present ? data.clubId.value : this.clubId,
      clubUuid: data.clubUuid.present ? data.clubUuid.value : this.clubUuid,
      bookId: data.bookId.present ? data.bookId.value : this.bookId,
      bookUuid: data.bookUuid.present ? data.bookUuid.value : this.bookUuid,
      userId: data.userId.present ? data.userId.value : this.userId,
      userRemoteId: data.userRemoteId.present
          ? data.userRemoteId.value
          : this.userRemoteId,
      remoteId: data.remoteId.present ? data.remoteId.value : this.remoteId,
      status: data.status.present ? data.status.value : this.status,
      currentChapter: data.currentChapter.present
          ? data.currentChapter.value
          : this.currentChapter,
      currentSection: data.currentSection.present
          ? data.currentSection.value
          : this.currentSection,
      isDirty: data.isDirty.present ? data.isDirty.value : this.isDirty,
      syncedAt: data.syncedAt.present ? data.syncedAt.value : this.syncedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ClubReadingProgressData(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('clubId: $clubId, ')
          ..write('clubUuid: $clubUuid, ')
          ..write('bookId: $bookId, ')
          ..write('bookUuid: $bookUuid, ')
          ..write('userId: $userId, ')
          ..write('userRemoteId: $userRemoteId, ')
          ..write('remoteId: $remoteId, ')
          ..write('status: $status, ')
          ..write('currentChapter: $currentChapter, ')
          ..write('currentSection: $currentSection, ')
          ..write('isDirty: $isDirty, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      clubId,
      clubUuid,
      bookId,
      bookUuid,
      userId,
      userRemoteId,
      remoteId,
      status,
      currentChapter,
      currentSection,
      isDirty,
      syncedAt,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ClubReadingProgressData &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.clubId == this.clubId &&
          other.clubUuid == this.clubUuid &&
          other.bookId == this.bookId &&
          other.bookUuid == this.bookUuid &&
          other.userId == this.userId &&
          other.userRemoteId == this.userRemoteId &&
          other.remoteId == this.remoteId &&
          other.status == this.status &&
          other.currentChapter == this.currentChapter &&
          other.currentSection == this.currentSection &&
          other.isDirty == this.isDirty &&
          other.syncedAt == this.syncedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class ClubReadingProgressCompanion
    extends UpdateCompanion<ClubReadingProgressData> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<int> clubId;
  final Value<String> clubUuid;
  final Value<int> bookId;
  final Value<String> bookUuid;
  final Value<int> userId;
  final Value<String?> userRemoteId;
  final Value<String?> remoteId;
  final Value<String> status;
  final Value<int> currentChapter;
  final Value<int> currentSection;
  final Value<bool> isDirty;
  final Value<DateTime?> syncedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const ClubReadingProgressCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.clubId = const Value.absent(),
    this.clubUuid = const Value.absent(),
    this.bookId = const Value.absent(),
    this.bookUuid = const Value.absent(),
    this.userId = const Value.absent(),
    this.userRemoteId = const Value.absent(),
    this.remoteId = const Value.absent(),
    this.status = const Value.absent(),
    this.currentChapter = const Value.absent(),
    this.currentSection = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  ClubReadingProgressCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    required int clubId,
    required String clubUuid,
    required int bookId,
    required String bookUuid,
    required int userId,
    this.userRemoteId = const Value.absent(),
    this.remoteId = const Value.absent(),
    this.status = const Value.absent(),
    this.currentChapter = const Value.absent(),
    this.currentSection = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        clubId = Value(clubId),
        clubUuid = Value(clubUuid),
        bookId = Value(bookId),
        bookUuid = Value(bookUuid),
        userId = Value(userId);
  static Insertable<ClubReadingProgressData> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<int>? clubId,
    Expression<String>? clubUuid,
    Expression<int>? bookId,
    Expression<String>? bookUuid,
    Expression<int>? userId,
    Expression<String>? userRemoteId,
    Expression<String>? remoteId,
    Expression<String>? status,
    Expression<int>? currentChapter,
    Expression<int>? currentSection,
    Expression<bool>? isDirty,
    Expression<DateTime>? syncedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (clubId != null) 'club_id': clubId,
      if (clubUuid != null) 'club_uuid': clubUuid,
      if (bookId != null) 'book_id': bookId,
      if (bookUuid != null) 'book_uuid': bookUuid,
      if (userId != null) 'user_id': userId,
      if (userRemoteId != null) 'user_remote_id': userRemoteId,
      if (remoteId != null) 'remote_id': remoteId,
      if (status != null) 'status': status,
      if (currentChapter != null) 'current_chapter': currentChapter,
      if (currentSection != null) 'current_section': currentSection,
      if (isDirty != null) 'is_dirty': isDirty,
      if (syncedAt != null) 'synced_at': syncedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  ClubReadingProgressCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<int>? clubId,
      Value<String>? clubUuid,
      Value<int>? bookId,
      Value<String>? bookUuid,
      Value<int>? userId,
      Value<String?>? userRemoteId,
      Value<String?>? remoteId,
      Value<String>? status,
      Value<int>? currentChapter,
      Value<int>? currentSection,
      Value<bool>? isDirty,
      Value<DateTime?>? syncedAt,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return ClubReadingProgressCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      clubId: clubId ?? this.clubId,
      clubUuid: clubUuid ?? this.clubUuid,
      bookId: bookId ?? this.bookId,
      bookUuid: bookUuid ?? this.bookUuid,
      userId: userId ?? this.userId,
      userRemoteId: userRemoteId ?? this.userRemoteId,
      remoteId: remoteId ?? this.remoteId,
      status: status ?? this.status,
      currentChapter: currentChapter ?? this.currentChapter,
      currentSection: currentSection ?? this.currentSection,
      isDirty: isDirty ?? this.isDirty,
      syncedAt: syncedAt ?? this.syncedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (clubId.present) {
      map['club_id'] = Variable<int>(clubId.value);
    }
    if (clubUuid.present) {
      map['club_uuid'] = Variable<String>(clubUuid.value);
    }
    if (bookId.present) {
      map['book_id'] = Variable<int>(bookId.value);
    }
    if (bookUuid.present) {
      map['book_uuid'] = Variable<String>(bookUuid.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<int>(userId.value);
    }
    if (userRemoteId.present) {
      map['user_remote_id'] = Variable<String>(userRemoteId.value);
    }
    if (remoteId.present) {
      map['remote_id'] = Variable<String>(remoteId.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (currentChapter.present) {
      map['current_chapter'] = Variable<int>(currentChapter.value);
    }
    if (currentSection.present) {
      map['current_section'] = Variable<int>(currentSection.value);
    }
    if (isDirty.present) {
      map['is_dirty'] = Variable<bool>(isDirty.value);
    }
    if (syncedAt.present) {
      map['synced_at'] = Variable<DateTime>(syncedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ClubReadingProgressCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('clubId: $clubId, ')
          ..write('clubUuid: $clubUuid, ')
          ..write('bookId: $bookId, ')
          ..write('bookUuid: $bookUuid, ')
          ..write('userId: $userId, ')
          ..write('userRemoteId: $userRemoteId, ')
          ..write('remoteId: $remoteId, ')
          ..write('status: $status, ')
          ..write('currentChapter: $currentChapter, ')
          ..write('currentSection: $currentSection, ')
          ..write('isDirty: $isDirty, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $BookProposalsTable extends BookProposals
    with TableInfo<$BookProposalsTable, BookProposal> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BookProposalsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _remoteIdMeta =
      const VerificationMeta('remoteId');
  @override
  late final GeneratedColumn<String> remoteId = GeneratedColumn<String>(
      'remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clubIdMeta = const VerificationMeta('clubId');
  @override
  late final GeneratedColumn<int> clubId = GeneratedColumn<int>(
      'club_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES reading_clubs (id) ON DELETE CASCADE'));
  static const VerificationMeta _clubUuidMeta =
      const VerificationMeta('clubUuid');
  @override
  late final GeneratedColumn<String> clubUuid = GeneratedColumn<String>(
      'club_uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _bookUuidMeta =
      const VerificationMeta('bookUuid');
  @override
  late final GeneratedColumn<String> bookUuid = GeneratedColumn<String>(
      'book_uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _proposedByUserIdMeta =
      const VerificationMeta('proposedByUserId');
  @override
  late final GeneratedColumn<int> proposedByUserId = GeneratedColumn<int>(
      'proposed_by_user_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES local_users (id)'));
  static const VerificationMeta _proposedByRemoteIdMeta =
      const VerificationMeta('proposedByRemoteId');
  @override
  late final GeneratedColumn<String> proposedByRemoteId =
      GeneratedColumn<String>('proposed_by_remote_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
      'title', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _authorMeta = const VerificationMeta('author');
  @override
  late final GeneratedColumn<String> author = GeneratedColumn<String>(
      'author', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isbnMeta = const VerificationMeta('isbn');
  @override
  late final GeneratedColumn<String> isbn = GeneratedColumn<String>(
      'isbn', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _coverUrlMeta =
      const VerificationMeta('coverUrl');
  @override
  late final GeneratedColumn<String> coverUrl = GeneratedColumn<String>(
      'cover_url', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _closingDateMeta =
      const VerificationMeta('closingDate');
  @override
  late final GeneratedColumn<DateTime> closingDate = GeneratedColumn<DateTime>(
      'closing_date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _totalChaptersMeta =
      const VerificationMeta('totalChapters');
  @override
  late final GeneratedColumn<int> totalChapters = GeneratedColumn<int>(
      'total_chapters', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _votesMeta = const VerificationMeta('votes');
  @override
  late final GeneratedColumn<String> votes = GeneratedColumn<String>(
      'votes', aliasedName, false,
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant(''));
  static const VerificationMeta _voteCountMeta =
      const VerificationMeta('voteCount');
  @override
  late final GeneratedColumn<int> voteCount = GeneratedColumn<int>(
      'vote_count', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
      'status', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 32),
      type: DriftSqlType.string,
      requiredDuringInsert: false,
      defaultValue: const Constant('abierta'));
  static const VerificationMeta _closeDateMeta =
      const VerificationMeta('closeDate');
  @override
  late final GeneratedColumn<DateTime> closeDate = GeneratedColumn<DateTime>(
      'close_date', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _isDirtyMeta =
      const VerificationMeta('isDirty');
  @override
  late final GeneratedColumn<bool> isDirty = GeneratedColumn<bool>(
      'is_dirty', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_dirty" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _syncedAtMeta =
      const VerificationMeta('syncedAt');
  @override
  late final GeneratedColumn<DateTime> syncedAt = GeneratedColumn<DateTime>(
      'synced_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        remoteId,
        clubId,
        clubUuid,
        bookUuid,
        proposedByUserId,
        proposedByRemoteId,
        title,
        author,
        isbn,
        coverUrl,
        closingDate,
        totalChapters,
        votes,
        voteCount,
        status,
        closeDate,
        isDirty,
        isDeleted,
        syncedAt,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'book_proposals';
  @override
  VerificationContext validateIntegrity(Insertable<BookProposal> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('remote_id')) {
      context.handle(_remoteIdMeta,
          remoteId.isAcceptableOrUnknown(data['remote_id']!, _remoteIdMeta));
    }
    if (data.containsKey('club_id')) {
      context.handle(_clubIdMeta,
          clubId.isAcceptableOrUnknown(data['club_id']!, _clubIdMeta));
    } else if (isInserting) {
      context.missing(_clubIdMeta);
    }
    if (data.containsKey('club_uuid')) {
      context.handle(_clubUuidMeta,
          clubUuid.isAcceptableOrUnknown(data['club_uuid']!, _clubUuidMeta));
    } else if (isInserting) {
      context.missing(_clubUuidMeta);
    }
    if (data.containsKey('book_uuid')) {
      context.handle(_bookUuidMeta,
          bookUuid.isAcceptableOrUnknown(data['book_uuid']!, _bookUuidMeta));
    } else if (isInserting) {
      context.missing(_bookUuidMeta);
    }
    if (data.containsKey('proposed_by_user_id')) {
      context.handle(
          _proposedByUserIdMeta,
          proposedByUserId.isAcceptableOrUnknown(
              data['proposed_by_user_id']!, _proposedByUserIdMeta));
    } else if (isInserting) {
      context.missing(_proposedByUserIdMeta);
    }
    if (data.containsKey('proposed_by_remote_id')) {
      context.handle(
          _proposedByRemoteIdMeta,
          proposedByRemoteId.isAcceptableOrUnknown(
              data['proposed_by_remote_id']!, _proposedByRemoteIdMeta));
    }
    if (data.containsKey('title')) {
      context.handle(
          _titleMeta, title.isAcceptableOrUnknown(data['title']!, _titleMeta));
    }
    if (data.containsKey('author')) {
      context.handle(_authorMeta,
          author.isAcceptableOrUnknown(data['author']!, _authorMeta));
    }
    if (data.containsKey('isbn')) {
      context.handle(
          _isbnMeta, isbn.isAcceptableOrUnknown(data['isbn']!, _isbnMeta));
    }
    if (data.containsKey('cover_url')) {
      context.handle(_coverUrlMeta,
          coverUrl.isAcceptableOrUnknown(data['cover_url']!, _coverUrlMeta));
    }
    if (data.containsKey('closing_date')) {
      context.handle(
          _closingDateMeta,
          closingDate.isAcceptableOrUnknown(
              data['closing_date']!, _closingDateMeta));
    }
    if (data.containsKey('total_chapters')) {
      context.handle(
          _totalChaptersMeta,
          totalChapters.isAcceptableOrUnknown(
              data['total_chapters']!, _totalChaptersMeta));
    } else if (isInserting) {
      context.missing(_totalChaptersMeta);
    }
    if (data.containsKey('votes')) {
      context.handle(
          _votesMeta, votes.isAcceptableOrUnknown(data['votes']!, _votesMeta));
    }
    if (data.containsKey('vote_count')) {
      context.handle(_voteCountMeta,
          voteCount.isAcceptableOrUnknown(data['vote_count']!, _voteCountMeta));
    }
    if (data.containsKey('status')) {
      context.handle(_statusMeta,
          status.isAcceptableOrUnknown(data['status']!, _statusMeta));
    }
    if (data.containsKey('close_date')) {
      context.handle(_closeDateMeta,
          closeDate.isAcceptableOrUnknown(data['close_date']!, _closeDateMeta));
    }
    if (data.containsKey('is_dirty')) {
      context.handle(_isDirtyMeta,
          isDirty.isAcceptableOrUnknown(data['is_dirty']!, _isDirtyMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('synced_at')) {
      context.handle(_syncedAtMeta,
          syncedAt.isAcceptableOrUnknown(data['synced_at']!, _syncedAtMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  BookProposal map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BookProposal(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      remoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}remote_id']),
      clubId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}club_id'])!,
      clubUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}club_uuid'])!,
      bookUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}book_uuid'])!,
      proposedByUserId: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}proposed_by_user_id'])!,
      proposedByRemoteId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}proposed_by_remote_id']),
      title: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}title']),
      author: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}author']),
      isbn: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}isbn']),
      coverUrl: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}cover_url']),
      closingDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}closing_date']),
      totalChapters: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}total_chapters'])!,
      votes: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}votes'])!,
      voteCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}vote_count'])!,
      status: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}status'])!,
      closeDate: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}close_date']),
      isDirty: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_dirty'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      syncedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}synced_at']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $BookProposalsTable createAlias(String alias) {
    return $BookProposalsTable(attachedDatabase, alias);
  }
}

class BookProposal extends DataClass implements Insertable<BookProposal> {
  final int id;
  final String uuid;
  final String? remoteId;
  final int clubId;
  final String clubUuid;
  final String bookUuid;
  final int proposedByUserId;
  final String? proposedByRemoteId;
  final String? title;
  final String? author;
  final String? isbn;
  final String? coverUrl;
  final DateTime? closingDate;
  final int totalChapters;
  final String votes;
  final int voteCount;
  final String status;
  final DateTime? closeDate;
  final bool isDirty;
  final bool isDeleted;
  final DateTime? syncedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const BookProposal(
      {required this.id,
      required this.uuid,
      this.remoteId,
      required this.clubId,
      required this.clubUuid,
      required this.bookUuid,
      required this.proposedByUserId,
      this.proposedByRemoteId,
      this.title,
      this.author,
      this.isbn,
      this.coverUrl,
      this.closingDate,
      required this.totalChapters,
      required this.votes,
      required this.voteCount,
      required this.status,
      this.closeDate,
      required this.isDirty,
      required this.isDeleted,
      this.syncedAt,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    if (!nullToAbsent || remoteId != null) {
      map['remote_id'] = Variable<String>(remoteId);
    }
    map['club_id'] = Variable<int>(clubId);
    map['club_uuid'] = Variable<String>(clubUuid);
    map['book_uuid'] = Variable<String>(bookUuid);
    map['proposed_by_user_id'] = Variable<int>(proposedByUserId);
    if (!nullToAbsent || proposedByRemoteId != null) {
      map['proposed_by_remote_id'] = Variable<String>(proposedByRemoteId);
    }
    if (!nullToAbsent || title != null) {
      map['title'] = Variable<String>(title);
    }
    if (!nullToAbsent || author != null) {
      map['author'] = Variable<String>(author);
    }
    if (!nullToAbsent || isbn != null) {
      map['isbn'] = Variable<String>(isbn);
    }
    if (!nullToAbsent || coverUrl != null) {
      map['cover_url'] = Variable<String>(coverUrl);
    }
    if (!nullToAbsent || closingDate != null) {
      map['closing_date'] = Variable<DateTime>(closingDate);
    }
    map['total_chapters'] = Variable<int>(totalChapters);
    map['votes'] = Variable<String>(votes);
    map['vote_count'] = Variable<int>(voteCount);
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || closeDate != null) {
      map['close_date'] = Variable<DateTime>(closeDate);
    }
    map['is_dirty'] = Variable<bool>(isDirty);
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || syncedAt != null) {
      map['synced_at'] = Variable<DateTime>(syncedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  BookProposalsCompanion toCompanion(bool nullToAbsent) {
    return BookProposalsCompanion(
      id: Value(id),
      uuid: Value(uuid),
      remoteId: remoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(remoteId),
      clubId: Value(clubId),
      clubUuid: Value(clubUuid),
      bookUuid: Value(bookUuid),
      proposedByUserId: Value(proposedByUserId),
      proposedByRemoteId: proposedByRemoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(proposedByRemoteId),
      title:
          title == null && nullToAbsent ? const Value.absent() : Value(title),
      author:
          author == null && nullToAbsent ? const Value.absent() : Value(author),
      isbn: isbn == null && nullToAbsent ? const Value.absent() : Value(isbn),
      coverUrl: coverUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(coverUrl),
      closingDate: closingDate == null && nullToAbsent
          ? const Value.absent()
          : Value(closingDate),
      totalChapters: Value(totalChapters),
      votes: Value(votes),
      voteCount: Value(voteCount),
      status: Value(status),
      closeDate: closeDate == null && nullToAbsent
          ? const Value.absent()
          : Value(closeDate),
      isDirty: Value(isDirty),
      isDeleted: Value(isDeleted),
      syncedAt: syncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory BookProposal.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BookProposal(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      remoteId: serializer.fromJson<String?>(json['remoteId']),
      clubId: serializer.fromJson<int>(json['clubId']),
      clubUuid: serializer.fromJson<String>(json['clubUuid']),
      bookUuid: serializer.fromJson<String>(json['bookUuid']),
      proposedByUserId: serializer.fromJson<int>(json['proposedByUserId']),
      proposedByRemoteId:
          serializer.fromJson<String?>(json['proposedByRemoteId']),
      title: serializer.fromJson<String?>(json['title']),
      author: serializer.fromJson<String?>(json['author']),
      isbn: serializer.fromJson<String?>(json['isbn']),
      coverUrl: serializer.fromJson<String?>(json['coverUrl']),
      closingDate: serializer.fromJson<DateTime?>(json['closingDate']),
      totalChapters: serializer.fromJson<int>(json['totalChapters']),
      votes: serializer.fromJson<String>(json['votes']),
      voteCount: serializer.fromJson<int>(json['voteCount']),
      status: serializer.fromJson<String>(json['status']),
      closeDate: serializer.fromJson<DateTime?>(json['closeDate']),
      isDirty: serializer.fromJson<bool>(json['isDirty']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      syncedAt: serializer.fromJson<DateTime?>(json['syncedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'remoteId': serializer.toJson<String?>(remoteId),
      'clubId': serializer.toJson<int>(clubId),
      'clubUuid': serializer.toJson<String>(clubUuid),
      'bookUuid': serializer.toJson<String>(bookUuid),
      'proposedByUserId': serializer.toJson<int>(proposedByUserId),
      'proposedByRemoteId': serializer.toJson<String?>(proposedByRemoteId),
      'title': serializer.toJson<String?>(title),
      'author': serializer.toJson<String?>(author),
      'isbn': serializer.toJson<String?>(isbn),
      'coverUrl': serializer.toJson<String?>(coverUrl),
      'closingDate': serializer.toJson<DateTime?>(closingDate),
      'totalChapters': serializer.toJson<int>(totalChapters),
      'votes': serializer.toJson<String>(votes),
      'voteCount': serializer.toJson<int>(voteCount),
      'status': serializer.toJson<String>(status),
      'closeDate': serializer.toJson<DateTime?>(closeDate),
      'isDirty': serializer.toJson<bool>(isDirty),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'syncedAt': serializer.toJson<DateTime?>(syncedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  BookProposal copyWith(
          {int? id,
          String? uuid,
          Value<String?> remoteId = const Value.absent(),
          int? clubId,
          String? clubUuid,
          String? bookUuid,
          int? proposedByUserId,
          Value<String?> proposedByRemoteId = const Value.absent(),
          Value<String?> title = const Value.absent(),
          Value<String?> author = const Value.absent(),
          Value<String?> isbn = const Value.absent(),
          Value<String?> coverUrl = const Value.absent(),
          Value<DateTime?> closingDate = const Value.absent(),
          int? totalChapters,
          String? votes,
          int? voteCount,
          String? status,
          Value<DateTime?> closeDate = const Value.absent(),
          bool? isDirty,
          bool? isDeleted,
          Value<DateTime?> syncedAt = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      BookProposal(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        remoteId: remoteId.present ? remoteId.value : this.remoteId,
        clubId: clubId ?? this.clubId,
        clubUuid: clubUuid ?? this.clubUuid,
        bookUuid: bookUuid ?? this.bookUuid,
        proposedByUserId: proposedByUserId ?? this.proposedByUserId,
        proposedByRemoteId: proposedByRemoteId.present
            ? proposedByRemoteId.value
            : this.proposedByRemoteId,
        title: title.present ? title.value : this.title,
        author: author.present ? author.value : this.author,
        isbn: isbn.present ? isbn.value : this.isbn,
        coverUrl: coverUrl.present ? coverUrl.value : this.coverUrl,
        closingDate: closingDate.present ? closingDate.value : this.closingDate,
        totalChapters: totalChapters ?? this.totalChapters,
        votes: votes ?? this.votes,
        voteCount: voteCount ?? this.voteCount,
        status: status ?? this.status,
        closeDate: closeDate.present ? closeDate.value : this.closeDate,
        isDirty: isDirty ?? this.isDirty,
        isDeleted: isDeleted ?? this.isDeleted,
        syncedAt: syncedAt.present ? syncedAt.value : this.syncedAt,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  BookProposal copyWithCompanion(BookProposalsCompanion data) {
    return BookProposal(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      remoteId: data.remoteId.present ? data.remoteId.value : this.remoteId,
      clubId: data.clubId.present ? data.clubId.value : this.clubId,
      clubUuid: data.clubUuid.present ? data.clubUuid.value : this.clubUuid,
      bookUuid: data.bookUuid.present ? data.bookUuid.value : this.bookUuid,
      proposedByUserId: data.proposedByUserId.present
          ? data.proposedByUserId.value
          : this.proposedByUserId,
      proposedByRemoteId: data.proposedByRemoteId.present
          ? data.proposedByRemoteId.value
          : this.proposedByRemoteId,
      title: data.title.present ? data.title.value : this.title,
      author: data.author.present ? data.author.value : this.author,
      isbn: data.isbn.present ? data.isbn.value : this.isbn,
      coverUrl: data.coverUrl.present ? data.coverUrl.value : this.coverUrl,
      closingDate:
          data.closingDate.present ? data.closingDate.value : this.closingDate,
      totalChapters: data.totalChapters.present
          ? data.totalChapters.value
          : this.totalChapters,
      votes: data.votes.present ? data.votes.value : this.votes,
      voteCount: data.voteCount.present ? data.voteCount.value : this.voteCount,
      status: data.status.present ? data.status.value : this.status,
      closeDate: data.closeDate.present ? data.closeDate.value : this.closeDate,
      isDirty: data.isDirty.present ? data.isDirty.value : this.isDirty,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      syncedAt: data.syncedAt.present ? data.syncedAt.value : this.syncedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BookProposal(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('clubId: $clubId, ')
          ..write('clubUuid: $clubUuid, ')
          ..write('bookUuid: $bookUuid, ')
          ..write('proposedByUserId: $proposedByUserId, ')
          ..write('proposedByRemoteId: $proposedByRemoteId, ')
          ..write('title: $title, ')
          ..write('author: $author, ')
          ..write('isbn: $isbn, ')
          ..write('coverUrl: $coverUrl, ')
          ..write('closingDate: $closingDate, ')
          ..write('totalChapters: $totalChapters, ')
          ..write('votes: $votes, ')
          ..write('voteCount: $voteCount, ')
          ..write('status: $status, ')
          ..write('closeDate: $closeDate, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
        id,
        uuid,
        remoteId,
        clubId,
        clubUuid,
        bookUuid,
        proposedByUserId,
        proposedByRemoteId,
        title,
        author,
        isbn,
        coverUrl,
        closingDate,
        totalChapters,
        votes,
        voteCount,
        status,
        closeDate,
        isDirty,
        isDeleted,
        syncedAt,
        createdAt,
        updatedAt
      ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BookProposal &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.remoteId == this.remoteId &&
          other.clubId == this.clubId &&
          other.clubUuid == this.clubUuid &&
          other.bookUuid == this.bookUuid &&
          other.proposedByUserId == this.proposedByUserId &&
          other.proposedByRemoteId == this.proposedByRemoteId &&
          other.title == this.title &&
          other.author == this.author &&
          other.isbn == this.isbn &&
          other.coverUrl == this.coverUrl &&
          other.closingDate == this.closingDate &&
          other.totalChapters == this.totalChapters &&
          other.votes == this.votes &&
          other.voteCount == this.voteCount &&
          other.status == this.status &&
          other.closeDate == this.closeDate &&
          other.isDirty == this.isDirty &&
          other.isDeleted == this.isDeleted &&
          other.syncedAt == this.syncedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class BookProposalsCompanion extends UpdateCompanion<BookProposal> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String?> remoteId;
  final Value<int> clubId;
  final Value<String> clubUuid;
  final Value<String> bookUuid;
  final Value<int> proposedByUserId;
  final Value<String?> proposedByRemoteId;
  final Value<String?> title;
  final Value<String?> author;
  final Value<String?> isbn;
  final Value<String?> coverUrl;
  final Value<DateTime?> closingDate;
  final Value<int> totalChapters;
  final Value<String> votes;
  final Value<int> voteCount;
  final Value<String> status;
  final Value<DateTime?> closeDate;
  final Value<bool> isDirty;
  final Value<bool> isDeleted;
  final Value<DateTime?> syncedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const BookProposalsCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.remoteId = const Value.absent(),
    this.clubId = const Value.absent(),
    this.clubUuid = const Value.absent(),
    this.bookUuid = const Value.absent(),
    this.proposedByUserId = const Value.absent(),
    this.proposedByRemoteId = const Value.absent(),
    this.title = const Value.absent(),
    this.author = const Value.absent(),
    this.isbn = const Value.absent(),
    this.coverUrl = const Value.absent(),
    this.closingDate = const Value.absent(),
    this.totalChapters = const Value.absent(),
    this.votes = const Value.absent(),
    this.voteCount = const Value.absent(),
    this.status = const Value.absent(),
    this.closeDate = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  BookProposalsCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    this.remoteId = const Value.absent(),
    required int clubId,
    required String clubUuid,
    required String bookUuid,
    required int proposedByUserId,
    this.proposedByRemoteId = const Value.absent(),
    this.title = const Value.absent(),
    this.author = const Value.absent(),
    this.isbn = const Value.absent(),
    this.coverUrl = const Value.absent(),
    this.closingDate = const Value.absent(),
    required int totalChapters,
    this.votes = const Value.absent(),
    this.voteCount = const Value.absent(),
    this.status = const Value.absent(),
    this.closeDate = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        clubId = Value(clubId),
        clubUuid = Value(clubUuid),
        bookUuid = Value(bookUuid),
        proposedByUserId = Value(proposedByUserId),
        totalChapters = Value(totalChapters);
  static Insertable<BookProposal> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? remoteId,
    Expression<int>? clubId,
    Expression<String>? clubUuid,
    Expression<String>? bookUuid,
    Expression<int>? proposedByUserId,
    Expression<String>? proposedByRemoteId,
    Expression<String>? title,
    Expression<String>? author,
    Expression<String>? isbn,
    Expression<String>? coverUrl,
    Expression<DateTime>? closingDate,
    Expression<int>? totalChapters,
    Expression<String>? votes,
    Expression<int>? voteCount,
    Expression<String>? status,
    Expression<DateTime>? closeDate,
    Expression<bool>? isDirty,
    Expression<bool>? isDeleted,
    Expression<DateTime>? syncedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (remoteId != null) 'remote_id': remoteId,
      if (clubId != null) 'club_id': clubId,
      if (clubUuid != null) 'club_uuid': clubUuid,
      if (bookUuid != null) 'book_uuid': bookUuid,
      if (proposedByUserId != null) 'proposed_by_user_id': proposedByUserId,
      if (proposedByRemoteId != null)
        'proposed_by_remote_id': proposedByRemoteId,
      if (title != null) 'title': title,
      if (author != null) 'author': author,
      if (isbn != null) 'isbn': isbn,
      if (coverUrl != null) 'cover_url': coverUrl,
      if (closingDate != null) 'closing_date': closingDate,
      if (totalChapters != null) 'total_chapters': totalChapters,
      if (votes != null) 'votes': votes,
      if (voteCount != null) 'vote_count': voteCount,
      if (status != null) 'status': status,
      if (closeDate != null) 'close_date': closeDate,
      if (isDirty != null) 'is_dirty': isDirty,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (syncedAt != null) 'synced_at': syncedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  BookProposalsCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String?>? remoteId,
      Value<int>? clubId,
      Value<String>? clubUuid,
      Value<String>? bookUuid,
      Value<int>? proposedByUserId,
      Value<String?>? proposedByRemoteId,
      Value<String?>? title,
      Value<String?>? author,
      Value<String?>? isbn,
      Value<String?>? coverUrl,
      Value<DateTime?>? closingDate,
      Value<int>? totalChapters,
      Value<String>? votes,
      Value<int>? voteCount,
      Value<String>? status,
      Value<DateTime?>? closeDate,
      Value<bool>? isDirty,
      Value<bool>? isDeleted,
      Value<DateTime?>? syncedAt,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return BookProposalsCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      remoteId: remoteId ?? this.remoteId,
      clubId: clubId ?? this.clubId,
      clubUuid: clubUuid ?? this.clubUuid,
      bookUuid: bookUuid ?? this.bookUuid,
      proposedByUserId: proposedByUserId ?? this.proposedByUserId,
      proposedByRemoteId: proposedByRemoteId ?? this.proposedByRemoteId,
      title: title ?? this.title,
      author: author ?? this.author,
      isbn: isbn ?? this.isbn,
      coverUrl: coverUrl ?? this.coverUrl,
      closingDate: closingDate ?? this.closingDate,
      totalChapters: totalChapters ?? this.totalChapters,
      votes: votes ?? this.votes,
      voteCount: voteCount ?? this.voteCount,
      status: status ?? this.status,
      closeDate: closeDate ?? this.closeDate,
      isDirty: isDirty ?? this.isDirty,
      isDeleted: isDeleted ?? this.isDeleted,
      syncedAt: syncedAt ?? this.syncedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (remoteId.present) {
      map['remote_id'] = Variable<String>(remoteId.value);
    }
    if (clubId.present) {
      map['club_id'] = Variable<int>(clubId.value);
    }
    if (clubUuid.present) {
      map['club_uuid'] = Variable<String>(clubUuid.value);
    }
    if (bookUuid.present) {
      map['book_uuid'] = Variable<String>(bookUuid.value);
    }
    if (proposedByUserId.present) {
      map['proposed_by_user_id'] = Variable<int>(proposedByUserId.value);
    }
    if (proposedByRemoteId.present) {
      map['proposed_by_remote_id'] = Variable<String>(proposedByRemoteId.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (author.present) {
      map['author'] = Variable<String>(author.value);
    }
    if (isbn.present) {
      map['isbn'] = Variable<String>(isbn.value);
    }
    if (coverUrl.present) {
      map['cover_url'] = Variable<String>(coverUrl.value);
    }
    if (closingDate.present) {
      map['closing_date'] = Variable<DateTime>(closingDate.value);
    }
    if (totalChapters.present) {
      map['total_chapters'] = Variable<int>(totalChapters.value);
    }
    if (votes.present) {
      map['votes'] = Variable<String>(votes.value);
    }
    if (voteCount.present) {
      map['vote_count'] = Variable<int>(voteCount.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (closeDate.present) {
      map['close_date'] = Variable<DateTime>(closeDate.value);
    }
    if (isDirty.present) {
      map['is_dirty'] = Variable<bool>(isDirty.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (syncedAt.present) {
      map['synced_at'] = Variable<DateTime>(syncedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BookProposalsCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('clubId: $clubId, ')
          ..write('clubUuid: $clubUuid, ')
          ..write('bookUuid: $bookUuid, ')
          ..write('proposedByUserId: $proposedByUserId, ')
          ..write('proposedByRemoteId: $proposedByRemoteId, ')
          ..write('title: $title, ')
          ..write('author: $author, ')
          ..write('isbn: $isbn, ')
          ..write('coverUrl: $coverUrl, ')
          ..write('closingDate: $closingDate, ')
          ..write('totalChapters: $totalChapters, ')
          ..write('votes: $votes, ')
          ..write('voteCount: $voteCount, ')
          ..write('status: $status, ')
          ..write('closeDate: $closeDate, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $SectionCommentsTable extends SectionComments
    with TableInfo<$SectionCommentsTable, SectionComment> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SectionCommentsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _remoteIdMeta =
      const VerificationMeta('remoteId');
  @override
  late final GeneratedColumn<String> remoteId = GeneratedColumn<String>(
      'remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clubIdMeta = const VerificationMeta('clubId');
  @override
  late final GeneratedColumn<int> clubId = GeneratedColumn<int>(
      'club_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES reading_clubs (id) ON DELETE CASCADE'));
  static const VerificationMeta _clubUuidMeta =
      const VerificationMeta('clubUuid');
  @override
  late final GeneratedColumn<String> clubUuid = GeneratedColumn<String>(
      'club_uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _bookIdMeta = const VerificationMeta('bookId');
  @override
  late final GeneratedColumn<int> bookId = GeneratedColumn<int>(
      'book_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES club_books (id) ON DELETE CASCADE'));
  static const VerificationMeta _bookUuidMeta =
      const VerificationMeta('bookUuid');
  @override
  late final GeneratedColumn<String> bookUuid = GeneratedColumn<String>(
      'book_uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _sectionNumberMeta =
      const VerificationMeta('sectionNumber');
  @override
  late final GeneratedColumn<int> sectionNumber = GeneratedColumn<int>(
      'section_number', aliasedName, false,
      type: DriftSqlType.int, requiredDuringInsert: true);
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<int> userId = GeneratedColumn<int>(
      'user_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES local_users (id)'));
  static const VerificationMeta _userRemoteIdMeta =
      const VerificationMeta('userRemoteId');
  @override
  late final GeneratedColumn<String> userRemoteId = GeneratedColumn<String>(
      'user_remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _authorRemoteIdMeta =
      const VerificationMeta('authorRemoteId');
  @override
  late final GeneratedColumn<String> authorRemoteId = GeneratedColumn<String>(
      'author_remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _contentMeta =
      const VerificationMeta('content');
  @override
  late final GeneratedColumn<String> content = GeneratedColumn<String>(
      'content', aliasedName, false,
      type: DriftSqlType.string, requiredDuringInsert: true);
  static const VerificationMeta _reportsCountMeta =
      const VerificationMeta('reportsCount');
  @override
  late final GeneratedColumn<int> reportsCount = GeneratedColumn<int>(
      'reports_count', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultValue: const Constant(0));
  static const VerificationMeta _isHiddenMeta =
      const VerificationMeta('isHidden');
  @override
  late final GeneratedColumn<bool> isHidden = GeneratedColumn<bool>(
      'is_hidden', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_hidden" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _isDirtyMeta =
      const VerificationMeta('isDirty');
  @override
  late final GeneratedColumn<bool> isDirty = GeneratedColumn<bool>(
      'is_dirty', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_dirty" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _isDeletedMeta =
      const VerificationMeta('isDeleted');
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
      'is_deleted', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_deleted" IN (0, 1))'),
      defaultValue: const Constant(false));
  static const VerificationMeta _deletedAtMeta =
      const VerificationMeta('deletedAt');
  @override
  late final GeneratedColumn<DateTime> deletedAt = GeneratedColumn<DateTime>(
      'deleted_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _syncedAtMeta =
      const VerificationMeta('syncedAt');
  @override
  late final GeneratedColumn<DateTime> syncedAt = GeneratedColumn<DateTime>(
      'synced_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  static const VerificationMeta _updatedAtMeta =
      const VerificationMeta('updatedAt');
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
      'updated_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        remoteId,
        clubId,
        clubUuid,
        bookId,
        bookUuid,
        sectionNumber,
        userId,
        userRemoteId,
        authorRemoteId,
        content,
        reportsCount,
        isHidden,
        isDirty,
        isDeleted,
        deletedAt,
        syncedAt,
        createdAt,
        updatedAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'section_comments';
  @override
  VerificationContext validateIntegrity(Insertable<SectionComment> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('remote_id')) {
      context.handle(_remoteIdMeta,
          remoteId.isAcceptableOrUnknown(data['remote_id']!, _remoteIdMeta));
    }
    if (data.containsKey('club_id')) {
      context.handle(_clubIdMeta,
          clubId.isAcceptableOrUnknown(data['club_id']!, _clubIdMeta));
    } else if (isInserting) {
      context.missing(_clubIdMeta);
    }
    if (data.containsKey('club_uuid')) {
      context.handle(_clubUuidMeta,
          clubUuid.isAcceptableOrUnknown(data['club_uuid']!, _clubUuidMeta));
    } else if (isInserting) {
      context.missing(_clubUuidMeta);
    }
    if (data.containsKey('book_id')) {
      context.handle(_bookIdMeta,
          bookId.isAcceptableOrUnknown(data['book_id']!, _bookIdMeta));
    } else if (isInserting) {
      context.missing(_bookIdMeta);
    }
    if (data.containsKey('book_uuid')) {
      context.handle(_bookUuidMeta,
          bookUuid.isAcceptableOrUnknown(data['book_uuid']!, _bookUuidMeta));
    } else if (isInserting) {
      context.missing(_bookUuidMeta);
    }
    if (data.containsKey('section_number')) {
      context.handle(
          _sectionNumberMeta,
          sectionNumber.isAcceptableOrUnknown(
              data['section_number']!, _sectionNumberMeta));
    } else if (isInserting) {
      context.missing(_sectionNumberMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(_userIdMeta,
          userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta));
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('user_remote_id')) {
      context.handle(
          _userRemoteIdMeta,
          userRemoteId.isAcceptableOrUnknown(
              data['user_remote_id']!, _userRemoteIdMeta));
    }
    if (data.containsKey('author_remote_id')) {
      context.handle(
          _authorRemoteIdMeta,
          authorRemoteId.isAcceptableOrUnknown(
              data['author_remote_id']!, _authorRemoteIdMeta));
    }
    if (data.containsKey('content')) {
      context.handle(_contentMeta,
          content.isAcceptableOrUnknown(data['content']!, _contentMeta));
    } else if (isInserting) {
      context.missing(_contentMeta);
    }
    if (data.containsKey('reports_count')) {
      context.handle(
          _reportsCountMeta,
          reportsCount.isAcceptableOrUnknown(
              data['reports_count']!, _reportsCountMeta));
    }
    if (data.containsKey('is_hidden')) {
      context.handle(_isHiddenMeta,
          isHidden.isAcceptableOrUnknown(data['is_hidden']!, _isHiddenMeta));
    }
    if (data.containsKey('is_dirty')) {
      context.handle(_isDirtyMeta,
          isDirty.isAcceptableOrUnknown(data['is_dirty']!, _isDirtyMeta));
    }
    if (data.containsKey('is_deleted')) {
      context.handle(_isDeletedMeta,
          isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta));
    }
    if (data.containsKey('deleted_at')) {
      context.handle(_deletedAtMeta,
          deletedAt.isAcceptableOrUnknown(data['deleted_at']!, _deletedAtMeta));
    }
    if (data.containsKey('synced_at')) {
      context.handle(_syncedAtMeta,
          syncedAt.isAcceptableOrUnknown(data['synced_at']!, _syncedAtMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    if (data.containsKey('updated_at')) {
      context.handle(_updatedAtMeta,
          updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SectionComment map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SectionComment(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      remoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}remote_id']),
      clubId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}club_id'])!,
      clubUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}club_uuid'])!,
      bookId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}book_id'])!,
      bookUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}book_uuid'])!,
      sectionNumber: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}section_number'])!,
      userId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}user_id'])!,
      userRemoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}user_remote_id']),
      authorRemoteId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}author_remote_id']),
      content: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}content'])!,
      reportsCount: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}reports_count'])!,
      isHidden: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_hidden'])!,
      isDirty: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_dirty'])!,
      isDeleted: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_deleted'])!,
      deletedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}deleted_at']),
      syncedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}synced_at']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
      updatedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}updated_at'])!,
    );
  }

  @override
  $SectionCommentsTable createAlias(String alias) {
    return $SectionCommentsTable(attachedDatabase, alias);
  }
}

class SectionComment extends DataClass implements Insertable<SectionComment> {
  final int id;
  final String uuid;
  final String? remoteId;
  final int clubId;
  final String clubUuid;
  final int bookId;
  final String bookUuid;
  final int sectionNumber;
  final int userId;
  final String? userRemoteId;
  final String? authorRemoteId;
  final String content;
  final int reportsCount;
  final bool isHidden;
  final bool isDirty;
  final bool isDeleted;
  final DateTime? deletedAt;
  final DateTime? syncedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  const SectionComment(
      {required this.id,
      required this.uuid,
      this.remoteId,
      required this.clubId,
      required this.clubUuid,
      required this.bookId,
      required this.bookUuid,
      required this.sectionNumber,
      required this.userId,
      this.userRemoteId,
      this.authorRemoteId,
      required this.content,
      required this.reportsCount,
      required this.isHidden,
      required this.isDirty,
      required this.isDeleted,
      this.deletedAt,
      this.syncedAt,
      required this.createdAt,
      required this.updatedAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    if (!nullToAbsent || remoteId != null) {
      map['remote_id'] = Variable<String>(remoteId);
    }
    map['club_id'] = Variable<int>(clubId);
    map['club_uuid'] = Variable<String>(clubUuid);
    map['book_id'] = Variable<int>(bookId);
    map['book_uuid'] = Variable<String>(bookUuid);
    map['section_number'] = Variable<int>(sectionNumber);
    map['user_id'] = Variable<int>(userId);
    if (!nullToAbsent || userRemoteId != null) {
      map['user_remote_id'] = Variable<String>(userRemoteId);
    }
    if (!nullToAbsent || authorRemoteId != null) {
      map['author_remote_id'] = Variable<String>(authorRemoteId);
    }
    map['content'] = Variable<String>(content);
    map['reports_count'] = Variable<int>(reportsCount);
    map['is_hidden'] = Variable<bool>(isHidden);
    map['is_dirty'] = Variable<bool>(isDirty);
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || deletedAt != null) {
      map['deleted_at'] = Variable<DateTime>(deletedAt);
    }
    if (!nullToAbsent || syncedAt != null) {
      map['synced_at'] = Variable<DateTime>(syncedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  SectionCommentsCompanion toCompanion(bool nullToAbsent) {
    return SectionCommentsCompanion(
      id: Value(id),
      uuid: Value(uuid),
      remoteId: remoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(remoteId),
      clubId: Value(clubId),
      clubUuid: Value(clubUuid),
      bookId: Value(bookId),
      bookUuid: Value(bookUuid),
      sectionNumber: Value(sectionNumber),
      userId: Value(userId),
      userRemoteId: userRemoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(userRemoteId),
      authorRemoteId: authorRemoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(authorRemoteId),
      content: Value(content),
      reportsCount: Value(reportsCount),
      isHidden: Value(isHidden),
      isDirty: Value(isDirty),
      isDeleted: Value(isDeleted),
      deletedAt: deletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(deletedAt),
      syncedAt: syncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory SectionComment.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SectionComment(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      remoteId: serializer.fromJson<String?>(json['remoteId']),
      clubId: serializer.fromJson<int>(json['clubId']),
      clubUuid: serializer.fromJson<String>(json['clubUuid']),
      bookId: serializer.fromJson<int>(json['bookId']),
      bookUuid: serializer.fromJson<String>(json['bookUuid']),
      sectionNumber: serializer.fromJson<int>(json['sectionNumber']),
      userId: serializer.fromJson<int>(json['userId']),
      userRemoteId: serializer.fromJson<String?>(json['userRemoteId']),
      authorRemoteId: serializer.fromJson<String?>(json['authorRemoteId']),
      content: serializer.fromJson<String>(json['content']),
      reportsCount: serializer.fromJson<int>(json['reportsCount']),
      isHidden: serializer.fromJson<bool>(json['isHidden']),
      isDirty: serializer.fromJson<bool>(json['isDirty']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      deletedAt: serializer.fromJson<DateTime?>(json['deletedAt']),
      syncedAt: serializer.fromJson<DateTime?>(json['syncedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'remoteId': serializer.toJson<String?>(remoteId),
      'clubId': serializer.toJson<int>(clubId),
      'clubUuid': serializer.toJson<String>(clubUuid),
      'bookId': serializer.toJson<int>(bookId),
      'bookUuid': serializer.toJson<String>(bookUuid),
      'sectionNumber': serializer.toJson<int>(sectionNumber),
      'userId': serializer.toJson<int>(userId),
      'userRemoteId': serializer.toJson<String?>(userRemoteId),
      'authorRemoteId': serializer.toJson<String?>(authorRemoteId),
      'content': serializer.toJson<String>(content),
      'reportsCount': serializer.toJson<int>(reportsCount),
      'isHidden': serializer.toJson<bool>(isHidden),
      'isDirty': serializer.toJson<bool>(isDirty),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'deletedAt': serializer.toJson<DateTime?>(deletedAt),
      'syncedAt': serializer.toJson<DateTime?>(syncedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  SectionComment copyWith(
          {int? id,
          String? uuid,
          Value<String?> remoteId = const Value.absent(),
          int? clubId,
          String? clubUuid,
          int? bookId,
          String? bookUuid,
          int? sectionNumber,
          int? userId,
          Value<String?> userRemoteId = const Value.absent(),
          Value<String?> authorRemoteId = const Value.absent(),
          String? content,
          int? reportsCount,
          bool? isHidden,
          bool? isDirty,
          bool? isDeleted,
          Value<DateTime?> deletedAt = const Value.absent(),
          Value<DateTime?> syncedAt = const Value.absent(),
          DateTime? createdAt,
          DateTime? updatedAt}) =>
      SectionComment(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        remoteId: remoteId.present ? remoteId.value : this.remoteId,
        clubId: clubId ?? this.clubId,
        clubUuid: clubUuid ?? this.clubUuid,
        bookId: bookId ?? this.bookId,
        bookUuid: bookUuid ?? this.bookUuid,
        sectionNumber: sectionNumber ?? this.sectionNumber,
        userId: userId ?? this.userId,
        userRemoteId:
            userRemoteId.present ? userRemoteId.value : this.userRemoteId,
        authorRemoteId:
            authorRemoteId.present ? authorRemoteId.value : this.authorRemoteId,
        content: content ?? this.content,
        reportsCount: reportsCount ?? this.reportsCount,
        isHidden: isHidden ?? this.isHidden,
        isDirty: isDirty ?? this.isDirty,
        isDeleted: isDeleted ?? this.isDeleted,
        deletedAt: deletedAt.present ? deletedAt.value : this.deletedAt,
        syncedAt: syncedAt.present ? syncedAt.value : this.syncedAt,
        createdAt: createdAt ?? this.createdAt,
        updatedAt: updatedAt ?? this.updatedAt,
      );
  SectionComment copyWithCompanion(SectionCommentsCompanion data) {
    return SectionComment(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      remoteId: data.remoteId.present ? data.remoteId.value : this.remoteId,
      clubId: data.clubId.present ? data.clubId.value : this.clubId,
      clubUuid: data.clubUuid.present ? data.clubUuid.value : this.clubUuid,
      bookId: data.bookId.present ? data.bookId.value : this.bookId,
      bookUuid: data.bookUuid.present ? data.bookUuid.value : this.bookUuid,
      sectionNumber: data.sectionNumber.present
          ? data.sectionNumber.value
          : this.sectionNumber,
      userId: data.userId.present ? data.userId.value : this.userId,
      userRemoteId: data.userRemoteId.present
          ? data.userRemoteId.value
          : this.userRemoteId,
      authorRemoteId: data.authorRemoteId.present
          ? data.authorRemoteId.value
          : this.authorRemoteId,
      content: data.content.present ? data.content.value : this.content,
      reportsCount: data.reportsCount.present
          ? data.reportsCount.value
          : this.reportsCount,
      isHidden: data.isHidden.present ? data.isHidden.value : this.isHidden,
      isDirty: data.isDirty.present ? data.isDirty.value : this.isDirty,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      deletedAt: data.deletedAt.present ? data.deletedAt.value : this.deletedAt,
      syncedAt: data.syncedAt.present ? data.syncedAt.value : this.syncedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SectionComment(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('clubId: $clubId, ')
          ..write('clubUuid: $clubUuid, ')
          ..write('bookId: $bookId, ')
          ..write('bookUuid: $bookUuid, ')
          ..write('sectionNumber: $sectionNumber, ')
          ..write('userId: $userId, ')
          ..write('userRemoteId: $userRemoteId, ')
          ..write('authorRemoteId: $authorRemoteId, ')
          ..write('content: $content, ')
          ..write('reportsCount: $reportsCount, ')
          ..write('isHidden: $isHidden, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      remoteId,
      clubId,
      clubUuid,
      bookId,
      bookUuid,
      sectionNumber,
      userId,
      userRemoteId,
      authorRemoteId,
      content,
      reportsCount,
      isHidden,
      isDirty,
      isDeleted,
      deletedAt,
      syncedAt,
      createdAt,
      updatedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SectionComment &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.remoteId == this.remoteId &&
          other.clubId == this.clubId &&
          other.clubUuid == this.clubUuid &&
          other.bookId == this.bookId &&
          other.bookUuid == this.bookUuid &&
          other.sectionNumber == this.sectionNumber &&
          other.userId == this.userId &&
          other.userRemoteId == this.userRemoteId &&
          other.authorRemoteId == this.authorRemoteId &&
          other.content == this.content &&
          other.reportsCount == this.reportsCount &&
          other.isHidden == this.isHidden &&
          other.isDirty == this.isDirty &&
          other.isDeleted == this.isDeleted &&
          other.deletedAt == this.deletedAt &&
          other.syncedAt == this.syncedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class SectionCommentsCompanion extends UpdateCompanion<SectionComment> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String?> remoteId;
  final Value<int> clubId;
  final Value<String> clubUuid;
  final Value<int> bookId;
  final Value<String> bookUuid;
  final Value<int> sectionNumber;
  final Value<int> userId;
  final Value<String?> userRemoteId;
  final Value<String?> authorRemoteId;
  final Value<String> content;
  final Value<int> reportsCount;
  final Value<bool> isHidden;
  final Value<bool> isDirty;
  final Value<bool> isDeleted;
  final Value<DateTime?> deletedAt;
  final Value<DateTime?> syncedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  const SectionCommentsCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.remoteId = const Value.absent(),
    this.clubId = const Value.absent(),
    this.clubUuid = const Value.absent(),
    this.bookId = const Value.absent(),
    this.bookUuid = const Value.absent(),
    this.sectionNumber = const Value.absent(),
    this.userId = const Value.absent(),
    this.userRemoteId = const Value.absent(),
    this.authorRemoteId = const Value.absent(),
    this.content = const Value.absent(),
    this.reportsCount = const Value.absent(),
    this.isHidden = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  SectionCommentsCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    this.remoteId = const Value.absent(),
    required int clubId,
    required String clubUuid,
    required int bookId,
    required String bookUuid,
    required int sectionNumber,
    required int userId,
    this.userRemoteId = const Value.absent(),
    this.authorRemoteId = const Value.absent(),
    required String content,
    this.reportsCount = const Value.absent(),
    this.isHidden = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.deletedAt = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  })  : uuid = Value(uuid),
        clubId = Value(clubId),
        clubUuid = Value(clubUuid),
        bookId = Value(bookId),
        bookUuid = Value(bookUuid),
        sectionNumber = Value(sectionNumber),
        userId = Value(userId),
        content = Value(content);
  static Insertable<SectionComment> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? remoteId,
    Expression<int>? clubId,
    Expression<String>? clubUuid,
    Expression<int>? bookId,
    Expression<String>? bookUuid,
    Expression<int>? sectionNumber,
    Expression<int>? userId,
    Expression<String>? userRemoteId,
    Expression<String>? authorRemoteId,
    Expression<String>? content,
    Expression<int>? reportsCount,
    Expression<bool>? isHidden,
    Expression<bool>? isDirty,
    Expression<bool>? isDeleted,
    Expression<DateTime>? deletedAt,
    Expression<DateTime>? syncedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (remoteId != null) 'remote_id': remoteId,
      if (clubId != null) 'club_id': clubId,
      if (clubUuid != null) 'club_uuid': clubUuid,
      if (bookId != null) 'book_id': bookId,
      if (bookUuid != null) 'book_uuid': bookUuid,
      if (sectionNumber != null) 'section_number': sectionNumber,
      if (userId != null) 'user_id': userId,
      if (userRemoteId != null) 'user_remote_id': userRemoteId,
      if (authorRemoteId != null) 'author_remote_id': authorRemoteId,
      if (content != null) 'content': content,
      if (reportsCount != null) 'reports_count': reportsCount,
      if (isHidden != null) 'is_hidden': isHidden,
      if (isDirty != null) 'is_dirty': isDirty,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (deletedAt != null) 'deleted_at': deletedAt,
      if (syncedAt != null) 'synced_at': syncedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  SectionCommentsCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String?>? remoteId,
      Value<int>? clubId,
      Value<String>? clubUuid,
      Value<int>? bookId,
      Value<String>? bookUuid,
      Value<int>? sectionNumber,
      Value<int>? userId,
      Value<String?>? userRemoteId,
      Value<String?>? authorRemoteId,
      Value<String>? content,
      Value<int>? reportsCount,
      Value<bool>? isHidden,
      Value<bool>? isDirty,
      Value<bool>? isDeleted,
      Value<DateTime?>? deletedAt,
      Value<DateTime?>? syncedAt,
      Value<DateTime>? createdAt,
      Value<DateTime>? updatedAt}) {
    return SectionCommentsCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      remoteId: remoteId ?? this.remoteId,
      clubId: clubId ?? this.clubId,
      clubUuid: clubUuid ?? this.clubUuid,
      bookId: bookId ?? this.bookId,
      bookUuid: bookUuid ?? this.bookUuid,
      sectionNumber: sectionNumber ?? this.sectionNumber,
      userId: userId ?? this.userId,
      userRemoteId: userRemoteId ?? this.userRemoteId,
      authorRemoteId: authorRemoteId ?? this.authorRemoteId,
      content: content ?? this.content,
      reportsCount: reportsCount ?? this.reportsCount,
      isHidden: isHidden ?? this.isHidden,
      isDirty: isDirty ?? this.isDirty,
      isDeleted: isDeleted ?? this.isDeleted,
      deletedAt: deletedAt ?? this.deletedAt,
      syncedAt: syncedAt ?? this.syncedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (remoteId.present) {
      map['remote_id'] = Variable<String>(remoteId.value);
    }
    if (clubId.present) {
      map['club_id'] = Variable<int>(clubId.value);
    }
    if (clubUuid.present) {
      map['club_uuid'] = Variable<String>(clubUuid.value);
    }
    if (bookId.present) {
      map['book_id'] = Variable<int>(bookId.value);
    }
    if (bookUuid.present) {
      map['book_uuid'] = Variable<String>(bookUuid.value);
    }
    if (sectionNumber.present) {
      map['section_number'] = Variable<int>(sectionNumber.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<int>(userId.value);
    }
    if (userRemoteId.present) {
      map['user_remote_id'] = Variable<String>(userRemoteId.value);
    }
    if (authorRemoteId.present) {
      map['author_remote_id'] = Variable<String>(authorRemoteId.value);
    }
    if (content.present) {
      map['content'] = Variable<String>(content.value);
    }
    if (reportsCount.present) {
      map['reports_count'] = Variable<int>(reportsCount.value);
    }
    if (isHidden.present) {
      map['is_hidden'] = Variable<bool>(isHidden.value);
    }
    if (isDirty.present) {
      map['is_dirty'] = Variable<bool>(isDirty.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (deletedAt.present) {
      map['deleted_at'] = Variable<DateTime>(deletedAt.value);
    }
    if (syncedAt.present) {
      map['synced_at'] = Variable<DateTime>(syncedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SectionCommentsCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('clubId: $clubId, ')
          ..write('clubUuid: $clubUuid, ')
          ..write('bookId: $bookId, ')
          ..write('bookUuid: $bookUuid, ')
          ..write('sectionNumber: $sectionNumber, ')
          ..write('userId: $userId, ')
          ..write('userRemoteId: $userRemoteId, ')
          ..write('authorRemoteId: $authorRemoteId, ')
          ..write('content: $content, ')
          ..write('reportsCount: $reportsCount, ')
          ..write('isHidden: $isHidden, ')
          ..write('isDirty: $isDirty, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('deletedAt: $deletedAt, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $CommentReportsTable extends CommentReports
    with TableInfo<$CommentReportsTable, CommentReport> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CommentReportsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _remoteIdMeta =
      const VerificationMeta('remoteId');
  @override
  late final GeneratedColumn<String> remoteId = GeneratedColumn<String>(
      'remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _commentIdMeta =
      const VerificationMeta('commentId');
  @override
  late final GeneratedColumn<int> commentId = GeneratedColumn<int>(
      'comment_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES section_comments (id) ON DELETE CASCADE'));
  static const VerificationMeta _commentUuidMeta =
      const VerificationMeta('commentUuid');
  @override
  late final GeneratedColumn<String> commentUuid = GeneratedColumn<String>(
      'comment_uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _reportedByUserIdMeta =
      const VerificationMeta('reportedByUserId');
  @override
  late final GeneratedColumn<int> reportedByUserId = GeneratedColumn<int>(
      'reported_by_user_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES local_users (id)'));
  static const VerificationMeta _reportedByRemoteIdMeta =
      const VerificationMeta('reportedByRemoteId');
  @override
  late final GeneratedColumn<String> reportedByRemoteId =
      GeneratedColumn<String>('reported_by_remote_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _reasonMeta = const VerificationMeta('reason');
  @override
  late final GeneratedColumn<String> reason = GeneratedColumn<String>(
      'reason', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDirtyMeta =
      const VerificationMeta('isDirty');
  @override
  late final GeneratedColumn<bool> isDirty = GeneratedColumn<bool>(
      'is_dirty', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_dirty" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _syncedAtMeta =
      const VerificationMeta('syncedAt');
  @override
  late final GeneratedColumn<DateTime> syncedAt = GeneratedColumn<DateTime>(
      'synced_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        remoteId,
        commentId,
        commentUuid,
        reportedByUserId,
        reportedByRemoteId,
        reason,
        isDirty,
        syncedAt,
        createdAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'comment_reports';
  @override
  VerificationContext validateIntegrity(Insertable<CommentReport> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('remote_id')) {
      context.handle(_remoteIdMeta,
          remoteId.isAcceptableOrUnknown(data['remote_id']!, _remoteIdMeta));
    }
    if (data.containsKey('comment_id')) {
      context.handle(_commentIdMeta,
          commentId.isAcceptableOrUnknown(data['comment_id']!, _commentIdMeta));
    } else if (isInserting) {
      context.missing(_commentIdMeta);
    }
    if (data.containsKey('comment_uuid')) {
      context.handle(
          _commentUuidMeta,
          commentUuid.isAcceptableOrUnknown(
              data['comment_uuid']!, _commentUuidMeta));
    } else if (isInserting) {
      context.missing(_commentUuidMeta);
    }
    if (data.containsKey('reported_by_user_id')) {
      context.handle(
          _reportedByUserIdMeta,
          reportedByUserId.isAcceptableOrUnknown(
              data['reported_by_user_id']!, _reportedByUserIdMeta));
    } else if (isInserting) {
      context.missing(_reportedByUserIdMeta);
    }
    if (data.containsKey('reported_by_remote_id')) {
      context.handle(
          _reportedByRemoteIdMeta,
          reportedByRemoteId.isAcceptableOrUnknown(
              data['reported_by_remote_id']!, _reportedByRemoteIdMeta));
    }
    if (data.containsKey('reason')) {
      context.handle(_reasonMeta,
          reason.isAcceptableOrUnknown(data['reason']!, _reasonMeta));
    }
    if (data.containsKey('is_dirty')) {
      context.handle(_isDirtyMeta,
          isDirty.isAcceptableOrUnknown(data['is_dirty']!, _isDirtyMeta));
    }
    if (data.containsKey('synced_at')) {
      context.handle(_syncedAtMeta,
          syncedAt.isAcceptableOrUnknown(data['synced_at']!, _syncedAtMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  List<Set<GeneratedColumn>> get uniqueKeys => [
        {commentId, reportedByUserId},
      ];
  @override
  CommentReport map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CommentReport(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      remoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}remote_id']),
      commentId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}comment_id'])!,
      commentUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}comment_uuid'])!,
      reportedByUserId: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}reported_by_user_id'])!,
      reportedByRemoteId: attachedDatabase.typeMapping.read(
          DriftSqlType.string, data['${effectivePrefix}reported_by_remote_id']),
      reason: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reason']),
      isDirty: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_dirty'])!,
      syncedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}synced_at']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
    );
  }

  @override
  $CommentReportsTable createAlias(String alias) {
    return $CommentReportsTable(attachedDatabase, alias);
  }
}

class CommentReport extends DataClass implements Insertable<CommentReport> {
  final int id;
  final String uuid;
  final String? remoteId;
  final int commentId;
  final String commentUuid;
  final int reportedByUserId;
  final String? reportedByRemoteId;
  final String? reason;
  final bool isDirty;
  final DateTime? syncedAt;
  final DateTime createdAt;
  const CommentReport(
      {required this.id,
      required this.uuid,
      this.remoteId,
      required this.commentId,
      required this.commentUuid,
      required this.reportedByUserId,
      this.reportedByRemoteId,
      this.reason,
      required this.isDirty,
      this.syncedAt,
      required this.createdAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    if (!nullToAbsent || remoteId != null) {
      map['remote_id'] = Variable<String>(remoteId);
    }
    map['comment_id'] = Variable<int>(commentId);
    map['comment_uuid'] = Variable<String>(commentUuid);
    map['reported_by_user_id'] = Variable<int>(reportedByUserId);
    if (!nullToAbsent || reportedByRemoteId != null) {
      map['reported_by_remote_id'] = Variable<String>(reportedByRemoteId);
    }
    if (!nullToAbsent || reason != null) {
      map['reason'] = Variable<String>(reason);
    }
    map['is_dirty'] = Variable<bool>(isDirty);
    if (!nullToAbsent || syncedAt != null) {
      map['synced_at'] = Variable<DateTime>(syncedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  CommentReportsCompanion toCompanion(bool nullToAbsent) {
    return CommentReportsCompanion(
      id: Value(id),
      uuid: Value(uuid),
      remoteId: remoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(remoteId),
      commentId: Value(commentId),
      commentUuid: Value(commentUuid),
      reportedByUserId: Value(reportedByUserId),
      reportedByRemoteId: reportedByRemoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(reportedByRemoteId),
      reason:
          reason == null && nullToAbsent ? const Value.absent() : Value(reason),
      isDirty: Value(isDirty),
      syncedAt: syncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncedAt),
      createdAt: Value(createdAt),
    );
  }

  factory CommentReport.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CommentReport(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      remoteId: serializer.fromJson<String?>(json['remoteId']),
      commentId: serializer.fromJson<int>(json['commentId']),
      commentUuid: serializer.fromJson<String>(json['commentUuid']),
      reportedByUserId: serializer.fromJson<int>(json['reportedByUserId']),
      reportedByRemoteId:
          serializer.fromJson<String?>(json['reportedByRemoteId']),
      reason: serializer.fromJson<String?>(json['reason']),
      isDirty: serializer.fromJson<bool>(json['isDirty']),
      syncedAt: serializer.fromJson<DateTime?>(json['syncedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'remoteId': serializer.toJson<String?>(remoteId),
      'commentId': serializer.toJson<int>(commentId),
      'commentUuid': serializer.toJson<String>(commentUuid),
      'reportedByUserId': serializer.toJson<int>(reportedByUserId),
      'reportedByRemoteId': serializer.toJson<String?>(reportedByRemoteId),
      'reason': serializer.toJson<String?>(reason),
      'isDirty': serializer.toJson<bool>(isDirty),
      'syncedAt': serializer.toJson<DateTime?>(syncedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  CommentReport copyWith(
          {int? id,
          String? uuid,
          Value<String?> remoteId = const Value.absent(),
          int? commentId,
          String? commentUuid,
          int? reportedByUserId,
          Value<String?> reportedByRemoteId = const Value.absent(),
          Value<String?> reason = const Value.absent(),
          bool? isDirty,
          Value<DateTime?> syncedAt = const Value.absent(),
          DateTime? createdAt}) =>
      CommentReport(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        remoteId: remoteId.present ? remoteId.value : this.remoteId,
        commentId: commentId ?? this.commentId,
        commentUuid: commentUuid ?? this.commentUuid,
        reportedByUserId: reportedByUserId ?? this.reportedByUserId,
        reportedByRemoteId: reportedByRemoteId.present
            ? reportedByRemoteId.value
            : this.reportedByRemoteId,
        reason: reason.present ? reason.value : this.reason,
        isDirty: isDirty ?? this.isDirty,
        syncedAt: syncedAt.present ? syncedAt.value : this.syncedAt,
        createdAt: createdAt ?? this.createdAt,
      );
  CommentReport copyWithCompanion(CommentReportsCompanion data) {
    return CommentReport(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      remoteId: data.remoteId.present ? data.remoteId.value : this.remoteId,
      commentId: data.commentId.present ? data.commentId.value : this.commentId,
      commentUuid:
          data.commentUuid.present ? data.commentUuid.value : this.commentUuid,
      reportedByUserId: data.reportedByUserId.present
          ? data.reportedByUserId.value
          : this.reportedByUserId,
      reportedByRemoteId: data.reportedByRemoteId.present
          ? data.reportedByRemoteId.value
          : this.reportedByRemoteId,
      reason: data.reason.present ? data.reason.value : this.reason,
      isDirty: data.isDirty.present ? data.isDirty.value : this.isDirty,
      syncedAt: data.syncedAt.present ? data.syncedAt.value : this.syncedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CommentReport(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('commentId: $commentId, ')
          ..write('commentUuid: $commentUuid, ')
          ..write('reportedByUserId: $reportedByUserId, ')
          ..write('reportedByRemoteId: $reportedByRemoteId, ')
          ..write('reason: $reason, ')
          ..write('isDirty: $isDirty, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      remoteId,
      commentId,
      commentUuid,
      reportedByUserId,
      reportedByRemoteId,
      reason,
      isDirty,
      syncedAt,
      createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CommentReport &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.remoteId == this.remoteId &&
          other.commentId == this.commentId &&
          other.commentUuid == this.commentUuid &&
          other.reportedByUserId == this.reportedByUserId &&
          other.reportedByRemoteId == this.reportedByRemoteId &&
          other.reason == this.reason &&
          other.isDirty == this.isDirty &&
          other.syncedAt == this.syncedAt &&
          other.createdAt == this.createdAt);
}

class CommentReportsCompanion extends UpdateCompanion<CommentReport> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String?> remoteId;
  final Value<int> commentId;
  final Value<String> commentUuid;
  final Value<int> reportedByUserId;
  final Value<String?> reportedByRemoteId;
  final Value<String?> reason;
  final Value<bool> isDirty;
  final Value<DateTime?> syncedAt;
  final Value<DateTime> createdAt;
  const CommentReportsCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.remoteId = const Value.absent(),
    this.commentId = const Value.absent(),
    this.commentUuid = const Value.absent(),
    this.reportedByUserId = const Value.absent(),
    this.reportedByRemoteId = const Value.absent(),
    this.reason = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
  });
  CommentReportsCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    this.remoteId = const Value.absent(),
    required int commentId,
    required String commentUuid,
    required int reportedByUserId,
    this.reportedByRemoteId = const Value.absent(),
    this.reason = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
  })  : uuid = Value(uuid),
        commentId = Value(commentId),
        commentUuid = Value(commentUuid),
        reportedByUserId = Value(reportedByUserId);
  static Insertable<CommentReport> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? remoteId,
    Expression<int>? commentId,
    Expression<String>? commentUuid,
    Expression<int>? reportedByUserId,
    Expression<String>? reportedByRemoteId,
    Expression<String>? reason,
    Expression<bool>? isDirty,
    Expression<DateTime>? syncedAt,
    Expression<DateTime>? createdAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (remoteId != null) 'remote_id': remoteId,
      if (commentId != null) 'comment_id': commentId,
      if (commentUuid != null) 'comment_uuid': commentUuid,
      if (reportedByUserId != null) 'reported_by_user_id': reportedByUserId,
      if (reportedByRemoteId != null)
        'reported_by_remote_id': reportedByRemoteId,
      if (reason != null) 'reason': reason,
      if (isDirty != null) 'is_dirty': isDirty,
      if (syncedAt != null) 'synced_at': syncedAt,
      if (createdAt != null) 'created_at': createdAt,
    });
  }

  CommentReportsCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String?>? remoteId,
      Value<int>? commentId,
      Value<String>? commentUuid,
      Value<int>? reportedByUserId,
      Value<String?>? reportedByRemoteId,
      Value<String?>? reason,
      Value<bool>? isDirty,
      Value<DateTime?>? syncedAt,
      Value<DateTime>? createdAt}) {
    return CommentReportsCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      remoteId: remoteId ?? this.remoteId,
      commentId: commentId ?? this.commentId,
      commentUuid: commentUuid ?? this.commentUuid,
      reportedByUserId: reportedByUserId ?? this.reportedByUserId,
      reportedByRemoteId: reportedByRemoteId ?? this.reportedByRemoteId,
      reason: reason ?? this.reason,
      isDirty: isDirty ?? this.isDirty,
      syncedAt: syncedAt ?? this.syncedAt,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (remoteId.present) {
      map['remote_id'] = Variable<String>(remoteId.value);
    }
    if (commentId.present) {
      map['comment_id'] = Variable<int>(commentId.value);
    }
    if (commentUuid.present) {
      map['comment_uuid'] = Variable<String>(commentUuid.value);
    }
    if (reportedByUserId.present) {
      map['reported_by_user_id'] = Variable<int>(reportedByUserId.value);
    }
    if (reportedByRemoteId.present) {
      map['reported_by_remote_id'] = Variable<String>(reportedByRemoteId.value);
    }
    if (reason.present) {
      map['reason'] = Variable<String>(reason.value);
    }
    if (isDirty.present) {
      map['is_dirty'] = Variable<bool>(isDirty.value);
    }
    if (syncedAt.present) {
      map['synced_at'] = Variable<DateTime>(syncedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CommentReportsCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('commentId: $commentId, ')
          ..write('commentUuid: $commentUuid, ')
          ..write('reportedByUserId: $reportedByUserId, ')
          ..write('reportedByRemoteId: $reportedByRemoteId, ')
          ..write('reason: $reason, ')
          ..write('isDirty: $isDirty, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }
}

class $ModerationLogsTable extends ModerationLogs
    with TableInfo<$ModerationLogsTable, ModerationLog> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ModerationLogsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
      'id', aliasedName, false,
      hasAutoIncrement: true,
      type: DriftSqlType.int,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('PRIMARY KEY AUTOINCREMENT'));
  static const VerificationMeta _uuidMeta = const VerificationMeta('uuid');
  @override
  late final GeneratedColumn<String> uuid = GeneratedColumn<String>(
      'uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'));
  static const VerificationMeta _remoteIdMeta =
      const VerificationMeta('remoteId');
  @override
  late final GeneratedColumn<String> remoteId = GeneratedColumn<String>(
      'remote_id', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _clubIdMeta = const VerificationMeta('clubId');
  @override
  late final GeneratedColumn<int> clubId = GeneratedColumn<int>(
      'club_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES reading_clubs (id) ON DELETE CASCADE'));
  static const VerificationMeta _clubUuidMeta =
      const VerificationMeta('clubUuid');
  @override
  late final GeneratedColumn<String> clubUuid = GeneratedColumn<String>(
      'club_uuid', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _actionMeta = const VerificationMeta('action');
  @override
  late final GeneratedColumn<String> action = GeneratedColumn<String>(
      'action', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 64),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _performedByUserIdMeta =
      const VerificationMeta('performedByUserId');
  @override
  late final GeneratedColumn<int> performedByUserId = GeneratedColumn<int>(
      'performed_by_user_id', aliasedName, false,
      type: DriftSqlType.int,
      requiredDuringInsert: true,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('REFERENCES local_users (id)'));
  static const VerificationMeta _performedByRemoteIdMeta =
      const VerificationMeta('performedByRemoteId');
  @override
  late final GeneratedColumn<String> performedByRemoteId =
      GeneratedColumn<String>('performed_by_remote_id', aliasedName, true,
          type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _targetIdMeta =
      const VerificationMeta('targetId');
  @override
  late final GeneratedColumn<String> targetId = GeneratedColumn<String>(
      'target_id', aliasedName, false,
      additionalChecks:
          GeneratedColumn.checkTextLength(minTextLength: 1, maxTextLength: 36),
      type: DriftSqlType.string,
      requiredDuringInsert: true);
  static const VerificationMeta _reasonMeta = const VerificationMeta('reason');
  @override
  late final GeneratedColumn<String> reason = GeneratedColumn<String>(
      'reason', aliasedName, true,
      type: DriftSqlType.string, requiredDuringInsert: false);
  static const VerificationMeta _isDirtyMeta =
      const VerificationMeta('isDirty');
  @override
  late final GeneratedColumn<bool> isDirty = GeneratedColumn<bool>(
      'is_dirty', aliasedName, false,
      type: DriftSqlType.bool,
      requiredDuringInsert: false,
      defaultConstraints:
          GeneratedColumn.constraintIsAlways('CHECK ("is_dirty" IN (0, 1))'),
      defaultValue: const Constant(true));
  static const VerificationMeta _syncedAtMeta =
      const VerificationMeta('syncedAt');
  @override
  late final GeneratedColumn<DateTime> syncedAt = GeneratedColumn<DateTime>(
      'synced_at', aliasedName, true,
      type: DriftSqlType.dateTime, requiredDuringInsert: false);
  static const VerificationMeta _createdAtMeta =
      const VerificationMeta('createdAt');
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
      'created_at', aliasedName, false,
      type: DriftSqlType.dateTime,
      requiredDuringInsert: false,
      defaultValue: currentDateAndTime);
  @override
  List<GeneratedColumn> get $columns => [
        id,
        uuid,
        remoteId,
        clubId,
        clubUuid,
        action,
        performedByUserId,
        performedByRemoteId,
        targetId,
        reason,
        isDirty,
        syncedAt,
        createdAt
      ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'moderation_logs';
  @override
  VerificationContext validateIntegrity(Insertable<ModerationLog> instance,
      {bool isInserting = false}) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('uuid')) {
      context.handle(
          _uuidMeta, uuid.isAcceptableOrUnknown(data['uuid']!, _uuidMeta));
    } else if (isInserting) {
      context.missing(_uuidMeta);
    }
    if (data.containsKey('remote_id')) {
      context.handle(_remoteIdMeta,
          remoteId.isAcceptableOrUnknown(data['remote_id']!, _remoteIdMeta));
    }
    if (data.containsKey('club_id')) {
      context.handle(_clubIdMeta,
          clubId.isAcceptableOrUnknown(data['club_id']!, _clubIdMeta));
    } else if (isInserting) {
      context.missing(_clubIdMeta);
    }
    if (data.containsKey('club_uuid')) {
      context.handle(_clubUuidMeta,
          clubUuid.isAcceptableOrUnknown(data['club_uuid']!, _clubUuidMeta));
    } else if (isInserting) {
      context.missing(_clubUuidMeta);
    }
    if (data.containsKey('action')) {
      context.handle(_actionMeta,
          action.isAcceptableOrUnknown(data['action']!, _actionMeta));
    } else if (isInserting) {
      context.missing(_actionMeta);
    }
    if (data.containsKey('performed_by_user_id')) {
      context.handle(
          _performedByUserIdMeta,
          performedByUserId.isAcceptableOrUnknown(
              data['performed_by_user_id']!, _performedByUserIdMeta));
    } else if (isInserting) {
      context.missing(_performedByUserIdMeta);
    }
    if (data.containsKey('performed_by_remote_id')) {
      context.handle(
          _performedByRemoteIdMeta,
          performedByRemoteId.isAcceptableOrUnknown(
              data['performed_by_remote_id']!, _performedByRemoteIdMeta));
    }
    if (data.containsKey('target_id')) {
      context.handle(_targetIdMeta,
          targetId.isAcceptableOrUnknown(data['target_id']!, _targetIdMeta));
    } else if (isInserting) {
      context.missing(_targetIdMeta);
    }
    if (data.containsKey('reason')) {
      context.handle(_reasonMeta,
          reason.isAcceptableOrUnknown(data['reason']!, _reasonMeta));
    }
    if (data.containsKey('is_dirty')) {
      context.handle(_isDirtyMeta,
          isDirty.isAcceptableOrUnknown(data['is_dirty']!, _isDirtyMeta));
    }
    if (data.containsKey('synced_at')) {
      context.handle(_syncedAtMeta,
          syncedAt.isAcceptableOrUnknown(data['synced_at']!, _syncedAtMeta));
    }
    if (data.containsKey('created_at')) {
      context.handle(_createdAtMeta,
          createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta));
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ModerationLog map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ModerationLog(
      id: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}id'])!,
      uuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}uuid'])!,
      remoteId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}remote_id']),
      clubId: attachedDatabase.typeMapping
          .read(DriftSqlType.int, data['${effectivePrefix}club_id'])!,
      clubUuid: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}club_uuid'])!,
      action: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}action'])!,
      performedByUserId: attachedDatabase.typeMapping.read(
          DriftSqlType.int, data['${effectivePrefix}performed_by_user_id'])!,
      performedByRemoteId: attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}performed_by_remote_id']),
      targetId: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}target_id'])!,
      reason: attachedDatabase.typeMapping
          .read(DriftSqlType.string, data['${effectivePrefix}reason']),
      isDirty: attachedDatabase.typeMapping
          .read(DriftSqlType.bool, data['${effectivePrefix}is_dirty'])!,
      syncedAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}synced_at']),
      createdAt: attachedDatabase.typeMapping
          .read(DriftSqlType.dateTime, data['${effectivePrefix}created_at'])!,
    );
  }

  @override
  $ModerationLogsTable createAlias(String alias) {
    return $ModerationLogsTable(attachedDatabase, alias);
  }
}

class ModerationLog extends DataClass implements Insertable<ModerationLog> {
  final int id;
  final String uuid;
  final String? remoteId;
  final int clubId;
  final String clubUuid;
  final String action;
  final int performedByUserId;
  final String? performedByRemoteId;
  final String targetId;
  final String? reason;
  final bool isDirty;
  final DateTime? syncedAt;
  final DateTime createdAt;
  const ModerationLog(
      {required this.id,
      required this.uuid,
      this.remoteId,
      required this.clubId,
      required this.clubUuid,
      required this.action,
      required this.performedByUserId,
      this.performedByRemoteId,
      required this.targetId,
      this.reason,
      required this.isDirty,
      this.syncedAt,
      required this.createdAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['uuid'] = Variable<String>(uuid);
    if (!nullToAbsent || remoteId != null) {
      map['remote_id'] = Variable<String>(remoteId);
    }
    map['club_id'] = Variable<int>(clubId);
    map['club_uuid'] = Variable<String>(clubUuid);
    map['action'] = Variable<String>(action);
    map['performed_by_user_id'] = Variable<int>(performedByUserId);
    if (!nullToAbsent || performedByRemoteId != null) {
      map['performed_by_remote_id'] = Variable<String>(performedByRemoteId);
    }
    map['target_id'] = Variable<String>(targetId);
    if (!nullToAbsent || reason != null) {
      map['reason'] = Variable<String>(reason);
    }
    map['is_dirty'] = Variable<bool>(isDirty);
    if (!nullToAbsent || syncedAt != null) {
      map['synced_at'] = Variable<DateTime>(syncedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  ModerationLogsCompanion toCompanion(bool nullToAbsent) {
    return ModerationLogsCompanion(
      id: Value(id),
      uuid: Value(uuid),
      remoteId: remoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(remoteId),
      clubId: Value(clubId),
      clubUuid: Value(clubUuid),
      action: Value(action),
      performedByUserId: Value(performedByUserId),
      performedByRemoteId: performedByRemoteId == null && nullToAbsent
          ? const Value.absent()
          : Value(performedByRemoteId),
      targetId: Value(targetId),
      reason:
          reason == null && nullToAbsent ? const Value.absent() : Value(reason),
      isDirty: Value(isDirty),
      syncedAt: syncedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncedAt),
      createdAt: Value(createdAt),
    );
  }

  factory ModerationLog.fromJson(Map<String, dynamic> json,
      {ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ModerationLog(
      id: serializer.fromJson<int>(json['id']),
      uuid: serializer.fromJson<String>(json['uuid']),
      remoteId: serializer.fromJson<String?>(json['remoteId']),
      clubId: serializer.fromJson<int>(json['clubId']),
      clubUuid: serializer.fromJson<String>(json['clubUuid']),
      action: serializer.fromJson<String>(json['action']),
      performedByUserId: serializer.fromJson<int>(json['performedByUserId']),
      performedByRemoteId:
          serializer.fromJson<String?>(json['performedByRemoteId']),
      targetId: serializer.fromJson<String>(json['targetId']),
      reason: serializer.fromJson<String?>(json['reason']),
      isDirty: serializer.fromJson<bool>(json['isDirty']),
      syncedAt: serializer.fromJson<DateTime?>(json['syncedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'uuid': serializer.toJson<String>(uuid),
      'remoteId': serializer.toJson<String?>(remoteId),
      'clubId': serializer.toJson<int>(clubId),
      'clubUuid': serializer.toJson<String>(clubUuid),
      'action': serializer.toJson<String>(action),
      'performedByUserId': serializer.toJson<int>(performedByUserId),
      'performedByRemoteId': serializer.toJson<String?>(performedByRemoteId),
      'targetId': serializer.toJson<String>(targetId),
      'reason': serializer.toJson<String?>(reason),
      'isDirty': serializer.toJson<bool>(isDirty),
      'syncedAt': serializer.toJson<DateTime?>(syncedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  ModerationLog copyWith(
          {int? id,
          String? uuid,
          Value<String?> remoteId = const Value.absent(),
          int? clubId,
          String? clubUuid,
          String? action,
          int? performedByUserId,
          Value<String?> performedByRemoteId = const Value.absent(),
          String? targetId,
          Value<String?> reason = const Value.absent(),
          bool? isDirty,
          Value<DateTime?> syncedAt = const Value.absent(),
          DateTime? createdAt}) =>
      ModerationLog(
        id: id ?? this.id,
        uuid: uuid ?? this.uuid,
        remoteId: remoteId.present ? remoteId.value : this.remoteId,
        clubId: clubId ?? this.clubId,
        clubUuid: clubUuid ?? this.clubUuid,
        action: action ?? this.action,
        performedByUserId: performedByUserId ?? this.performedByUserId,
        performedByRemoteId: performedByRemoteId.present
            ? performedByRemoteId.value
            : this.performedByRemoteId,
        targetId: targetId ?? this.targetId,
        reason: reason.present ? reason.value : this.reason,
        isDirty: isDirty ?? this.isDirty,
        syncedAt: syncedAt.present ? syncedAt.value : this.syncedAt,
        createdAt: createdAt ?? this.createdAt,
      );
  ModerationLog copyWithCompanion(ModerationLogsCompanion data) {
    return ModerationLog(
      id: data.id.present ? data.id.value : this.id,
      uuid: data.uuid.present ? data.uuid.value : this.uuid,
      remoteId: data.remoteId.present ? data.remoteId.value : this.remoteId,
      clubId: data.clubId.present ? data.clubId.value : this.clubId,
      clubUuid: data.clubUuid.present ? data.clubUuid.value : this.clubUuid,
      action: data.action.present ? data.action.value : this.action,
      performedByUserId: data.performedByUserId.present
          ? data.performedByUserId.value
          : this.performedByUserId,
      performedByRemoteId: data.performedByRemoteId.present
          ? data.performedByRemoteId.value
          : this.performedByRemoteId,
      targetId: data.targetId.present ? data.targetId.value : this.targetId,
      reason: data.reason.present ? data.reason.value : this.reason,
      isDirty: data.isDirty.present ? data.isDirty.value : this.isDirty,
      syncedAt: data.syncedAt.present ? data.syncedAt.value : this.syncedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ModerationLog(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('clubId: $clubId, ')
          ..write('clubUuid: $clubUuid, ')
          ..write('action: $action, ')
          ..write('performedByUserId: $performedByUserId, ')
          ..write('performedByRemoteId: $performedByRemoteId, ')
          ..write('targetId: $targetId, ')
          ..write('reason: $reason, ')
          ..write('isDirty: $isDirty, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
      id,
      uuid,
      remoteId,
      clubId,
      clubUuid,
      action,
      performedByUserId,
      performedByRemoteId,
      targetId,
      reason,
      isDirty,
      syncedAt,
      createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ModerationLog &&
          other.id == this.id &&
          other.uuid == this.uuid &&
          other.remoteId == this.remoteId &&
          other.clubId == this.clubId &&
          other.clubUuid == this.clubUuid &&
          other.action == this.action &&
          other.performedByUserId == this.performedByUserId &&
          other.performedByRemoteId == this.performedByRemoteId &&
          other.targetId == this.targetId &&
          other.reason == this.reason &&
          other.isDirty == this.isDirty &&
          other.syncedAt == this.syncedAt &&
          other.createdAt == this.createdAt);
}

class ModerationLogsCompanion extends UpdateCompanion<ModerationLog> {
  final Value<int> id;
  final Value<String> uuid;
  final Value<String?> remoteId;
  final Value<int> clubId;
  final Value<String> clubUuid;
  final Value<String> action;
  final Value<int> performedByUserId;
  final Value<String?> performedByRemoteId;
  final Value<String> targetId;
  final Value<String?> reason;
  final Value<bool> isDirty;
  final Value<DateTime?> syncedAt;
  final Value<DateTime> createdAt;
  const ModerationLogsCompanion({
    this.id = const Value.absent(),
    this.uuid = const Value.absent(),
    this.remoteId = const Value.absent(),
    this.clubId = const Value.absent(),
    this.clubUuid = const Value.absent(),
    this.action = const Value.absent(),
    this.performedByUserId = const Value.absent(),
    this.performedByRemoteId = const Value.absent(),
    this.targetId = const Value.absent(),
    this.reason = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
  });
  ModerationLogsCompanion.insert({
    this.id = const Value.absent(),
    required String uuid,
    this.remoteId = const Value.absent(),
    required int clubId,
    required String clubUuid,
    required String action,
    required int performedByUserId,
    this.performedByRemoteId = const Value.absent(),
    required String targetId,
    this.reason = const Value.absent(),
    this.isDirty = const Value.absent(),
    this.syncedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
  })  : uuid = Value(uuid),
        clubId = Value(clubId),
        clubUuid = Value(clubUuid),
        action = Value(action),
        performedByUserId = Value(performedByUserId),
        targetId = Value(targetId);
  static Insertable<ModerationLog> custom({
    Expression<int>? id,
    Expression<String>? uuid,
    Expression<String>? remoteId,
    Expression<int>? clubId,
    Expression<String>? clubUuid,
    Expression<String>? action,
    Expression<int>? performedByUserId,
    Expression<String>? performedByRemoteId,
    Expression<String>? targetId,
    Expression<String>? reason,
    Expression<bool>? isDirty,
    Expression<DateTime>? syncedAt,
    Expression<DateTime>? createdAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (uuid != null) 'uuid': uuid,
      if (remoteId != null) 'remote_id': remoteId,
      if (clubId != null) 'club_id': clubId,
      if (clubUuid != null) 'club_uuid': clubUuid,
      if (action != null) 'action': action,
      if (performedByUserId != null) 'performed_by_user_id': performedByUserId,
      if (performedByRemoteId != null)
        'performed_by_remote_id': performedByRemoteId,
      if (targetId != null) 'target_id': targetId,
      if (reason != null) 'reason': reason,
      if (isDirty != null) 'is_dirty': isDirty,
      if (syncedAt != null) 'synced_at': syncedAt,
      if (createdAt != null) 'created_at': createdAt,
    });
  }

  ModerationLogsCompanion copyWith(
      {Value<int>? id,
      Value<String>? uuid,
      Value<String?>? remoteId,
      Value<int>? clubId,
      Value<String>? clubUuid,
      Value<String>? action,
      Value<int>? performedByUserId,
      Value<String?>? performedByRemoteId,
      Value<String>? targetId,
      Value<String?>? reason,
      Value<bool>? isDirty,
      Value<DateTime?>? syncedAt,
      Value<DateTime>? createdAt}) {
    return ModerationLogsCompanion(
      id: id ?? this.id,
      uuid: uuid ?? this.uuid,
      remoteId: remoteId ?? this.remoteId,
      clubId: clubId ?? this.clubId,
      clubUuid: clubUuid ?? this.clubUuid,
      action: action ?? this.action,
      performedByUserId: performedByUserId ?? this.performedByUserId,
      performedByRemoteId: performedByRemoteId ?? this.performedByRemoteId,
      targetId: targetId ?? this.targetId,
      reason: reason ?? this.reason,
      isDirty: isDirty ?? this.isDirty,
      syncedAt: syncedAt ?? this.syncedAt,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (uuid.present) {
      map['uuid'] = Variable<String>(uuid.value);
    }
    if (remoteId.present) {
      map['remote_id'] = Variable<String>(remoteId.value);
    }
    if (clubId.present) {
      map['club_id'] = Variable<int>(clubId.value);
    }
    if (clubUuid.present) {
      map['club_uuid'] = Variable<String>(clubUuid.value);
    }
    if (action.present) {
      map['action'] = Variable<String>(action.value);
    }
    if (performedByUserId.present) {
      map['performed_by_user_id'] = Variable<int>(performedByUserId.value);
    }
    if (performedByRemoteId.present) {
      map['performed_by_remote_id'] =
          Variable<String>(performedByRemoteId.value);
    }
    if (targetId.present) {
      map['target_id'] = Variable<String>(targetId.value);
    }
    if (reason.present) {
      map['reason'] = Variable<String>(reason.value);
    }
    if (isDirty.present) {
      map['is_dirty'] = Variable<bool>(isDirty.value);
    }
    if (syncedAt.present) {
      map['synced_at'] = Variable<DateTime>(syncedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ModerationLogsCompanion(')
          ..write('id: $id, ')
          ..write('uuid: $uuid, ')
          ..write('remoteId: $remoteId, ')
          ..write('clubId: $clubId, ')
          ..write('clubUuid: $clubUuid, ')
          ..write('action: $action, ')
          ..write('performedByUserId: $performedByUserId, ')
          ..write('performedByRemoteId: $performedByRemoteId, ')
          ..write('targetId: $targetId, ')
          ..write('reason: $reason, ')
          ..write('isDirty: $isDirty, ')
          ..write('syncedAt: $syncedAt, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $LocalUsersTable localUsers = $LocalUsersTable(this);
  late final $BooksTable books = $BooksTable(this);
  late final $BookReviewsTable bookReviews = $BookReviewsTable(this);
  late final $ReadingTimelineEntriesTable readingTimelineEntries =
      $ReadingTimelineEntriesTable(this);
  late final $GroupsTable groups = $GroupsTable(this);
  late final $GroupMembersTable groupMembers = $GroupMembersTable(this);
  late final $SharedBooksTable sharedBooks = $SharedBooksTable(this);
  late final $GroupInvitationsTable groupInvitations =
      $GroupInvitationsTable(this);
  late final $LoansTable loans = $LoansTable(this);
  late final $InAppNotificationsTable inAppNotifications =
      $InAppNotificationsTable(this);
  late final $WishlistItemsTable wishlistItems = $WishlistItemsTable(this);
  late final $ReadingClubsTable readingClubs = $ReadingClubsTable(this);
  late final $ClubMembersTable clubMembers = $ClubMembersTable(this);
  late final $ClubBooksTable clubBooks = $ClubBooksTable(this);
  late final $ClubReadingProgressTable clubReadingProgress =
      $ClubReadingProgressTable(this);
  late final $BookProposalsTable bookProposals = $BookProposalsTable(this);
  late final $SectionCommentsTable sectionComments =
      $SectionCommentsTable(this);
  late final $CommentReportsTable commentReports = $CommentReportsTable(this);
  late final $ModerationLogsTable moderationLogs = $ModerationLogsTable(this);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
        localUsers,
        books,
        bookReviews,
        readingTimelineEntries,
        groups,
        groupMembers,
        sharedBooks,
        groupInvitations,
        loans,
        inAppNotifications,
        wishlistItems,
        readingClubs,
        clubMembers,
        clubBooks,
        clubReadingProgress,
        bookProposals,
        sectionComments,
        commentReports,
        moderationLogs
      ];
  @override
  StreamQueryUpdateRules get streamUpdateRules => const StreamQueryUpdateRules(
        [
          WritePropagation(
            on: TableUpdateQuery.onTableName('books',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('book_reviews', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('books',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('reading_timeline_entries', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('groups',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('group_members', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('groups',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('shared_books', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('books',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('shared_books', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('groups',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('group_invitations', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('shared_books',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('loans', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('books',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('loans', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('reading_clubs',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('club_members', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('reading_clubs',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('club_books', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('reading_clubs',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('club_reading_progress', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('club_books',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('club_reading_progress', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('reading_clubs',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('book_proposals', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('reading_clubs',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('section_comments', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('club_books',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('section_comments', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('section_comments',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('comment_reports', kind: UpdateKind.delete),
            ],
          ),
          WritePropagation(
            on: TableUpdateQuery.onTableName('reading_clubs',
                limitUpdateKind: UpdateKind.delete),
            result: [
              TableUpdate('moderation_logs', kind: UpdateKind.delete),
            ],
          ),
        ],
      );
}

typedef $$LocalUsersTableCreateCompanionBuilder = LocalUsersCompanion Function({
  Value<int> id,
  required String uuid,
  required String username,
  Value<String?> remoteId,
  Value<String?> pinHash,
  Value<String?> pinSalt,
  Value<DateTime?> pinUpdatedAt,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});
typedef $$LocalUsersTableUpdateCompanionBuilder = LocalUsersCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> username,
  Value<String?> remoteId,
  Value<String?> pinHash,
  Value<String?> pinSalt,
  Value<DateTime?> pinUpdatedAt,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

final class $$LocalUsersTableReferences
    extends BaseReferences<_$AppDatabase, $LocalUsersTable, LocalUser> {
  $$LocalUsersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$BooksTable, List<Book>> _ownedBooksTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.books,
          aliasName:
              $_aliasNameGenerator(db.localUsers.id, db.books.ownerUserId));

  $$BooksTableProcessedTableManager get ownedBooks {
    final manager = $$BooksTableTableManager($_db, $_db.books)
        .filter((f) => f.ownerUserId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_ownedBooksTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$BookReviewsTable, List<BookReview>>
      _bookReviewsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.bookReviews,
              aliasName: $_aliasNameGenerator(
                  db.localUsers.id, db.bookReviews.authorUserId));

  $$BookReviewsTableProcessedTableManager get bookReviewsRefs {
    final manager = $$BookReviewsTableTableManager($_db, $_db.bookReviews)
        .filter((f) => f.authorUserId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_bookReviewsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$ReadingTimelineEntriesTable,
      List<ReadingTimelineEntry>> _readingTimelineEntriesRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.readingTimelineEntries,
          aliasName: $_aliasNameGenerator(
              db.localUsers.id, db.readingTimelineEntries.ownerUserId));

  $$ReadingTimelineEntriesTableProcessedTableManager
      get readingTimelineEntriesRefs {
    final manager = $$ReadingTimelineEntriesTableTableManager(
            $_db, $_db.readingTimelineEntries)
        .filter((f) => f.ownerUserId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_readingTimelineEntriesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$GroupsTable, List<Group>> _groupsRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.groups,
          aliasName:
              $_aliasNameGenerator(db.localUsers.id, db.groups.ownerUserId));

  $$GroupsTableProcessedTableManager get groupsRefs {
    final manager = $$GroupsTableTableManager($_db, $_db.groups)
        .filter((f) => f.ownerUserId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_groupsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$GroupMembersTable, List<GroupMember>>
      _groupMembershipsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.groupMembers,
              aliasName: $_aliasNameGenerator(
                  db.localUsers.id, db.groupMembers.memberUserId));

  $$GroupMembersTableProcessedTableManager get groupMemberships {
    final manager = $$GroupMembersTableTableManager($_db, $_db.groupMembers)
        .filter((f) => f.memberUserId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_groupMembershipsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$SharedBooksTable, List<SharedBook>>
      _sharedBooksOwnedTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.sharedBooks,
              aliasName: $_aliasNameGenerator(
                  db.localUsers.id, db.sharedBooks.ownerUserId));

  $$SharedBooksTableProcessedTableManager get sharedBooksOwned {
    final manager = $$SharedBooksTableTableManager($_db, $_db.sharedBooks)
        .filter((f) => f.ownerUserId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_sharedBooksOwnedTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$GroupInvitationsTable, List<GroupInvitation>>
      _groupInvitationsSentTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.groupInvitations,
              aliasName: $_aliasNameGenerator(
                  db.localUsers.id, db.groupInvitations.inviterUserId));

  $$GroupInvitationsTableProcessedTableManager get groupInvitationsSent {
    final manager = $$GroupInvitationsTableTableManager(
            $_db, $_db.groupInvitations)
        .filter((f) => f.inviterUserId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_groupInvitationsSentTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$GroupInvitationsTable, List<GroupInvitation>>
      _groupInvitationsAcceptedTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.groupInvitations,
              aliasName: $_aliasNameGenerator(
                  db.localUsers.id, db.groupInvitations.acceptedUserId));

  $$GroupInvitationsTableProcessedTableManager get groupInvitationsAccepted {
    final manager = $$GroupInvitationsTableTableManager(
            $_db, $_db.groupInvitations)
        .filter((f) => f.acceptedUserId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_groupInvitationsAcceptedTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$LoansTable, List<Loan>> _loansBorrowerTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.loans,
          aliasName:
              $_aliasNameGenerator(db.localUsers.id, db.loans.borrowerUserId));

  $$LoansTableProcessedTableManager get loansBorrower {
    final manager = $$LoansTableTableManager($_db, $_db.loans)
        .filter((f) => f.borrowerUserId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_loansBorrowerTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$LoansTable, List<Loan>> _loansLenderTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.loans,
          aliasName:
              $_aliasNameGenerator(db.localUsers.id, db.loans.lenderUserId));

  $$LoansTableProcessedTableManager get loansLender {
    final manager = $$LoansTableTableManager($_db, $_db.loans)
        .filter((f) => f.lenderUserId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_loansLenderTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$InAppNotificationsTable, List<InAppNotification>>
      _notificationsAuthoredTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.inAppNotifications,
              aliasName: $_aliasNameGenerator(
                  db.localUsers.id, db.inAppNotifications.actorUserId));

  $$InAppNotificationsTableProcessedTableManager get notificationsAuthored {
    final manager = $$InAppNotificationsTableTableManager(
            $_db, $_db.inAppNotifications)
        .filter((f) => f.actorUserId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_notificationsAuthoredTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$InAppNotificationsTable, List<InAppNotification>>
      _notificationsReceivedTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.inAppNotifications,
              aliasName: $_aliasNameGenerator(
                  db.localUsers.id, db.inAppNotifications.targetUserId));

  $$InAppNotificationsTableProcessedTableManager get notificationsReceived {
    final manager = $$InAppNotificationsTableTableManager(
            $_db, $_db.inAppNotifications)
        .filter((f) => f.targetUserId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_notificationsReceivedTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$WishlistItemsTable, List<WishlistItem>>
      _wishlistUserTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
          db.wishlistItems,
          aliasName:
              $_aliasNameGenerator(db.localUsers.id, db.wishlistItems.userId));

  $$WishlistItemsTableProcessedTableManager get wishlistUser {
    final manager = $$WishlistItemsTableTableManager($_db, $_db.wishlistItems)
        .filter((f) => f.userId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_wishlistUserTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$ReadingClubsTable, List<ReadingClub>>
      _readingClubsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.readingClubs,
              aliasName: $_aliasNameGenerator(
                  db.localUsers.id, db.readingClubs.ownerUserId));

  $$ReadingClubsTableProcessedTableManager get readingClubsRefs {
    final manager = $$ReadingClubsTableTableManager($_db, $_db.readingClubs)
        .filter((f) => f.ownerUserId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_readingClubsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$ClubMembersTable, List<ClubMember>>
      _clubMembershipsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.clubMembers,
              aliasName: $_aliasNameGenerator(
                  db.localUsers.id, db.clubMembers.memberUserId));

  $$ClubMembersTableProcessedTableManager get clubMemberships {
    final manager = $$ClubMembersTableTableManager($_db, $_db.clubMembers)
        .filter((f) => f.memberUserId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_clubMembershipsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$ClubReadingProgressTable,
      List<ClubReadingProgressData>> _clubProgressUserTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.clubReadingProgress,
          aliasName: $_aliasNameGenerator(
              db.localUsers.id, db.clubReadingProgress.userId));

  $$ClubReadingProgressTableProcessedTableManager get clubProgressUser {
    final manager =
        $$ClubReadingProgressTableTableManager($_db, $_db.clubReadingProgress)
            .filter((f) => f.userId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_clubProgressUserTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$BookProposalsTable, List<BookProposal>>
      _proposalAuthorTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.bookProposals,
              aliasName: $_aliasNameGenerator(
                  db.localUsers.id, db.bookProposals.proposedByUserId));

  $$BookProposalsTableProcessedTableManager get proposalAuthor {
    final manager = $$BookProposalsTableTableManager($_db, $_db.bookProposals)
        .filter(
            (f) => f.proposedByUserId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_proposalAuthorTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$SectionCommentsTable, List<SectionComment>>
      _commentAuthorTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.sectionComments,
              aliasName: $_aliasNameGenerator(
                  db.localUsers.id, db.sectionComments.userId));

  $$SectionCommentsTableProcessedTableManager get commentAuthor {
    final manager =
        $$SectionCommentsTableTableManager($_db, $_db.sectionComments)
            .filter((f) => f.userId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_commentAuthorTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$CommentReportsTable, List<CommentReport>>
      _reportAuthorTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.commentReports,
              aliasName: $_aliasNameGenerator(
                  db.localUsers.id, db.commentReports.reportedByUserId));

  $$CommentReportsTableProcessedTableManager get reportAuthor {
    final manager = $$CommentReportsTableTableManager($_db, $_db.commentReports)
        .filter(
            (f) => f.reportedByUserId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_reportAuthorTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$ModerationLogsTable, List<ModerationLog>>
      _moderationPerformerTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.moderationLogs,
              aliasName: $_aliasNameGenerator(
                  db.localUsers.id, db.moderationLogs.performedByUserId));

  $$ModerationLogsTableProcessedTableManager get moderationPerformer {
    final manager = $$ModerationLogsTableTableManager($_db, $_db.moderationLogs)
        .filter(
            (f) => f.performedByUserId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_moderationPerformerTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$LocalUsersTableFilterComposer
    extends Composer<_$AppDatabase, $LocalUsersTable> {
  $$LocalUsersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get username => $composableBuilder(
      column: $table.username, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get pinHash => $composableBuilder(
      column: $table.pinHash, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get pinSalt => $composableBuilder(
      column: $table.pinSalt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get pinUpdatedAt => $composableBuilder(
      column: $table.pinUpdatedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  Expression<bool> ownedBooks(
      Expression<bool> Function($$BooksTableFilterComposer f) f) {
    final $$BooksTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.books,
        getReferencedColumn: (t) => t.ownerUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BooksTableFilterComposer(
              $db: $db,
              $table: $db.books,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> bookReviewsRefs(
      Expression<bool> Function($$BookReviewsTableFilterComposer f) f) {
    final $$BookReviewsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.bookReviews,
        getReferencedColumn: (t) => t.authorUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BookReviewsTableFilterComposer(
              $db: $db,
              $table: $db.bookReviews,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> readingTimelineEntriesRefs(
      Expression<bool> Function($$ReadingTimelineEntriesTableFilterComposer f)
          f) {
    final $$ReadingTimelineEntriesTableFilterComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.readingTimelineEntries,
            getReferencedColumn: (t) => t.ownerUserId,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$ReadingTimelineEntriesTableFilterComposer(
                  $db: $db,
                  $table: $db.readingTimelineEntries,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<bool> groupsRefs(
      Expression<bool> Function($$GroupsTableFilterComposer f) f) {
    final $$GroupsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.groups,
        getReferencedColumn: (t) => t.ownerUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupsTableFilterComposer(
              $db: $db,
              $table: $db.groups,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> groupMemberships(
      Expression<bool> Function($$GroupMembersTableFilterComposer f) f) {
    final $$GroupMembersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.groupMembers,
        getReferencedColumn: (t) => t.memberUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupMembersTableFilterComposer(
              $db: $db,
              $table: $db.groupMembers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> sharedBooksOwned(
      Expression<bool> Function($$SharedBooksTableFilterComposer f) f) {
    final $$SharedBooksTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.sharedBooks,
        getReferencedColumn: (t) => t.ownerUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SharedBooksTableFilterComposer(
              $db: $db,
              $table: $db.sharedBooks,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> groupInvitationsSent(
      Expression<bool> Function($$GroupInvitationsTableFilterComposer f) f) {
    final $$GroupInvitationsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.groupInvitations,
        getReferencedColumn: (t) => t.inviterUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupInvitationsTableFilterComposer(
              $db: $db,
              $table: $db.groupInvitations,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> groupInvitationsAccepted(
      Expression<bool> Function($$GroupInvitationsTableFilterComposer f) f) {
    final $$GroupInvitationsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.groupInvitations,
        getReferencedColumn: (t) => t.acceptedUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupInvitationsTableFilterComposer(
              $db: $db,
              $table: $db.groupInvitations,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> loansBorrower(
      Expression<bool> Function($$LoansTableFilterComposer f) f) {
    final $$LoansTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.loans,
        getReferencedColumn: (t) => t.borrowerUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LoansTableFilterComposer(
              $db: $db,
              $table: $db.loans,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> loansLender(
      Expression<bool> Function($$LoansTableFilterComposer f) f) {
    final $$LoansTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.loans,
        getReferencedColumn: (t) => t.lenderUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LoansTableFilterComposer(
              $db: $db,
              $table: $db.loans,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> notificationsAuthored(
      Expression<bool> Function($$InAppNotificationsTableFilterComposer f) f) {
    final $$InAppNotificationsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.inAppNotifications,
        getReferencedColumn: (t) => t.actorUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$InAppNotificationsTableFilterComposer(
              $db: $db,
              $table: $db.inAppNotifications,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> notificationsReceived(
      Expression<bool> Function($$InAppNotificationsTableFilterComposer f) f) {
    final $$InAppNotificationsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.inAppNotifications,
        getReferencedColumn: (t) => t.targetUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$InAppNotificationsTableFilterComposer(
              $db: $db,
              $table: $db.inAppNotifications,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> wishlistUser(
      Expression<bool> Function($$WishlistItemsTableFilterComposer f) f) {
    final $$WishlistItemsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.wishlistItems,
        getReferencedColumn: (t) => t.userId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$WishlistItemsTableFilterComposer(
              $db: $db,
              $table: $db.wishlistItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> readingClubsRefs(
      Expression<bool> Function($$ReadingClubsTableFilterComposer f) f) {
    final $$ReadingClubsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.readingClubs,
        getReferencedColumn: (t) => t.ownerUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReadingClubsTableFilterComposer(
              $db: $db,
              $table: $db.readingClubs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> clubMemberships(
      Expression<bool> Function($$ClubMembersTableFilterComposer f) f) {
    final $$ClubMembersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.clubMembers,
        getReferencedColumn: (t) => t.memberUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClubMembersTableFilterComposer(
              $db: $db,
              $table: $db.clubMembers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> clubProgressUser(
      Expression<bool> Function($$ClubReadingProgressTableFilterComposer f) f) {
    final $$ClubReadingProgressTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.clubReadingProgress,
        getReferencedColumn: (t) => t.userId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClubReadingProgressTableFilterComposer(
              $db: $db,
              $table: $db.clubReadingProgress,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> proposalAuthor(
      Expression<bool> Function($$BookProposalsTableFilterComposer f) f) {
    final $$BookProposalsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.bookProposals,
        getReferencedColumn: (t) => t.proposedByUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BookProposalsTableFilterComposer(
              $db: $db,
              $table: $db.bookProposals,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> commentAuthor(
      Expression<bool> Function($$SectionCommentsTableFilterComposer f) f) {
    final $$SectionCommentsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.sectionComments,
        getReferencedColumn: (t) => t.userId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SectionCommentsTableFilterComposer(
              $db: $db,
              $table: $db.sectionComments,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> reportAuthor(
      Expression<bool> Function($$CommentReportsTableFilterComposer f) f) {
    final $$CommentReportsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.commentReports,
        getReferencedColumn: (t) => t.reportedByUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$CommentReportsTableFilterComposer(
              $db: $db,
              $table: $db.commentReports,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> moderationPerformer(
      Expression<bool> Function($$ModerationLogsTableFilterComposer f) f) {
    final $$ModerationLogsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.moderationLogs,
        getReferencedColumn: (t) => t.performedByUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ModerationLogsTableFilterComposer(
              $db: $db,
              $table: $db.moderationLogs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$LocalUsersTableOrderingComposer
    extends Composer<_$AppDatabase, $LocalUsersTable> {
  $$LocalUsersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get username => $composableBuilder(
      column: $table.username, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get pinHash => $composableBuilder(
      column: $table.pinHash, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get pinSalt => $composableBuilder(
      column: $table.pinSalt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get pinUpdatedAt => $composableBuilder(
      column: $table.pinUpdatedAt,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));
}

class $$LocalUsersTableAnnotationComposer
    extends Composer<_$AppDatabase, $LocalUsersTable> {
  $$LocalUsersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get username =>
      $composableBuilder(column: $table.username, builder: (column) => column);

  GeneratedColumn<String> get remoteId =>
      $composableBuilder(column: $table.remoteId, builder: (column) => column);

  GeneratedColumn<String> get pinHash =>
      $composableBuilder(column: $table.pinHash, builder: (column) => column);

  GeneratedColumn<String> get pinSalt =>
      $composableBuilder(column: $table.pinSalt, builder: (column) => column);

  GeneratedColumn<DateTime> get pinUpdatedAt => $composableBuilder(
      column: $table.pinUpdatedAt, builder: (column) => column);

  GeneratedColumn<bool> get isDirty =>
      $composableBuilder(column: $table.isDirty, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get syncedAt =>
      $composableBuilder(column: $table.syncedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  Expression<T> ownedBooks<T extends Object>(
      Expression<T> Function($$BooksTableAnnotationComposer a) f) {
    final $$BooksTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.books,
        getReferencedColumn: (t) => t.ownerUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BooksTableAnnotationComposer(
              $db: $db,
              $table: $db.books,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> bookReviewsRefs<T extends Object>(
      Expression<T> Function($$BookReviewsTableAnnotationComposer a) f) {
    final $$BookReviewsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.bookReviews,
        getReferencedColumn: (t) => t.authorUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BookReviewsTableAnnotationComposer(
              $db: $db,
              $table: $db.bookReviews,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> readingTimelineEntriesRefs<T extends Object>(
      Expression<T> Function($$ReadingTimelineEntriesTableAnnotationComposer a)
          f) {
    final $$ReadingTimelineEntriesTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.readingTimelineEntries,
            getReferencedColumn: (t) => t.ownerUserId,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$ReadingTimelineEntriesTableAnnotationComposer(
                  $db: $db,
                  $table: $db.readingTimelineEntries,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<T> groupsRefs<T extends Object>(
      Expression<T> Function($$GroupsTableAnnotationComposer a) f) {
    final $$GroupsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.groups,
        getReferencedColumn: (t) => t.ownerUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupsTableAnnotationComposer(
              $db: $db,
              $table: $db.groups,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> groupMemberships<T extends Object>(
      Expression<T> Function($$GroupMembersTableAnnotationComposer a) f) {
    final $$GroupMembersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.groupMembers,
        getReferencedColumn: (t) => t.memberUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupMembersTableAnnotationComposer(
              $db: $db,
              $table: $db.groupMembers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> sharedBooksOwned<T extends Object>(
      Expression<T> Function($$SharedBooksTableAnnotationComposer a) f) {
    final $$SharedBooksTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.sharedBooks,
        getReferencedColumn: (t) => t.ownerUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SharedBooksTableAnnotationComposer(
              $db: $db,
              $table: $db.sharedBooks,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> groupInvitationsSent<T extends Object>(
      Expression<T> Function($$GroupInvitationsTableAnnotationComposer a) f) {
    final $$GroupInvitationsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.groupInvitations,
        getReferencedColumn: (t) => t.inviterUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupInvitationsTableAnnotationComposer(
              $db: $db,
              $table: $db.groupInvitations,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> groupInvitationsAccepted<T extends Object>(
      Expression<T> Function($$GroupInvitationsTableAnnotationComposer a) f) {
    final $$GroupInvitationsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.groupInvitations,
        getReferencedColumn: (t) => t.acceptedUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupInvitationsTableAnnotationComposer(
              $db: $db,
              $table: $db.groupInvitations,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> loansBorrower<T extends Object>(
      Expression<T> Function($$LoansTableAnnotationComposer a) f) {
    final $$LoansTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.loans,
        getReferencedColumn: (t) => t.borrowerUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LoansTableAnnotationComposer(
              $db: $db,
              $table: $db.loans,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> loansLender<T extends Object>(
      Expression<T> Function($$LoansTableAnnotationComposer a) f) {
    final $$LoansTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.loans,
        getReferencedColumn: (t) => t.lenderUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LoansTableAnnotationComposer(
              $db: $db,
              $table: $db.loans,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> notificationsAuthored<T extends Object>(
      Expression<T> Function($$InAppNotificationsTableAnnotationComposer a) f) {
    final $$InAppNotificationsTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.inAppNotifications,
            getReferencedColumn: (t) => t.actorUserId,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$InAppNotificationsTableAnnotationComposer(
                  $db: $db,
                  $table: $db.inAppNotifications,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<T> notificationsReceived<T extends Object>(
      Expression<T> Function($$InAppNotificationsTableAnnotationComposer a) f) {
    final $$InAppNotificationsTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.inAppNotifications,
            getReferencedColumn: (t) => t.targetUserId,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$InAppNotificationsTableAnnotationComposer(
                  $db: $db,
                  $table: $db.inAppNotifications,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<T> wishlistUser<T extends Object>(
      Expression<T> Function($$WishlistItemsTableAnnotationComposer a) f) {
    final $$WishlistItemsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.wishlistItems,
        getReferencedColumn: (t) => t.userId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$WishlistItemsTableAnnotationComposer(
              $db: $db,
              $table: $db.wishlistItems,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> readingClubsRefs<T extends Object>(
      Expression<T> Function($$ReadingClubsTableAnnotationComposer a) f) {
    final $$ReadingClubsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.readingClubs,
        getReferencedColumn: (t) => t.ownerUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReadingClubsTableAnnotationComposer(
              $db: $db,
              $table: $db.readingClubs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> clubMemberships<T extends Object>(
      Expression<T> Function($$ClubMembersTableAnnotationComposer a) f) {
    final $$ClubMembersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.clubMembers,
        getReferencedColumn: (t) => t.memberUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClubMembersTableAnnotationComposer(
              $db: $db,
              $table: $db.clubMembers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> clubProgressUser<T extends Object>(
      Expression<T> Function($$ClubReadingProgressTableAnnotationComposer a)
          f) {
    final $$ClubReadingProgressTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.clubReadingProgress,
            getReferencedColumn: (t) => t.userId,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$ClubReadingProgressTableAnnotationComposer(
                  $db: $db,
                  $table: $db.clubReadingProgress,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<T> proposalAuthor<T extends Object>(
      Expression<T> Function($$BookProposalsTableAnnotationComposer a) f) {
    final $$BookProposalsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.bookProposals,
        getReferencedColumn: (t) => t.proposedByUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BookProposalsTableAnnotationComposer(
              $db: $db,
              $table: $db.bookProposals,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> commentAuthor<T extends Object>(
      Expression<T> Function($$SectionCommentsTableAnnotationComposer a) f) {
    final $$SectionCommentsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.sectionComments,
        getReferencedColumn: (t) => t.userId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SectionCommentsTableAnnotationComposer(
              $db: $db,
              $table: $db.sectionComments,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> reportAuthor<T extends Object>(
      Expression<T> Function($$CommentReportsTableAnnotationComposer a) f) {
    final $$CommentReportsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.commentReports,
        getReferencedColumn: (t) => t.reportedByUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$CommentReportsTableAnnotationComposer(
              $db: $db,
              $table: $db.commentReports,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> moderationPerformer<T extends Object>(
      Expression<T> Function($$ModerationLogsTableAnnotationComposer a) f) {
    final $$ModerationLogsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.moderationLogs,
        getReferencedColumn: (t) => t.performedByUserId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ModerationLogsTableAnnotationComposer(
              $db: $db,
              $table: $db.moderationLogs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$LocalUsersTableTableManager extends RootTableManager<
    _$AppDatabase,
    $LocalUsersTable,
    LocalUser,
    $$LocalUsersTableFilterComposer,
    $$LocalUsersTableOrderingComposer,
    $$LocalUsersTableAnnotationComposer,
    $$LocalUsersTableCreateCompanionBuilder,
    $$LocalUsersTableUpdateCompanionBuilder,
    (LocalUser, $$LocalUsersTableReferences),
    LocalUser,
    PrefetchHooks Function(
        {bool ownedBooks,
        bool bookReviewsRefs,
        bool readingTimelineEntriesRefs,
        bool groupsRefs,
        bool groupMemberships,
        bool sharedBooksOwned,
        bool groupInvitationsSent,
        bool groupInvitationsAccepted,
        bool loansBorrower,
        bool loansLender,
        bool notificationsAuthored,
        bool notificationsReceived,
        bool wishlistUser,
        bool readingClubsRefs,
        bool clubMemberships,
        bool clubProgressUser,
        bool proposalAuthor,
        bool commentAuthor,
        bool reportAuthor,
        bool moderationPerformer})> {
  $$LocalUsersTableTableManager(_$AppDatabase db, $LocalUsersTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$LocalUsersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$LocalUsersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$LocalUsersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> username = const Value.absent(),
            Value<String?> remoteId = const Value.absent(),
            Value<String?> pinHash = const Value.absent(),
            Value<String?> pinSalt = const Value.absent(),
            Value<DateTime?> pinUpdatedAt = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              LocalUsersCompanion(
            id: id,
            uuid: uuid,
            username: username,
            remoteId: remoteId,
            pinHash: pinHash,
            pinSalt: pinSalt,
            pinUpdatedAt: pinUpdatedAt,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String username,
            Value<String?> remoteId = const Value.absent(),
            Value<String?> pinHash = const Value.absent(),
            Value<String?> pinSalt = const Value.absent(),
            Value<DateTime?> pinUpdatedAt = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              LocalUsersCompanion.insert(
            id: id,
            uuid: uuid,
            username: username,
            remoteId: remoteId,
            pinHash: pinHash,
            pinSalt: pinSalt,
            pinUpdatedAt: pinUpdatedAt,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$LocalUsersTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {ownedBooks = false,
              bookReviewsRefs = false,
              readingTimelineEntriesRefs = false,
              groupsRefs = false,
              groupMemberships = false,
              sharedBooksOwned = false,
              groupInvitationsSent = false,
              groupInvitationsAccepted = false,
              loansBorrower = false,
              loansLender = false,
              notificationsAuthored = false,
              notificationsReceived = false,
              wishlistUser = false,
              readingClubsRefs = false,
              clubMemberships = false,
              clubProgressUser = false,
              proposalAuthor = false,
              commentAuthor = false,
              reportAuthor = false,
              moderationPerformer = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (ownedBooks) db.books,
                if (bookReviewsRefs) db.bookReviews,
                if (readingTimelineEntriesRefs) db.readingTimelineEntries,
                if (groupsRefs) db.groups,
                if (groupMemberships) db.groupMembers,
                if (sharedBooksOwned) db.sharedBooks,
                if (groupInvitationsSent) db.groupInvitations,
                if (groupInvitationsAccepted) db.groupInvitations,
                if (loansBorrower) db.loans,
                if (loansLender) db.loans,
                if (notificationsAuthored) db.inAppNotifications,
                if (notificationsReceived) db.inAppNotifications,
                if (wishlistUser) db.wishlistItems,
                if (readingClubsRefs) db.readingClubs,
                if (clubMemberships) db.clubMembers,
                if (clubProgressUser) db.clubReadingProgress,
                if (proposalAuthor) db.bookProposals,
                if (commentAuthor) db.sectionComments,
                if (reportAuthor) db.commentReports,
                if (moderationPerformer) db.moderationLogs
              ],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (ownedBooks)
                    await $_getPrefetchedData<LocalUser, $LocalUsersTable,
                            Book>(
                        currentTable: table,
                        referencedTable:
                            $$LocalUsersTableReferences._ownedBooksTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LocalUsersTableReferences(db, table, p0)
                                .ownedBooks,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.ownerUserId == item.id),
                        typedResults: items),
                  if (bookReviewsRefs)
                    await $_getPrefetchedData<LocalUser, $LocalUsersTable,
                            BookReview>(
                        currentTable: table,
                        referencedTable: $$LocalUsersTableReferences
                            ._bookReviewsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LocalUsersTableReferences(db, table, p0)
                                .bookReviewsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.authorUserId == item.id),
                        typedResults: items),
                  if (readingTimelineEntriesRefs)
                    await $_getPrefetchedData<LocalUser, $LocalUsersTable, ReadingTimelineEntry>(
                        currentTable: table,
                        referencedTable: $$LocalUsersTableReferences
                            ._readingTimelineEntriesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LocalUsersTableReferences(db, table, p0)
                                .readingTimelineEntriesRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.ownerUserId == item.id),
                        typedResults: items),
                  if (groupsRefs)
                    await $_getPrefetchedData<LocalUser, $LocalUsersTable,
                            Group>(
                        currentTable: table,
                        referencedTable:
                            $$LocalUsersTableReferences._groupsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LocalUsersTableReferences(db, table, p0)
                                .groupsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.ownerUserId == item.id),
                        typedResults: items),
                  if (groupMemberships)
                    await $_getPrefetchedData<LocalUser, $LocalUsersTable,
                            GroupMember>(
                        currentTable: table,
                        referencedTable: $$LocalUsersTableReferences
                            ._groupMembershipsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LocalUsersTableReferences(db, table, p0)
                                .groupMemberships,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.memberUserId == item.id),
                        typedResults: items),
                  if (sharedBooksOwned)
                    await $_getPrefetchedData<LocalUser, $LocalUsersTable,
                            SharedBook>(
                        currentTable: table,
                        referencedTable: $$LocalUsersTableReferences
                            ._sharedBooksOwnedTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LocalUsersTableReferences(db, table, p0)
                                .sharedBooksOwned,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.ownerUserId == item.id),
                        typedResults: items),
                  if (groupInvitationsSent)
                    await $_getPrefetchedData<LocalUser, $LocalUsersTable,
                            GroupInvitation>(
                        currentTable: table,
                        referencedTable: $$LocalUsersTableReferences
                            ._groupInvitationsSentTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LocalUsersTableReferences(db, table, p0)
                                .groupInvitationsSent,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.inviterUserId == item.id),
                        typedResults: items),
                  if (groupInvitationsAccepted)
                    await $_getPrefetchedData<LocalUser, $LocalUsersTable,
                            GroupInvitation>(
                        currentTable: table,
                        referencedTable: $$LocalUsersTableReferences
                            ._groupInvitationsAcceptedTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LocalUsersTableReferences(db, table, p0)
                                .groupInvitationsAccepted,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.acceptedUserId == item.id),
                        typedResults: items),
                  if (loansBorrower)
                    await $_getPrefetchedData<LocalUser, $LocalUsersTable,
                            Loan>(
                        currentTable: table,
                        referencedTable:
                            $$LocalUsersTableReferences._loansBorrowerTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LocalUsersTableReferences(db, table, p0)
                                .loansBorrower,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.borrowerUserId == item.id),
                        typedResults: items),
                  if (loansLender)
                    await $_getPrefetchedData<LocalUser, $LocalUsersTable,
                            Loan>(
                        currentTable: table,
                        referencedTable:
                            $$LocalUsersTableReferences._loansLenderTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LocalUsersTableReferences(db, table, p0)
                                .loansLender,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.lenderUserId == item.id),
                        typedResults: items),
                  if (notificationsAuthored)
                    await $_getPrefetchedData<LocalUser, $LocalUsersTable,
                            InAppNotification>(
                        currentTable: table,
                        referencedTable: $$LocalUsersTableReferences
                            ._notificationsAuthoredTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LocalUsersTableReferences(db, table, p0)
                                .notificationsAuthored,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.actorUserId == item.id),
                        typedResults: items),
                  if (notificationsReceived)
                    await $_getPrefetchedData<LocalUser, $LocalUsersTable,
                            InAppNotification>(
                        currentTable: table,
                        referencedTable: $$LocalUsersTableReferences
                            ._notificationsReceivedTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LocalUsersTableReferences(db, table, p0)
                                .notificationsReceived,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.targetUserId == item.id),
                        typedResults: items),
                  if (wishlistUser)
                    await $_getPrefetchedData<LocalUser, $LocalUsersTable,
                            WishlistItem>(
                        currentTable: table,
                        referencedTable:
                            $$LocalUsersTableReferences._wishlistUserTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LocalUsersTableReferences(db, table, p0)
                                .wishlistUser,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.userId == item.id),
                        typedResults: items),
                  if (readingClubsRefs)
                    await $_getPrefetchedData<LocalUser, $LocalUsersTable,
                            ReadingClub>(
                        currentTable: table,
                        referencedTable: $$LocalUsersTableReferences
                            ._readingClubsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LocalUsersTableReferences(db, table, p0)
                                .readingClubsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.ownerUserId == item.id),
                        typedResults: items),
                  if (clubMemberships)
                    await $_getPrefetchedData<LocalUser, $LocalUsersTable,
                            ClubMember>(
                        currentTable: table,
                        referencedTable: $$LocalUsersTableReferences
                            ._clubMembershipsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LocalUsersTableReferences(db, table, p0)
                                .clubMemberships,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.memberUserId == item.id),
                        typedResults: items),
                  if (clubProgressUser)
                    await $_getPrefetchedData<LocalUser, $LocalUsersTable,
                            ClubReadingProgressData>(
                        currentTable: table,
                        referencedTable: $$LocalUsersTableReferences
                            ._clubProgressUserTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LocalUsersTableReferences(db, table, p0)
                                .clubProgressUser,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.userId == item.id),
                        typedResults: items),
                  if (proposalAuthor)
                    await $_getPrefetchedData<LocalUser, $LocalUsersTable,
                            BookProposal>(
                        currentTable: table,
                        referencedTable: $$LocalUsersTableReferences
                            ._proposalAuthorTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LocalUsersTableReferences(db, table, p0)
                                .proposalAuthor,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.proposedByUserId == item.id),
                        typedResults: items),
                  if (commentAuthor)
                    await $_getPrefetchedData<LocalUser, $LocalUsersTable,
                            SectionComment>(
                        currentTable: table,
                        referencedTable:
                            $$LocalUsersTableReferences._commentAuthorTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LocalUsersTableReferences(db, table, p0)
                                .commentAuthor,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.userId == item.id),
                        typedResults: items),
                  if (reportAuthor)
                    await $_getPrefetchedData<LocalUser, $LocalUsersTable,
                            CommentReport>(
                        currentTable: table,
                        referencedTable:
                            $$LocalUsersTableReferences._reportAuthorTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LocalUsersTableReferences(db, table, p0)
                                .reportAuthor,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.reportedByUserId == item.id),
                        typedResults: items),
                  if (moderationPerformer)
                    await $_getPrefetchedData<LocalUser, $LocalUsersTable,
                            ModerationLog>(
                        currentTable: table,
                        referencedTable: $$LocalUsersTableReferences
                            ._moderationPerformerTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LocalUsersTableReferences(db, table, p0)
                                .moderationPerformer,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.performedByUserId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$LocalUsersTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $LocalUsersTable,
    LocalUser,
    $$LocalUsersTableFilterComposer,
    $$LocalUsersTableOrderingComposer,
    $$LocalUsersTableAnnotationComposer,
    $$LocalUsersTableCreateCompanionBuilder,
    $$LocalUsersTableUpdateCompanionBuilder,
    (LocalUser, $$LocalUsersTableReferences),
    LocalUser,
    PrefetchHooks Function(
        {bool ownedBooks,
        bool bookReviewsRefs,
        bool readingTimelineEntriesRefs,
        bool groupsRefs,
        bool groupMemberships,
        bool sharedBooksOwned,
        bool groupInvitationsSent,
        bool groupInvitationsAccepted,
        bool loansBorrower,
        bool loansLender,
        bool notificationsAuthored,
        bool notificationsReceived,
        bool wishlistUser,
        bool readingClubsRefs,
        bool clubMemberships,
        bool clubProgressUser,
        bool proposalAuthor,
        bool commentAuthor,
        bool reportAuthor,
        bool moderationPerformer})>;
typedef $$BooksTableCreateCompanionBuilder = BooksCompanion Function({
  Value<int> id,
  required String uuid,
  Value<String?> remoteId,
  Value<int?> ownerUserId,
  Value<String?> ownerRemoteId,
  required String title,
  Value<String?> author,
  Value<String?> isbn,
  Value<String?> barcode,
  Value<String?> coverPath,
  Value<String> status,
  Value<String?> description,
  Value<String> readingStatus,
  Value<bool> isRead,
  Value<DateTime?> readAt,
  Value<bool> isBorrowedExternal,
  Value<String?> externalLenderName,
  Value<String?> genre,
  Value<bool> isPhysical,
  Value<int?> pageCount,
  Value<int?> publicationYear,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});
typedef $$BooksTableUpdateCompanionBuilder = BooksCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String?> remoteId,
  Value<int?> ownerUserId,
  Value<String?> ownerRemoteId,
  Value<String> title,
  Value<String?> author,
  Value<String?> isbn,
  Value<String?> barcode,
  Value<String?> coverPath,
  Value<String> status,
  Value<String?> description,
  Value<String> readingStatus,
  Value<bool> isRead,
  Value<DateTime?> readAt,
  Value<bool> isBorrowedExternal,
  Value<String?> externalLenderName,
  Value<String?> genre,
  Value<bool> isPhysical,
  Value<int?> pageCount,
  Value<int?> publicationYear,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

final class $$BooksTableReferences
    extends BaseReferences<_$AppDatabase, $BooksTable, Book> {
  $$BooksTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $LocalUsersTable _ownerUserIdTable(_$AppDatabase db) =>
      db.localUsers.createAlias(
          $_aliasNameGenerator(db.books.ownerUserId, db.localUsers.id));

  $$LocalUsersTableProcessedTableManager? get ownerUserId {
    final $_column = $_itemColumn<int>('owner_user_id');
    if ($_column == null) return null;
    final manager = $$LocalUsersTableTableManager($_db, $_db.localUsers)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_ownerUserIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$BookReviewsTable, List<BookReview>>
      _bookReviewsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
          db.bookReviews,
          aliasName: $_aliasNameGenerator(db.books.id, db.bookReviews.bookId));

  $$BookReviewsTableProcessedTableManager get bookReviewsRefs {
    final manager = $$BookReviewsTableTableManager($_db, $_db.bookReviews)
        .filter((f) => f.bookId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_bookReviewsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$ReadingTimelineEntriesTable,
      List<ReadingTimelineEntry>> _readingTimelineEntriesRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.readingTimelineEntries,
          aliasName: $_aliasNameGenerator(
              db.books.id, db.readingTimelineEntries.bookId));

  $$ReadingTimelineEntriesTableProcessedTableManager
      get readingTimelineEntriesRefs {
    final manager = $$ReadingTimelineEntriesTableTableManager(
            $_db, $_db.readingTimelineEntries)
        .filter((f) => f.bookId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_readingTimelineEntriesRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$SharedBooksTable, List<SharedBook>>
      _sharedBooksRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
          db.sharedBooks,
          aliasName: $_aliasNameGenerator(db.books.id, db.sharedBooks.bookId));

  $$SharedBooksTableProcessedTableManager get sharedBooksRefs {
    final manager = $$SharedBooksTableTableManager($_db, $_db.sharedBooks)
        .filter((f) => f.bookId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_sharedBooksRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$LoansTable, List<Loan>> _loansRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.loans,
          aliasName: $_aliasNameGenerator(db.books.id, db.loans.bookId));

  $$LoansTableProcessedTableManager get loansRefs {
    final manager = $$LoansTableTableManager($_db, $_db.loans)
        .filter((f) => f.bookId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_loansRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$BooksTableFilterComposer extends Composer<_$AppDatabase, $BooksTable> {
  $$BooksTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get ownerRemoteId => $composableBuilder(
      column: $table.ownerRemoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get title => $composableBuilder(
      column: $table.title, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get author => $composableBuilder(
      column: $table.author, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get isbn => $composableBuilder(
      column: $table.isbn, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get barcode => $composableBuilder(
      column: $table.barcode, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get coverPath => $composableBuilder(
      column: $table.coverPath, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get readingStatus => $composableBuilder(
      column: $table.readingStatus, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isRead => $composableBuilder(
      column: $table.isRead, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get readAt => $composableBuilder(
      column: $table.readAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isBorrowedExternal => $composableBuilder(
      column: $table.isBorrowedExternal,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get externalLenderName => $composableBuilder(
      column: $table.externalLenderName,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get genre => $composableBuilder(
      column: $table.genre, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isPhysical => $composableBuilder(
      column: $table.isPhysical, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get pageCount => $composableBuilder(
      column: $table.pageCount, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get publicationYear => $composableBuilder(
      column: $table.publicationYear,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $$LocalUsersTableFilterComposer get ownerUserId {
    final $$LocalUsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ownerUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableFilterComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> bookReviewsRefs(
      Expression<bool> Function($$BookReviewsTableFilterComposer f) f) {
    final $$BookReviewsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.bookReviews,
        getReferencedColumn: (t) => t.bookId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BookReviewsTableFilterComposer(
              $db: $db,
              $table: $db.bookReviews,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> readingTimelineEntriesRefs(
      Expression<bool> Function($$ReadingTimelineEntriesTableFilterComposer f)
          f) {
    final $$ReadingTimelineEntriesTableFilterComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.readingTimelineEntries,
            getReferencedColumn: (t) => t.bookId,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$ReadingTimelineEntriesTableFilterComposer(
                  $db: $db,
                  $table: $db.readingTimelineEntries,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<bool> sharedBooksRefs(
      Expression<bool> Function($$SharedBooksTableFilterComposer f) f) {
    final $$SharedBooksTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.sharedBooks,
        getReferencedColumn: (t) => t.bookId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SharedBooksTableFilterComposer(
              $db: $db,
              $table: $db.sharedBooks,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> loansRefs(
      Expression<bool> Function($$LoansTableFilterComposer f) f) {
    final $$LoansTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.loans,
        getReferencedColumn: (t) => t.bookId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LoansTableFilterComposer(
              $db: $db,
              $table: $db.loans,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$BooksTableOrderingComposer
    extends Composer<_$AppDatabase, $BooksTable> {
  $$BooksTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get ownerRemoteId => $composableBuilder(
      column: $table.ownerRemoteId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get title => $composableBuilder(
      column: $table.title, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get author => $composableBuilder(
      column: $table.author, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get isbn => $composableBuilder(
      column: $table.isbn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get barcode => $composableBuilder(
      column: $table.barcode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get coverPath => $composableBuilder(
      column: $table.coverPath, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get readingStatus => $composableBuilder(
      column: $table.readingStatus,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isRead => $composableBuilder(
      column: $table.isRead, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get readAt => $composableBuilder(
      column: $table.readAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isBorrowedExternal => $composableBuilder(
      column: $table.isBorrowedExternal,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get externalLenderName => $composableBuilder(
      column: $table.externalLenderName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get genre => $composableBuilder(
      column: $table.genre, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isPhysical => $composableBuilder(
      column: $table.isPhysical, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get pageCount => $composableBuilder(
      column: $table.pageCount, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get publicationYear => $composableBuilder(
      column: $table.publicationYear,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $$LocalUsersTableOrderingComposer get ownerUserId {
    final $$LocalUsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ownerUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableOrderingComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$BooksTableAnnotationComposer
    extends Composer<_$AppDatabase, $BooksTable> {
  $$BooksTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get remoteId =>
      $composableBuilder(column: $table.remoteId, builder: (column) => column);

  GeneratedColumn<String> get ownerRemoteId => $composableBuilder(
      column: $table.ownerRemoteId, builder: (column) => column);

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<String> get author =>
      $composableBuilder(column: $table.author, builder: (column) => column);

  GeneratedColumn<String> get isbn =>
      $composableBuilder(column: $table.isbn, builder: (column) => column);

  GeneratedColumn<String> get barcode =>
      $composableBuilder(column: $table.barcode, builder: (column) => column);

  GeneratedColumn<String> get coverPath =>
      $composableBuilder(column: $table.coverPath, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => column);

  GeneratedColumn<String> get readingStatus => $composableBuilder(
      column: $table.readingStatus, builder: (column) => column);

  GeneratedColumn<bool> get isRead =>
      $composableBuilder(column: $table.isRead, builder: (column) => column);

  GeneratedColumn<DateTime> get readAt =>
      $composableBuilder(column: $table.readAt, builder: (column) => column);

  GeneratedColumn<bool> get isBorrowedExternal => $composableBuilder(
      column: $table.isBorrowedExternal, builder: (column) => column);

  GeneratedColumn<String> get externalLenderName => $composableBuilder(
      column: $table.externalLenderName, builder: (column) => column);

  GeneratedColumn<String> get genre =>
      $composableBuilder(column: $table.genre, builder: (column) => column);

  GeneratedColumn<bool> get isPhysical => $composableBuilder(
      column: $table.isPhysical, builder: (column) => column);

  GeneratedColumn<int> get pageCount =>
      $composableBuilder(column: $table.pageCount, builder: (column) => column);

  GeneratedColumn<int> get publicationYear => $composableBuilder(
      column: $table.publicationYear, builder: (column) => column);

  GeneratedColumn<bool> get isDirty =>
      $composableBuilder(column: $table.isDirty, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get syncedAt =>
      $composableBuilder(column: $table.syncedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$LocalUsersTableAnnotationComposer get ownerUserId {
    final $$LocalUsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ownerUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableAnnotationComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> bookReviewsRefs<T extends Object>(
      Expression<T> Function($$BookReviewsTableAnnotationComposer a) f) {
    final $$BookReviewsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.bookReviews,
        getReferencedColumn: (t) => t.bookId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BookReviewsTableAnnotationComposer(
              $db: $db,
              $table: $db.bookReviews,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> readingTimelineEntriesRefs<T extends Object>(
      Expression<T> Function($$ReadingTimelineEntriesTableAnnotationComposer a)
          f) {
    final $$ReadingTimelineEntriesTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.readingTimelineEntries,
            getReferencedColumn: (t) => t.bookId,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$ReadingTimelineEntriesTableAnnotationComposer(
                  $db: $db,
                  $table: $db.readingTimelineEntries,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<T> sharedBooksRefs<T extends Object>(
      Expression<T> Function($$SharedBooksTableAnnotationComposer a) f) {
    final $$SharedBooksTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.sharedBooks,
        getReferencedColumn: (t) => t.bookId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SharedBooksTableAnnotationComposer(
              $db: $db,
              $table: $db.sharedBooks,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> loansRefs<T extends Object>(
      Expression<T> Function($$LoansTableAnnotationComposer a) f) {
    final $$LoansTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.loans,
        getReferencedColumn: (t) => t.bookId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LoansTableAnnotationComposer(
              $db: $db,
              $table: $db.loans,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$BooksTableTableManager extends RootTableManager<
    _$AppDatabase,
    $BooksTable,
    Book,
    $$BooksTableFilterComposer,
    $$BooksTableOrderingComposer,
    $$BooksTableAnnotationComposer,
    $$BooksTableCreateCompanionBuilder,
    $$BooksTableUpdateCompanionBuilder,
    (Book, $$BooksTableReferences),
    Book,
    PrefetchHooks Function(
        {bool ownerUserId,
        bool bookReviewsRefs,
        bool readingTimelineEntriesRefs,
        bool sharedBooksRefs,
        bool loansRefs})> {
  $$BooksTableTableManager(_$AppDatabase db, $BooksTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BooksTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BooksTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BooksTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String?> remoteId = const Value.absent(),
            Value<int?> ownerUserId = const Value.absent(),
            Value<String?> ownerRemoteId = const Value.absent(),
            Value<String> title = const Value.absent(),
            Value<String?> author = const Value.absent(),
            Value<String?> isbn = const Value.absent(),
            Value<String?> barcode = const Value.absent(),
            Value<String?> coverPath = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<String> readingStatus = const Value.absent(),
            Value<bool> isRead = const Value.absent(),
            Value<DateTime?> readAt = const Value.absent(),
            Value<bool> isBorrowedExternal = const Value.absent(),
            Value<String?> externalLenderName = const Value.absent(),
            Value<String?> genre = const Value.absent(),
            Value<bool> isPhysical = const Value.absent(),
            Value<int?> pageCount = const Value.absent(),
            Value<int?> publicationYear = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              BooksCompanion(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            ownerUserId: ownerUserId,
            ownerRemoteId: ownerRemoteId,
            title: title,
            author: author,
            isbn: isbn,
            barcode: barcode,
            coverPath: coverPath,
            status: status,
            description: description,
            readingStatus: readingStatus,
            isRead: isRead,
            readAt: readAt,
            isBorrowedExternal: isBorrowedExternal,
            externalLenderName: externalLenderName,
            genre: genre,
            isPhysical: isPhysical,
            pageCount: pageCount,
            publicationYear: publicationYear,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            Value<String?> remoteId = const Value.absent(),
            Value<int?> ownerUserId = const Value.absent(),
            Value<String?> ownerRemoteId = const Value.absent(),
            required String title,
            Value<String?> author = const Value.absent(),
            Value<String?> isbn = const Value.absent(),
            Value<String?> barcode = const Value.absent(),
            Value<String?> coverPath = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<String> readingStatus = const Value.absent(),
            Value<bool> isRead = const Value.absent(),
            Value<DateTime?> readAt = const Value.absent(),
            Value<bool> isBorrowedExternal = const Value.absent(),
            Value<String?> externalLenderName = const Value.absent(),
            Value<String?> genre = const Value.absent(),
            Value<bool> isPhysical = const Value.absent(),
            Value<int?> pageCount = const Value.absent(),
            Value<int?> publicationYear = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              BooksCompanion.insert(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            ownerUserId: ownerUserId,
            ownerRemoteId: ownerRemoteId,
            title: title,
            author: author,
            isbn: isbn,
            barcode: barcode,
            coverPath: coverPath,
            status: status,
            description: description,
            readingStatus: readingStatus,
            isRead: isRead,
            readAt: readAt,
            isBorrowedExternal: isBorrowedExternal,
            externalLenderName: externalLenderName,
            genre: genre,
            isPhysical: isPhysical,
            pageCount: pageCount,
            publicationYear: publicationYear,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $$BooksTableReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: (
              {ownerUserId = false,
              bookReviewsRefs = false,
              readingTimelineEntriesRefs = false,
              sharedBooksRefs = false,
              loansRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (bookReviewsRefs) db.bookReviews,
                if (readingTimelineEntriesRefs) db.readingTimelineEntries,
                if (sharedBooksRefs) db.sharedBooks,
                if (loansRefs) db.loans
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (ownerUserId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.ownerUserId,
                    referencedTable:
                        $$BooksTableReferences._ownerUserIdTable(db),
                    referencedColumn:
                        $$BooksTableReferences._ownerUserIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (bookReviewsRefs)
                    await $_getPrefetchedData<Book, $BooksTable, BookReview>(
                        currentTable: table,
                        referencedTable:
                            $$BooksTableReferences._bookReviewsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$BooksTableReferences(db, table, p0)
                                .bookReviewsRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.bookId == item.id),
                        typedResults: items),
                  if (readingTimelineEntriesRefs)
                    await $_getPrefetchedData<Book, $BooksTable,
                            ReadingTimelineEntry>(
                        currentTable: table,
                        referencedTable: $$BooksTableReferences
                            ._readingTimelineEntriesRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$BooksTableReferences(db, table, p0)
                                .readingTimelineEntriesRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.bookId == item.id),
                        typedResults: items),
                  if (sharedBooksRefs)
                    await $_getPrefetchedData<Book, $BooksTable, SharedBook>(
                        currentTable: table,
                        referencedTable:
                            $$BooksTableReferences._sharedBooksRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$BooksTableReferences(db, table, p0)
                                .sharedBooksRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.bookId == item.id),
                        typedResults: items),
                  if (loansRefs)
                    await $_getPrefetchedData<Book, $BooksTable, Loan>(
                        currentTable: table,
                        referencedTable:
                            $$BooksTableReferences._loansRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$BooksTableReferences(db, table, p0).loansRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.bookId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$BooksTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $BooksTable,
    Book,
    $$BooksTableFilterComposer,
    $$BooksTableOrderingComposer,
    $$BooksTableAnnotationComposer,
    $$BooksTableCreateCompanionBuilder,
    $$BooksTableUpdateCompanionBuilder,
    (Book, $$BooksTableReferences),
    Book,
    PrefetchHooks Function(
        {bool ownerUserId,
        bool bookReviewsRefs,
        bool readingTimelineEntriesRefs,
        bool sharedBooksRefs,
        bool loansRefs})>;
typedef $$BookReviewsTableCreateCompanionBuilder = BookReviewsCompanion
    Function({
  Value<int> id,
  required String uuid,
  Value<String?> remoteId,
  required int bookId,
  required String bookUuid,
  required int authorUserId,
  Value<String?> authorRemoteId,
  required int rating,
  Value<String?> review,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});
typedef $$BookReviewsTableUpdateCompanionBuilder = BookReviewsCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String?> remoteId,
  Value<int> bookId,
  Value<String> bookUuid,
  Value<int> authorUserId,
  Value<String?> authorRemoteId,
  Value<int> rating,
  Value<String?> review,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

final class $$BookReviewsTableReferences
    extends BaseReferences<_$AppDatabase, $BookReviewsTable, BookReview> {
  $$BookReviewsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $BooksTable _bookIdTable(_$AppDatabase db) => db.books
      .createAlias($_aliasNameGenerator(db.bookReviews.bookId, db.books.id));

  $$BooksTableProcessedTableManager get bookId {
    final $_column = $_itemColumn<int>('book_id')!;

    final manager = $$BooksTableTableManager($_db, $_db.books)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bookIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $LocalUsersTable _authorUserIdTable(_$AppDatabase db) =>
      db.localUsers.createAlias(
          $_aliasNameGenerator(db.bookReviews.authorUserId, db.localUsers.id));

  $$LocalUsersTableProcessedTableManager get authorUserId {
    final $_column = $_itemColumn<int>('author_user_id')!;

    final manager = $$LocalUsersTableTableManager($_db, $_db.localUsers)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_authorUserIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$BookReviewsTableFilterComposer
    extends Composer<_$AppDatabase, $BookReviewsTable> {
  $$BookReviewsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get bookUuid => $composableBuilder(
      column: $table.bookUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get authorRemoteId => $composableBuilder(
      column: $table.authorRemoteId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get rating => $composableBuilder(
      column: $table.rating, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get review => $composableBuilder(
      column: $table.review, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $$BooksTableFilterComposer get bookId {
    final $$BooksTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.bookId,
        referencedTable: $db.books,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BooksTableFilterComposer(
              $db: $db,
              $table: $db.books,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableFilterComposer get authorUserId {
    final $$LocalUsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.authorUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableFilterComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$BookReviewsTableOrderingComposer
    extends Composer<_$AppDatabase, $BookReviewsTable> {
  $$BookReviewsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get bookUuid => $composableBuilder(
      column: $table.bookUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get authorRemoteId => $composableBuilder(
      column: $table.authorRemoteId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get rating => $composableBuilder(
      column: $table.rating, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get review => $composableBuilder(
      column: $table.review, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $$BooksTableOrderingComposer get bookId {
    final $$BooksTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.bookId,
        referencedTable: $db.books,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BooksTableOrderingComposer(
              $db: $db,
              $table: $db.books,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableOrderingComposer get authorUserId {
    final $$LocalUsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.authorUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableOrderingComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$BookReviewsTableAnnotationComposer
    extends Composer<_$AppDatabase, $BookReviewsTable> {
  $$BookReviewsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get remoteId =>
      $composableBuilder(column: $table.remoteId, builder: (column) => column);

  GeneratedColumn<String> get bookUuid =>
      $composableBuilder(column: $table.bookUuid, builder: (column) => column);

  GeneratedColumn<String> get authorRemoteId => $composableBuilder(
      column: $table.authorRemoteId, builder: (column) => column);

  GeneratedColumn<int> get rating =>
      $composableBuilder(column: $table.rating, builder: (column) => column);

  GeneratedColumn<String> get review =>
      $composableBuilder(column: $table.review, builder: (column) => column);

  GeneratedColumn<bool> get isDirty =>
      $composableBuilder(column: $table.isDirty, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get syncedAt =>
      $composableBuilder(column: $table.syncedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$BooksTableAnnotationComposer get bookId {
    final $$BooksTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.bookId,
        referencedTable: $db.books,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BooksTableAnnotationComposer(
              $db: $db,
              $table: $db.books,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableAnnotationComposer get authorUserId {
    final $$LocalUsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.authorUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableAnnotationComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$BookReviewsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $BookReviewsTable,
    BookReview,
    $$BookReviewsTableFilterComposer,
    $$BookReviewsTableOrderingComposer,
    $$BookReviewsTableAnnotationComposer,
    $$BookReviewsTableCreateCompanionBuilder,
    $$BookReviewsTableUpdateCompanionBuilder,
    (BookReview, $$BookReviewsTableReferences),
    BookReview,
    PrefetchHooks Function({bool bookId, bool authorUserId})> {
  $$BookReviewsTableTableManager(_$AppDatabase db, $BookReviewsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BookReviewsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BookReviewsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BookReviewsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String?> remoteId = const Value.absent(),
            Value<int> bookId = const Value.absent(),
            Value<String> bookUuid = const Value.absent(),
            Value<int> authorUserId = const Value.absent(),
            Value<String?> authorRemoteId = const Value.absent(),
            Value<int> rating = const Value.absent(),
            Value<String?> review = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              BookReviewsCompanion(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            bookId: bookId,
            bookUuid: bookUuid,
            authorUserId: authorUserId,
            authorRemoteId: authorRemoteId,
            rating: rating,
            review: review,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            Value<String?> remoteId = const Value.absent(),
            required int bookId,
            required String bookUuid,
            required int authorUserId,
            Value<String?> authorRemoteId = const Value.absent(),
            required int rating,
            Value<String?> review = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              BookReviewsCompanion.insert(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            bookId: bookId,
            bookUuid: bookUuid,
            authorUserId: authorUserId,
            authorRemoteId: authorRemoteId,
            rating: rating,
            review: review,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$BookReviewsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({bookId = false, authorUserId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (bookId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.bookId,
                    referencedTable:
                        $$BookReviewsTableReferences._bookIdTable(db),
                    referencedColumn:
                        $$BookReviewsTableReferences._bookIdTable(db).id,
                  ) as T;
                }
                if (authorUserId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.authorUserId,
                    referencedTable:
                        $$BookReviewsTableReferences._authorUserIdTable(db),
                    referencedColumn:
                        $$BookReviewsTableReferences._authorUserIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$BookReviewsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $BookReviewsTable,
    BookReview,
    $$BookReviewsTableFilterComposer,
    $$BookReviewsTableOrderingComposer,
    $$BookReviewsTableAnnotationComposer,
    $$BookReviewsTableCreateCompanionBuilder,
    $$BookReviewsTableUpdateCompanionBuilder,
    (BookReview, $$BookReviewsTableReferences),
    BookReview,
    PrefetchHooks Function({bool bookId, bool authorUserId})>;
typedef $$ReadingTimelineEntriesTableCreateCompanionBuilder
    = ReadingTimelineEntriesCompanion Function({
  Value<int> id,
  required String uuid,
  Value<String?> remoteId,
  required int bookId,
  Value<String?> bookUuid,
  required int ownerUserId,
  Value<int?> currentPage,
  Value<int?> percentageRead,
  required String eventType,
  Value<String?> note,
  Value<DateTime> eventDate,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});
typedef $$ReadingTimelineEntriesTableUpdateCompanionBuilder
    = ReadingTimelineEntriesCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String?> remoteId,
  Value<int> bookId,
  Value<String?> bookUuid,
  Value<int> ownerUserId,
  Value<int?> currentPage,
  Value<int?> percentageRead,
  Value<String> eventType,
  Value<String?> note,
  Value<DateTime> eventDate,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

final class $$ReadingTimelineEntriesTableReferences extends BaseReferences<
    _$AppDatabase, $ReadingTimelineEntriesTable, ReadingTimelineEntry> {
  $$ReadingTimelineEntriesTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $BooksTable _bookIdTable(_$AppDatabase db) => db.books.createAlias(
      $_aliasNameGenerator(db.readingTimelineEntries.bookId, db.books.id));

  $$BooksTableProcessedTableManager get bookId {
    final $_column = $_itemColumn<int>('book_id')!;

    final manager = $$BooksTableTableManager($_db, $_db.books)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bookIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $LocalUsersTable _ownerUserIdTable(_$AppDatabase db) =>
      db.localUsers.createAlias($_aliasNameGenerator(
          db.readingTimelineEntries.ownerUserId, db.localUsers.id));

  $$LocalUsersTableProcessedTableManager get ownerUserId {
    final $_column = $_itemColumn<int>('owner_user_id')!;

    final manager = $$LocalUsersTableTableManager($_db, $_db.localUsers)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_ownerUserIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$ReadingTimelineEntriesTableFilterComposer
    extends Composer<_$AppDatabase, $ReadingTimelineEntriesTable> {
  $$ReadingTimelineEntriesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get bookUuid => $composableBuilder(
      column: $table.bookUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get currentPage => $composableBuilder(
      column: $table.currentPage, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get percentageRead => $composableBuilder(
      column: $table.percentageRead,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get eventType => $composableBuilder(
      column: $table.eventType, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get note => $composableBuilder(
      column: $table.note, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get eventDate => $composableBuilder(
      column: $table.eventDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $$BooksTableFilterComposer get bookId {
    final $$BooksTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.bookId,
        referencedTable: $db.books,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BooksTableFilterComposer(
              $db: $db,
              $table: $db.books,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableFilterComposer get ownerUserId {
    final $$LocalUsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ownerUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableFilterComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ReadingTimelineEntriesTableOrderingComposer
    extends Composer<_$AppDatabase, $ReadingTimelineEntriesTable> {
  $$ReadingTimelineEntriesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get bookUuid => $composableBuilder(
      column: $table.bookUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get currentPage => $composableBuilder(
      column: $table.currentPage, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get percentageRead => $composableBuilder(
      column: $table.percentageRead,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get eventType => $composableBuilder(
      column: $table.eventType, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get note => $composableBuilder(
      column: $table.note, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get eventDate => $composableBuilder(
      column: $table.eventDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $$BooksTableOrderingComposer get bookId {
    final $$BooksTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.bookId,
        referencedTable: $db.books,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BooksTableOrderingComposer(
              $db: $db,
              $table: $db.books,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableOrderingComposer get ownerUserId {
    final $$LocalUsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ownerUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableOrderingComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ReadingTimelineEntriesTableAnnotationComposer
    extends Composer<_$AppDatabase, $ReadingTimelineEntriesTable> {
  $$ReadingTimelineEntriesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get remoteId =>
      $composableBuilder(column: $table.remoteId, builder: (column) => column);

  GeneratedColumn<String> get bookUuid =>
      $composableBuilder(column: $table.bookUuid, builder: (column) => column);

  GeneratedColumn<int> get currentPage => $composableBuilder(
      column: $table.currentPage, builder: (column) => column);

  GeneratedColumn<int> get percentageRead => $composableBuilder(
      column: $table.percentageRead, builder: (column) => column);

  GeneratedColumn<String> get eventType =>
      $composableBuilder(column: $table.eventType, builder: (column) => column);

  GeneratedColumn<String> get note =>
      $composableBuilder(column: $table.note, builder: (column) => column);

  GeneratedColumn<DateTime> get eventDate =>
      $composableBuilder(column: $table.eventDate, builder: (column) => column);

  GeneratedColumn<bool> get isDirty =>
      $composableBuilder(column: $table.isDirty, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get syncedAt =>
      $composableBuilder(column: $table.syncedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$BooksTableAnnotationComposer get bookId {
    final $$BooksTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.bookId,
        referencedTable: $db.books,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BooksTableAnnotationComposer(
              $db: $db,
              $table: $db.books,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableAnnotationComposer get ownerUserId {
    final $$LocalUsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ownerUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableAnnotationComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ReadingTimelineEntriesTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ReadingTimelineEntriesTable,
    ReadingTimelineEntry,
    $$ReadingTimelineEntriesTableFilterComposer,
    $$ReadingTimelineEntriesTableOrderingComposer,
    $$ReadingTimelineEntriesTableAnnotationComposer,
    $$ReadingTimelineEntriesTableCreateCompanionBuilder,
    $$ReadingTimelineEntriesTableUpdateCompanionBuilder,
    (ReadingTimelineEntry, $$ReadingTimelineEntriesTableReferences),
    ReadingTimelineEntry,
    PrefetchHooks Function({bool bookId, bool ownerUserId})> {
  $$ReadingTimelineEntriesTableTableManager(
      _$AppDatabase db, $ReadingTimelineEntriesTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ReadingTimelineEntriesTableFilterComposer(
                  $db: db, $table: table),
          createOrderingComposer: () =>
              $$ReadingTimelineEntriesTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ReadingTimelineEntriesTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String?> remoteId = const Value.absent(),
            Value<int> bookId = const Value.absent(),
            Value<String?> bookUuid = const Value.absent(),
            Value<int> ownerUserId = const Value.absent(),
            Value<int?> currentPage = const Value.absent(),
            Value<int?> percentageRead = const Value.absent(),
            Value<String> eventType = const Value.absent(),
            Value<String?> note = const Value.absent(),
            Value<DateTime> eventDate = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              ReadingTimelineEntriesCompanion(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            bookId: bookId,
            bookUuid: bookUuid,
            ownerUserId: ownerUserId,
            currentPage: currentPage,
            percentageRead: percentageRead,
            eventType: eventType,
            note: note,
            eventDate: eventDate,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            Value<String?> remoteId = const Value.absent(),
            required int bookId,
            Value<String?> bookUuid = const Value.absent(),
            required int ownerUserId,
            Value<int?> currentPage = const Value.absent(),
            Value<int?> percentageRead = const Value.absent(),
            required String eventType,
            Value<String?> note = const Value.absent(),
            Value<DateTime> eventDate = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              ReadingTimelineEntriesCompanion.insert(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            bookId: bookId,
            bookUuid: bookUuid,
            ownerUserId: ownerUserId,
            currentPage: currentPage,
            percentageRead: percentageRead,
            eventType: eventType,
            note: note,
            eventDate: eventDate,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$ReadingTimelineEntriesTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({bookId = false, ownerUserId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (bookId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.bookId,
                    referencedTable: $$ReadingTimelineEntriesTableReferences
                        ._bookIdTable(db),
                    referencedColumn: $$ReadingTimelineEntriesTableReferences
                        ._bookIdTable(db)
                        .id,
                  ) as T;
                }
                if (ownerUserId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.ownerUserId,
                    referencedTable: $$ReadingTimelineEntriesTableReferences
                        ._ownerUserIdTable(db),
                    referencedColumn: $$ReadingTimelineEntriesTableReferences
                        ._ownerUserIdTable(db)
                        .id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$ReadingTimelineEntriesTableProcessedTableManager
    = ProcessedTableManager<
        _$AppDatabase,
        $ReadingTimelineEntriesTable,
        ReadingTimelineEntry,
        $$ReadingTimelineEntriesTableFilterComposer,
        $$ReadingTimelineEntriesTableOrderingComposer,
        $$ReadingTimelineEntriesTableAnnotationComposer,
        $$ReadingTimelineEntriesTableCreateCompanionBuilder,
        $$ReadingTimelineEntriesTableUpdateCompanionBuilder,
        (ReadingTimelineEntry, $$ReadingTimelineEntriesTableReferences),
        ReadingTimelineEntry,
        PrefetchHooks Function({bool bookId, bool ownerUserId})>;
typedef $$GroupsTableCreateCompanionBuilder = GroupsCompanion Function({
  Value<int> id,
  required String uuid,
  Value<String?> remoteId,
  required String name,
  Value<String?> description,
  Value<int?> ownerUserId,
  Value<String?> ownerRemoteId,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});
typedef $$GroupsTableUpdateCompanionBuilder = GroupsCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String?> remoteId,
  Value<String> name,
  Value<String?> description,
  Value<int?> ownerUserId,
  Value<String?> ownerRemoteId,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

final class $$GroupsTableReferences
    extends BaseReferences<_$AppDatabase, $GroupsTable, Group> {
  $$GroupsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $LocalUsersTable _ownerUserIdTable(_$AppDatabase db) =>
      db.localUsers.createAlias(
          $_aliasNameGenerator(db.groups.ownerUserId, db.localUsers.id));

  $$LocalUsersTableProcessedTableManager? get ownerUserId {
    final $_column = $_itemColumn<int>('owner_user_id');
    if ($_column == null) return null;
    final manager = $$LocalUsersTableTableManager($_db, $_db.localUsers)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_ownerUserIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$GroupMembersTable, List<GroupMember>>
      _groupMembersRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.groupMembers,
              aliasName:
                  $_aliasNameGenerator(db.groups.id, db.groupMembers.groupId));

  $$GroupMembersTableProcessedTableManager get groupMembersRefs {
    final manager = $$GroupMembersTableTableManager($_db, $_db.groupMembers)
        .filter((f) => f.groupId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_groupMembersRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$SharedBooksTable, List<SharedBook>>
      _sharedBooksRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.sharedBooks,
              aliasName:
                  $_aliasNameGenerator(db.groups.id, db.sharedBooks.groupId));

  $$SharedBooksTableProcessedTableManager get sharedBooksRefs {
    final manager = $$SharedBooksTableTableManager($_db, $_db.sharedBooks)
        .filter((f) => f.groupId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_sharedBooksRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$GroupInvitationsTable, List<GroupInvitation>>
      _groupInvitationsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.groupInvitations,
              aliasName: $_aliasNameGenerator(
                  db.groups.id, db.groupInvitations.groupId));

  $$GroupInvitationsTableProcessedTableManager get groupInvitationsRefs {
    final manager =
        $$GroupInvitationsTableTableManager($_db, $_db.groupInvitations)
            .filter((f) => f.groupId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_groupInvitationsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$GroupsTableFilterComposer
    extends Composer<_$AppDatabase, $GroupsTable> {
  $$GroupsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get ownerRemoteId => $composableBuilder(
      column: $table.ownerRemoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $$LocalUsersTableFilterComposer get ownerUserId {
    final $$LocalUsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ownerUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableFilterComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> groupMembersRefs(
      Expression<bool> Function($$GroupMembersTableFilterComposer f) f) {
    final $$GroupMembersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.groupMembers,
        getReferencedColumn: (t) => t.groupId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupMembersTableFilterComposer(
              $db: $db,
              $table: $db.groupMembers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> sharedBooksRefs(
      Expression<bool> Function($$SharedBooksTableFilterComposer f) f) {
    final $$SharedBooksTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.sharedBooks,
        getReferencedColumn: (t) => t.groupId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SharedBooksTableFilterComposer(
              $db: $db,
              $table: $db.sharedBooks,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> groupInvitationsRefs(
      Expression<bool> Function($$GroupInvitationsTableFilterComposer f) f) {
    final $$GroupInvitationsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.groupInvitations,
        getReferencedColumn: (t) => t.groupId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupInvitationsTableFilterComposer(
              $db: $db,
              $table: $db.groupInvitations,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$GroupsTableOrderingComposer
    extends Composer<_$AppDatabase, $GroupsTable> {
  $$GroupsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get ownerRemoteId => $composableBuilder(
      column: $table.ownerRemoteId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $$LocalUsersTableOrderingComposer get ownerUserId {
    final $$LocalUsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ownerUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableOrderingComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$GroupsTableAnnotationComposer
    extends Composer<_$AppDatabase, $GroupsTable> {
  $$GroupsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get remoteId =>
      $composableBuilder(column: $table.remoteId, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => column);

  GeneratedColumn<String> get ownerRemoteId => $composableBuilder(
      column: $table.ownerRemoteId, builder: (column) => column);

  GeneratedColumn<bool> get isDirty =>
      $composableBuilder(column: $table.isDirty, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get syncedAt =>
      $composableBuilder(column: $table.syncedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$LocalUsersTableAnnotationComposer get ownerUserId {
    final $$LocalUsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ownerUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableAnnotationComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> groupMembersRefs<T extends Object>(
      Expression<T> Function($$GroupMembersTableAnnotationComposer a) f) {
    final $$GroupMembersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.groupMembers,
        getReferencedColumn: (t) => t.groupId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupMembersTableAnnotationComposer(
              $db: $db,
              $table: $db.groupMembers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> sharedBooksRefs<T extends Object>(
      Expression<T> Function($$SharedBooksTableAnnotationComposer a) f) {
    final $$SharedBooksTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.sharedBooks,
        getReferencedColumn: (t) => t.groupId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SharedBooksTableAnnotationComposer(
              $db: $db,
              $table: $db.sharedBooks,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> groupInvitationsRefs<T extends Object>(
      Expression<T> Function($$GroupInvitationsTableAnnotationComposer a) f) {
    final $$GroupInvitationsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.groupInvitations,
        getReferencedColumn: (t) => t.groupId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupInvitationsTableAnnotationComposer(
              $db: $db,
              $table: $db.groupInvitations,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$GroupsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $GroupsTable,
    Group,
    $$GroupsTableFilterComposer,
    $$GroupsTableOrderingComposer,
    $$GroupsTableAnnotationComposer,
    $$GroupsTableCreateCompanionBuilder,
    $$GroupsTableUpdateCompanionBuilder,
    (Group, $$GroupsTableReferences),
    Group,
    PrefetchHooks Function(
        {bool ownerUserId,
        bool groupMembersRefs,
        bool sharedBooksRefs,
        bool groupInvitationsRefs})> {
  $$GroupsTableTableManager(_$AppDatabase db, $GroupsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GroupsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$GroupsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GroupsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String?> remoteId = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String?> description = const Value.absent(),
            Value<int?> ownerUserId = const Value.absent(),
            Value<String?> ownerRemoteId = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              GroupsCompanion(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            name: name,
            description: description,
            ownerUserId: ownerUserId,
            ownerRemoteId: ownerRemoteId,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            Value<String?> remoteId = const Value.absent(),
            required String name,
            Value<String?> description = const Value.absent(),
            Value<int?> ownerUserId = const Value.absent(),
            Value<String?> ownerRemoteId = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              GroupsCompanion.insert(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            name: name,
            description: description,
            ownerUserId: ownerUserId,
            ownerRemoteId: ownerRemoteId,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $$GroupsTableReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: (
              {ownerUserId = false,
              groupMembersRefs = false,
              sharedBooksRefs = false,
              groupInvitationsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (groupMembersRefs) db.groupMembers,
                if (sharedBooksRefs) db.sharedBooks,
                if (groupInvitationsRefs) db.groupInvitations
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (ownerUserId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.ownerUserId,
                    referencedTable:
                        $$GroupsTableReferences._ownerUserIdTable(db),
                    referencedColumn:
                        $$GroupsTableReferences._ownerUserIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (groupMembersRefs)
                    await $_getPrefetchedData<Group, $GroupsTable, GroupMember>(
                        currentTable: table,
                        referencedTable:
                            $$GroupsTableReferences._groupMembersRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$GroupsTableReferences(db, table, p0)
                                .groupMembersRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.groupId == item.id),
                        typedResults: items),
                  if (sharedBooksRefs)
                    await $_getPrefetchedData<Group, $GroupsTable, SharedBook>(
                        currentTable: table,
                        referencedTable:
                            $$GroupsTableReferences._sharedBooksRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$GroupsTableReferences(db, table, p0)
                                .sharedBooksRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.groupId == item.id),
                        typedResults: items),
                  if (groupInvitationsRefs)
                    await $_getPrefetchedData<Group, $GroupsTable,
                            GroupInvitation>(
                        currentTable: table,
                        referencedTable: $$GroupsTableReferences
                            ._groupInvitationsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$GroupsTableReferences(db, table, p0)
                                .groupInvitationsRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.groupId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$GroupsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $GroupsTable,
    Group,
    $$GroupsTableFilterComposer,
    $$GroupsTableOrderingComposer,
    $$GroupsTableAnnotationComposer,
    $$GroupsTableCreateCompanionBuilder,
    $$GroupsTableUpdateCompanionBuilder,
    (Group, $$GroupsTableReferences),
    Group,
    PrefetchHooks Function(
        {bool ownerUserId,
        bool groupMembersRefs,
        bool sharedBooksRefs,
        bool groupInvitationsRefs})>;
typedef $$GroupMembersTableCreateCompanionBuilder = GroupMembersCompanion
    Function({
  Value<int> id,
  required String uuid,
  Value<String?> remoteId,
  required int groupId,
  required String groupUuid,
  required int memberUserId,
  Value<String?> memberRemoteId,
  Value<String> role,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});
typedef $$GroupMembersTableUpdateCompanionBuilder = GroupMembersCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String?> remoteId,
  Value<int> groupId,
  Value<String> groupUuid,
  Value<int> memberUserId,
  Value<String?> memberRemoteId,
  Value<String> role,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

final class $$GroupMembersTableReferences
    extends BaseReferences<_$AppDatabase, $GroupMembersTable, GroupMember> {
  $$GroupMembersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $GroupsTable _groupIdTable(_$AppDatabase db) => db.groups
      .createAlias($_aliasNameGenerator(db.groupMembers.groupId, db.groups.id));

  $$GroupsTableProcessedTableManager get groupId {
    final $_column = $_itemColumn<int>('group_id')!;

    final manager = $$GroupsTableTableManager($_db, $_db.groups)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_groupIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $LocalUsersTable _memberUserIdTable(_$AppDatabase db) =>
      db.localUsers.createAlias(
          $_aliasNameGenerator(db.groupMembers.memberUserId, db.localUsers.id));

  $$LocalUsersTableProcessedTableManager get memberUserId {
    final $_column = $_itemColumn<int>('member_user_id')!;

    final manager = $$LocalUsersTableTableManager($_db, $_db.localUsers)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_memberUserIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$GroupMembersTableFilterComposer
    extends Composer<_$AppDatabase, $GroupMembersTable> {
  $$GroupMembersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get groupUuid => $composableBuilder(
      column: $table.groupUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get memberRemoteId => $composableBuilder(
      column: $table.memberRemoteId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get role => $composableBuilder(
      column: $table.role, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $$GroupsTableFilterComposer get groupId {
    final $$GroupsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.groupId,
        referencedTable: $db.groups,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupsTableFilterComposer(
              $db: $db,
              $table: $db.groups,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableFilterComposer get memberUserId {
    final $$LocalUsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.memberUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableFilterComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$GroupMembersTableOrderingComposer
    extends Composer<_$AppDatabase, $GroupMembersTable> {
  $$GroupMembersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get groupUuid => $composableBuilder(
      column: $table.groupUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get memberRemoteId => $composableBuilder(
      column: $table.memberRemoteId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get role => $composableBuilder(
      column: $table.role, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $$GroupsTableOrderingComposer get groupId {
    final $$GroupsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.groupId,
        referencedTable: $db.groups,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupsTableOrderingComposer(
              $db: $db,
              $table: $db.groups,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableOrderingComposer get memberUserId {
    final $$LocalUsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.memberUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableOrderingComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$GroupMembersTableAnnotationComposer
    extends Composer<_$AppDatabase, $GroupMembersTable> {
  $$GroupMembersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get remoteId =>
      $composableBuilder(column: $table.remoteId, builder: (column) => column);

  GeneratedColumn<String> get groupUuid =>
      $composableBuilder(column: $table.groupUuid, builder: (column) => column);

  GeneratedColumn<String> get memberRemoteId => $composableBuilder(
      column: $table.memberRemoteId, builder: (column) => column);

  GeneratedColumn<String> get role =>
      $composableBuilder(column: $table.role, builder: (column) => column);

  GeneratedColumn<bool> get isDirty =>
      $composableBuilder(column: $table.isDirty, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get syncedAt =>
      $composableBuilder(column: $table.syncedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$GroupsTableAnnotationComposer get groupId {
    final $$GroupsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.groupId,
        referencedTable: $db.groups,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupsTableAnnotationComposer(
              $db: $db,
              $table: $db.groups,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableAnnotationComposer get memberUserId {
    final $$LocalUsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.memberUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableAnnotationComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$GroupMembersTableTableManager extends RootTableManager<
    _$AppDatabase,
    $GroupMembersTable,
    GroupMember,
    $$GroupMembersTableFilterComposer,
    $$GroupMembersTableOrderingComposer,
    $$GroupMembersTableAnnotationComposer,
    $$GroupMembersTableCreateCompanionBuilder,
    $$GroupMembersTableUpdateCompanionBuilder,
    (GroupMember, $$GroupMembersTableReferences),
    GroupMember,
    PrefetchHooks Function({bool groupId, bool memberUserId})> {
  $$GroupMembersTableTableManager(_$AppDatabase db, $GroupMembersTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GroupMembersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$GroupMembersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GroupMembersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String?> remoteId = const Value.absent(),
            Value<int> groupId = const Value.absent(),
            Value<String> groupUuid = const Value.absent(),
            Value<int> memberUserId = const Value.absent(),
            Value<String?> memberRemoteId = const Value.absent(),
            Value<String> role = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              GroupMembersCompanion(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            groupId: groupId,
            groupUuid: groupUuid,
            memberUserId: memberUserId,
            memberRemoteId: memberRemoteId,
            role: role,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            Value<String?> remoteId = const Value.absent(),
            required int groupId,
            required String groupUuid,
            required int memberUserId,
            Value<String?> memberRemoteId = const Value.absent(),
            Value<String> role = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              GroupMembersCompanion.insert(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            groupId: groupId,
            groupUuid: groupUuid,
            memberUserId: memberUserId,
            memberRemoteId: memberRemoteId,
            role: role,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$GroupMembersTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({groupId = false, memberUserId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (groupId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.groupId,
                    referencedTable:
                        $$GroupMembersTableReferences._groupIdTable(db),
                    referencedColumn:
                        $$GroupMembersTableReferences._groupIdTable(db).id,
                  ) as T;
                }
                if (memberUserId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.memberUserId,
                    referencedTable:
                        $$GroupMembersTableReferences._memberUserIdTable(db),
                    referencedColumn:
                        $$GroupMembersTableReferences._memberUserIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$GroupMembersTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $GroupMembersTable,
    GroupMember,
    $$GroupMembersTableFilterComposer,
    $$GroupMembersTableOrderingComposer,
    $$GroupMembersTableAnnotationComposer,
    $$GroupMembersTableCreateCompanionBuilder,
    $$GroupMembersTableUpdateCompanionBuilder,
    (GroupMember, $$GroupMembersTableReferences),
    GroupMember,
    PrefetchHooks Function({bool groupId, bool memberUserId})>;
typedef $$SharedBooksTableCreateCompanionBuilder = SharedBooksCompanion
    Function({
  Value<int> id,
  required String uuid,
  Value<String?> remoteId,
  required int groupId,
  required String groupUuid,
  required int bookId,
  required String bookUuid,
  required int ownerUserId,
  Value<String?> ownerRemoteId,
  Value<String> visibility,
  Value<bool> isAvailable,
  Value<String?> genre,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});
typedef $$SharedBooksTableUpdateCompanionBuilder = SharedBooksCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String?> remoteId,
  Value<int> groupId,
  Value<String> groupUuid,
  Value<int> bookId,
  Value<String> bookUuid,
  Value<int> ownerUserId,
  Value<String?> ownerRemoteId,
  Value<String> visibility,
  Value<bool> isAvailable,
  Value<String?> genre,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

final class $$SharedBooksTableReferences
    extends BaseReferences<_$AppDatabase, $SharedBooksTable, SharedBook> {
  $$SharedBooksTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $GroupsTable _groupIdTable(_$AppDatabase db) => db.groups
      .createAlias($_aliasNameGenerator(db.sharedBooks.groupId, db.groups.id));

  $$GroupsTableProcessedTableManager get groupId {
    final $_column = $_itemColumn<int>('group_id')!;

    final manager = $$GroupsTableTableManager($_db, $_db.groups)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_groupIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $BooksTable _bookIdTable(_$AppDatabase db) => db.books
      .createAlias($_aliasNameGenerator(db.sharedBooks.bookId, db.books.id));

  $$BooksTableProcessedTableManager get bookId {
    final $_column = $_itemColumn<int>('book_id')!;

    final manager = $$BooksTableTableManager($_db, $_db.books)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bookIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $LocalUsersTable _ownerUserIdTable(_$AppDatabase db) =>
      db.localUsers.createAlias(
          $_aliasNameGenerator(db.sharedBooks.ownerUserId, db.localUsers.id));

  $$LocalUsersTableProcessedTableManager get ownerUserId {
    final $_column = $_itemColumn<int>('owner_user_id')!;

    final manager = $$LocalUsersTableTableManager($_db, $_db.localUsers)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_ownerUserIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$LoansTable, List<Loan>> _loansRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.loans,
          aliasName:
              $_aliasNameGenerator(db.sharedBooks.id, db.loans.sharedBookId));

  $$LoansTableProcessedTableManager get loansRefs {
    final manager = $$LoansTableTableManager($_db, $_db.loans)
        .filter((f) => f.sharedBookId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_loansRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$InAppNotificationsTable, List<InAppNotification>>
      _notificationSharedBooksTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.inAppNotifications,
              aliasName: $_aliasNameGenerator(
                  db.sharedBooks.id, db.inAppNotifications.sharedBookId));

  $$InAppNotificationsTableProcessedTableManager get notificationSharedBooks {
    final manager = $$InAppNotificationsTableTableManager(
            $_db, $_db.inAppNotifications)
        .filter((f) => f.sharedBookId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_notificationSharedBooksTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$SharedBooksTableFilterComposer
    extends Composer<_$AppDatabase, $SharedBooksTable> {
  $$SharedBooksTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get groupUuid => $composableBuilder(
      column: $table.groupUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get bookUuid => $composableBuilder(
      column: $table.bookUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get ownerRemoteId => $composableBuilder(
      column: $table.ownerRemoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get visibility => $composableBuilder(
      column: $table.visibility, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isAvailable => $composableBuilder(
      column: $table.isAvailable, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get genre => $composableBuilder(
      column: $table.genre, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $$GroupsTableFilterComposer get groupId {
    final $$GroupsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.groupId,
        referencedTable: $db.groups,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupsTableFilterComposer(
              $db: $db,
              $table: $db.groups,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$BooksTableFilterComposer get bookId {
    final $$BooksTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.bookId,
        referencedTable: $db.books,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BooksTableFilterComposer(
              $db: $db,
              $table: $db.books,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableFilterComposer get ownerUserId {
    final $$LocalUsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ownerUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableFilterComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> loansRefs(
      Expression<bool> Function($$LoansTableFilterComposer f) f) {
    final $$LoansTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.loans,
        getReferencedColumn: (t) => t.sharedBookId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LoansTableFilterComposer(
              $db: $db,
              $table: $db.loans,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> notificationSharedBooks(
      Expression<bool> Function($$InAppNotificationsTableFilterComposer f) f) {
    final $$InAppNotificationsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.inAppNotifications,
        getReferencedColumn: (t) => t.sharedBookId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$InAppNotificationsTableFilterComposer(
              $db: $db,
              $table: $db.inAppNotifications,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$SharedBooksTableOrderingComposer
    extends Composer<_$AppDatabase, $SharedBooksTable> {
  $$SharedBooksTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get groupUuid => $composableBuilder(
      column: $table.groupUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get bookUuid => $composableBuilder(
      column: $table.bookUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get ownerRemoteId => $composableBuilder(
      column: $table.ownerRemoteId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get visibility => $composableBuilder(
      column: $table.visibility, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isAvailable => $composableBuilder(
      column: $table.isAvailable, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get genre => $composableBuilder(
      column: $table.genre, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $$GroupsTableOrderingComposer get groupId {
    final $$GroupsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.groupId,
        referencedTable: $db.groups,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupsTableOrderingComposer(
              $db: $db,
              $table: $db.groups,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$BooksTableOrderingComposer get bookId {
    final $$BooksTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.bookId,
        referencedTable: $db.books,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BooksTableOrderingComposer(
              $db: $db,
              $table: $db.books,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableOrderingComposer get ownerUserId {
    final $$LocalUsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ownerUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableOrderingComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$SharedBooksTableAnnotationComposer
    extends Composer<_$AppDatabase, $SharedBooksTable> {
  $$SharedBooksTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get remoteId =>
      $composableBuilder(column: $table.remoteId, builder: (column) => column);

  GeneratedColumn<String> get groupUuid =>
      $composableBuilder(column: $table.groupUuid, builder: (column) => column);

  GeneratedColumn<String> get bookUuid =>
      $composableBuilder(column: $table.bookUuid, builder: (column) => column);

  GeneratedColumn<String> get ownerRemoteId => $composableBuilder(
      column: $table.ownerRemoteId, builder: (column) => column);

  GeneratedColumn<String> get visibility => $composableBuilder(
      column: $table.visibility, builder: (column) => column);

  GeneratedColumn<bool> get isAvailable => $composableBuilder(
      column: $table.isAvailable, builder: (column) => column);

  GeneratedColumn<String> get genre =>
      $composableBuilder(column: $table.genre, builder: (column) => column);

  GeneratedColumn<bool> get isDirty =>
      $composableBuilder(column: $table.isDirty, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get syncedAt =>
      $composableBuilder(column: $table.syncedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$GroupsTableAnnotationComposer get groupId {
    final $$GroupsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.groupId,
        referencedTable: $db.groups,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupsTableAnnotationComposer(
              $db: $db,
              $table: $db.groups,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$BooksTableAnnotationComposer get bookId {
    final $$BooksTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.bookId,
        referencedTable: $db.books,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BooksTableAnnotationComposer(
              $db: $db,
              $table: $db.books,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableAnnotationComposer get ownerUserId {
    final $$LocalUsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ownerUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableAnnotationComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> loansRefs<T extends Object>(
      Expression<T> Function($$LoansTableAnnotationComposer a) f) {
    final $$LoansTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.loans,
        getReferencedColumn: (t) => t.sharedBookId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LoansTableAnnotationComposer(
              $db: $db,
              $table: $db.loans,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> notificationSharedBooks<T extends Object>(
      Expression<T> Function($$InAppNotificationsTableAnnotationComposer a) f) {
    final $$InAppNotificationsTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.inAppNotifications,
            getReferencedColumn: (t) => t.sharedBookId,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$InAppNotificationsTableAnnotationComposer(
                  $db: $db,
                  $table: $db.inAppNotifications,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$SharedBooksTableTableManager extends RootTableManager<
    _$AppDatabase,
    $SharedBooksTable,
    SharedBook,
    $$SharedBooksTableFilterComposer,
    $$SharedBooksTableOrderingComposer,
    $$SharedBooksTableAnnotationComposer,
    $$SharedBooksTableCreateCompanionBuilder,
    $$SharedBooksTableUpdateCompanionBuilder,
    (SharedBook, $$SharedBooksTableReferences),
    SharedBook,
    PrefetchHooks Function(
        {bool groupId,
        bool bookId,
        bool ownerUserId,
        bool loansRefs,
        bool notificationSharedBooks})> {
  $$SharedBooksTableTableManager(_$AppDatabase db, $SharedBooksTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SharedBooksTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SharedBooksTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SharedBooksTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String?> remoteId = const Value.absent(),
            Value<int> groupId = const Value.absent(),
            Value<String> groupUuid = const Value.absent(),
            Value<int> bookId = const Value.absent(),
            Value<String> bookUuid = const Value.absent(),
            Value<int> ownerUserId = const Value.absent(),
            Value<String?> ownerRemoteId = const Value.absent(),
            Value<String> visibility = const Value.absent(),
            Value<bool> isAvailable = const Value.absent(),
            Value<String?> genre = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              SharedBooksCompanion(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            groupId: groupId,
            groupUuid: groupUuid,
            bookId: bookId,
            bookUuid: bookUuid,
            ownerUserId: ownerUserId,
            ownerRemoteId: ownerRemoteId,
            visibility: visibility,
            isAvailable: isAvailable,
            genre: genre,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            Value<String?> remoteId = const Value.absent(),
            required int groupId,
            required String groupUuid,
            required int bookId,
            required String bookUuid,
            required int ownerUserId,
            Value<String?> ownerRemoteId = const Value.absent(),
            Value<String> visibility = const Value.absent(),
            Value<bool> isAvailable = const Value.absent(),
            Value<String?> genre = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              SharedBooksCompanion.insert(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            groupId: groupId,
            groupUuid: groupUuid,
            bookId: bookId,
            bookUuid: bookUuid,
            ownerUserId: ownerUserId,
            ownerRemoteId: ownerRemoteId,
            visibility: visibility,
            isAvailable: isAvailable,
            genre: genre,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$SharedBooksTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {groupId = false,
              bookId = false,
              ownerUserId = false,
              loansRefs = false,
              notificationSharedBooks = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (loansRefs) db.loans,
                if (notificationSharedBooks) db.inAppNotifications
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (groupId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.groupId,
                    referencedTable:
                        $$SharedBooksTableReferences._groupIdTable(db),
                    referencedColumn:
                        $$SharedBooksTableReferences._groupIdTable(db).id,
                  ) as T;
                }
                if (bookId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.bookId,
                    referencedTable:
                        $$SharedBooksTableReferences._bookIdTable(db),
                    referencedColumn:
                        $$SharedBooksTableReferences._bookIdTable(db).id,
                  ) as T;
                }
                if (ownerUserId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.ownerUserId,
                    referencedTable:
                        $$SharedBooksTableReferences._ownerUserIdTable(db),
                    referencedColumn:
                        $$SharedBooksTableReferences._ownerUserIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (loansRefs)
                    await $_getPrefetchedData<SharedBook, $SharedBooksTable,
                            Loan>(
                        currentTable: table,
                        referencedTable:
                            $$SharedBooksTableReferences._loansRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$SharedBooksTableReferences(db, table, p0)
                                .loansRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.sharedBookId == item.id),
                        typedResults: items),
                  if (notificationSharedBooks)
                    await $_getPrefetchedData<SharedBook, $SharedBooksTable,
                            InAppNotification>(
                        currentTable: table,
                        referencedTable: $$SharedBooksTableReferences
                            ._notificationSharedBooksTable(db),
                        managerFromTypedResult: (p0) =>
                            $$SharedBooksTableReferences(db, table, p0)
                                .notificationSharedBooks,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.sharedBookId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$SharedBooksTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $SharedBooksTable,
    SharedBook,
    $$SharedBooksTableFilterComposer,
    $$SharedBooksTableOrderingComposer,
    $$SharedBooksTableAnnotationComposer,
    $$SharedBooksTableCreateCompanionBuilder,
    $$SharedBooksTableUpdateCompanionBuilder,
    (SharedBook, $$SharedBooksTableReferences),
    SharedBook,
    PrefetchHooks Function(
        {bool groupId,
        bool bookId,
        bool ownerUserId,
        bool loansRefs,
        bool notificationSharedBooks})>;
typedef $$GroupInvitationsTableCreateCompanionBuilder
    = GroupInvitationsCompanion Function({
  Value<int> id,
  required String uuid,
  Value<String?> remoteId,
  required int groupId,
  required String groupUuid,
  required int inviterUserId,
  Value<String?> inviterRemoteId,
  Value<int?> acceptedUserId,
  Value<String?> acceptedUserRemoteId,
  Value<String> role,
  required String code,
  Value<String> status,
  required DateTime expiresAt,
  Value<DateTime?> respondedAt,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});
typedef $$GroupInvitationsTableUpdateCompanionBuilder
    = GroupInvitationsCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String?> remoteId,
  Value<int> groupId,
  Value<String> groupUuid,
  Value<int> inviterUserId,
  Value<String?> inviterRemoteId,
  Value<int?> acceptedUserId,
  Value<String?> acceptedUserRemoteId,
  Value<String> role,
  Value<String> code,
  Value<String> status,
  Value<DateTime> expiresAt,
  Value<DateTime?> respondedAt,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

final class $$GroupInvitationsTableReferences extends BaseReferences<
    _$AppDatabase, $GroupInvitationsTable, GroupInvitation> {
  $$GroupInvitationsTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $GroupsTable _groupIdTable(_$AppDatabase db) => db.groups.createAlias(
      $_aliasNameGenerator(db.groupInvitations.groupId, db.groups.id));

  $$GroupsTableProcessedTableManager get groupId {
    final $_column = $_itemColumn<int>('group_id')!;

    final manager = $$GroupsTableTableManager($_db, $_db.groups)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_groupIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $LocalUsersTable _inviterUserIdTable(_$AppDatabase db) =>
      db.localUsers.createAlias($_aliasNameGenerator(
          db.groupInvitations.inviterUserId, db.localUsers.id));

  $$LocalUsersTableProcessedTableManager get inviterUserId {
    final $_column = $_itemColumn<int>('inviter_user_id')!;

    final manager = $$LocalUsersTableTableManager($_db, $_db.localUsers)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_inviterUserIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $LocalUsersTable _acceptedUserIdTable(_$AppDatabase db) =>
      db.localUsers.createAlias($_aliasNameGenerator(
          db.groupInvitations.acceptedUserId, db.localUsers.id));

  $$LocalUsersTableProcessedTableManager? get acceptedUserId {
    final $_column = $_itemColumn<int>('accepted_user_id');
    if ($_column == null) return null;
    final manager = $$LocalUsersTableTableManager($_db, $_db.localUsers)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_acceptedUserIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$GroupInvitationsTableFilterComposer
    extends Composer<_$AppDatabase, $GroupInvitationsTable> {
  $$GroupInvitationsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get groupUuid => $composableBuilder(
      column: $table.groupUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get inviterRemoteId => $composableBuilder(
      column: $table.inviterRemoteId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get acceptedUserRemoteId => $composableBuilder(
      column: $table.acceptedUserRemoteId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get role => $composableBuilder(
      column: $table.role, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get expiresAt => $composableBuilder(
      column: $table.expiresAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get respondedAt => $composableBuilder(
      column: $table.respondedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $$GroupsTableFilterComposer get groupId {
    final $$GroupsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.groupId,
        referencedTable: $db.groups,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupsTableFilterComposer(
              $db: $db,
              $table: $db.groups,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableFilterComposer get inviterUserId {
    final $$LocalUsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.inviterUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableFilterComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableFilterComposer get acceptedUserId {
    final $$LocalUsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.acceptedUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableFilterComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$GroupInvitationsTableOrderingComposer
    extends Composer<_$AppDatabase, $GroupInvitationsTable> {
  $$GroupInvitationsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get groupUuid => $composableBuilder(
      column: $table.groupUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get inviterRemoteId => $composableBuilder(
      column: $table.inviterRemoteId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get acceptedUserRemoteId => $composableBuilder(
      column: $table.acceptedUserRemoteId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get role => $composableBuilder(
      column: $table.role, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get code => $composableBuilder(
      column: $table.code, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get expiresAt => $composableBuilder(
      column: $table.expiresAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get respondedAt => $composableBuilder(
      column: $table.respondedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $$GroupsTableOrderingComposer get groupId {
    final $$GroupsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.groupId,
        referencedTable: $db.groups,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupsTableOrderingComposer(
              $db: $db,
              $table: $db.groups,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableOrderingComposer get inviterUserId {
    final $$LocalUsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.inviterUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableOrderingComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableOrderingComposer get acceptedUserId {
    final $$LocalUsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.acceptedUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableOrderingComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$GroupInvitationsTableAnnotationComposer
    extends Composer<_$AppDatabase, $GroupInvitationsTable> {
  $$GroupInvitationsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get remoteId =>
      $composableBuilder(column: $table.remoteId, builder: (column) => column);

  GeneratedColumn<String> get groupUuid =>
      $composableBuilder(column: $table.groupUuid, builder: (column) => column);

  GeneratedColumn<String> get inviterRemoteId => $composableBuilder(
      column: $table.inviterRemoteId, builder: (column) => column);

  GeneratedColumn<String> get acceptedUserRemoteId => $composableBuilder(
      column: $table.acceptedUserRemoteId, builder: (column) => column);

  GeneratedColumn<String> get role =>
      $composableBuilder(column: $table.role, builder: (column) => column);

  GeneratedColumn<String> get code =>
      $composableBuilder(column: $table.code, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get expiresAt =>
      $composableBuilder(column: $table.expiresAt, builder: (column) => column);

  GeneratedColumn<DateTime> get respondedAt => $composableBuilder(
      column: $table.respondedAt, builder: (column) => column);

  GeneratedColumn<bool> get isDirty =>
      $composableBuilder(column: $table.isDirty, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get syncedAt =>
      $composableBuilder(column: $table.syncedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$GroupsTableAnnotationComposer get groupId {
    final $$GroupsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.groupId,
        referencedTable: $db.groups,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$GroupsTableAnnotationComposer(
              $db: $db,
              $table: $db.groups,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableAnnotationComposer get inviterUserId {
    final $$LocalUsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.inviterUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableAnnotationComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableAnnotationComposer get acceptedUserId {
    final $$LocalUsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.acceptedUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableAnnotationComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$GroupInvitationsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $GroupInvitationsTable,
    GroupInvitation,
    $$GroupInvitationsTableFilterComposer,
    $$GroupInvitationsTableOrderingComposer,
    $$GroupInvitationsTableAnnotationComposer,
    $$GroupInvitationsTableCreateCompanionBuilder,
    $$GroupInvitationsTableUpdateCompanionBuilder,
    (GroupInvitation, $$GroupInvitationsTableReferences),
    GroupInvitation,
    PrefetchHooks Function(
        {bool groupId, bool inviterUserId, bool acceptedUserId})> {
  $$GroupInvitationsTableTableManager(
      _$AppDatabase db, $GroupInvitationsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GroupInvitationsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$GroupInvitationsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GroupInvitationsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String?> remoteId = const Value.absent(),
            Value<int> groupId = const Value.absent(),
            Value<String> groupUuid = const Value.absent(),
            Value<int> inviterUserId = const Value.absent(),
            Value<String?> inviterRemoteId = const Value.absent(),
            Value<int?> acceptedUserId = const Value.absent(),
            Value<String?> acceptedUserRemoteId = const Value.absent(),
            Value<String> role = const Value.absent(),
            Value<String> code = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<DateTime> expiresAt = const Value.absent(),
            Value<DateTime?> respondedAt = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              GroupInvitationsCompanion(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            groupId: groupId,
            groupUuid: groupUuid,
            inviterUserId: inviterUserId,
            inviterRemoteId: inviterRemoteId,
            acceptedUserId: acceptedUserId,
            acceptedUserRemoteId: acceptedUserRemoteId,
            role: role,
            code: code,
            status: status,
            expiresAt: expiresAt,
            respondedAt: respondedAt,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            Value<String?> remoteId = const Value.absent(),
            required int groupId,
            required String groupUuid,
            required int inviterUserId,
            Value<String?> inviterRemoteId = const Value.absent(),
            Value<int?> acceptedUserId = const Value.absent(),
            Value<String?> acceptedUserRemoteId = const Value.absent(),
            Value<String> role = const Value.absent(),
            required String code,
            Value<String> status = const Value.absent(),
            required DateTime expiresAt,
            Value<DateTime?> respondedAt = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              GroupInvitationsCompanion.insert(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            groupId: groupId,
            groupUuid: groupUuid,
            inviterUserId: inviterUserId,
            inviterRemoteId: inviterRemoteId,
            acceptedUserId: acceptedUserId,
            acceptedUserRemoteId: acceptedUserRemoteId,
            role: role,
            code: code,
            status: status,
            expiresAt: expiresAt,
            respondedAt: respondedAt,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$GroupInvitationsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {groupId = false,
              inviterUserId = false,
              acceptedUserId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (groupId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.groupId,
                    referencedTable:
                        $$GroupInvitationsTableReferences._groupIdTable(db),
                    referencedColumn:
                        $$GroupInvitationsTableReferences._groupIdTable(db).id,
                  ) as T;
                }
                if (inviterUserId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.inviterUserId,
                    referencedTable: $$GroupInvitationsTableReferences
                        ._inviterUserIdTable(db),
                    referencedColumn: $$GroupInvitationsTableReferences
                        ._inviterUserIdTable(db)
                        .id,
                  ) as T;
                }
                if (acceptedUserId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.acceptedUserId,
                    referencedTable: $$GroupInvitationsTableReferences
                        ._acceptedUserIdTable(db),
                    referencedColumn: $$GroupInvitationsTableReferences
                        ._acceptedUserIdTable(db)
                        .id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$GroupInvitationsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $GroupInvitationsTable,
    GroupInvitation,
    $$GroupInvitationsTableFilterComposer,
    $$GroupInvitationsTableOrderingComposer,
    $$GroupInvitationsTableAnnotationComposer,
    $$GroupInvitationsTableCreateCompanionBuilder,
    $$GroupInvitationsTableUpdateCompanionBuilder,
    (GroupInvitation, $$GroupInvitationsTableReferences),
    GroupInvitation,
    PrefetchHooks Function(
        {bool groupId, bool inviterUserId, bool acceptedUserId})>;
typedef $$LoansTableCreateCompanionBuilder = LoansCompanion Function({
  Value<int> id,
  required String uuid,
  Value<String?> remoteId,
  Value<int?> sharedBookId,
  Value<int?> bookId,
  Value<int?> borrowerUserId,
  required int lenderUserId,
  Value<String?> externalBorrowerName,
  Value<String?> externalBorrowerContact,
  Value<String> status,
  Value<DateTime> requestedAt,
  Value<DateTime?> approvedAt,
  Value<DateTime?> dueDate,
  Value<DateTime?> borrowerReturnedAt,
  Value<DateTime?> lenderReturnedAt,
  Value<DateTime?> returnedAt,
  Value<bool?> wasRead,
  Value<DateTime?> markedReadAt,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});
typedef $$LoansTableUpdateCompanionBuilder = LoansCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String?> remoteId,
  Value<int?> sharedBookId,
  Value<int?> bookId,
  Value<int?> borrowerUserId,
  Value<int> lenderUserId,
  Value<String?> externalBorrowerName,
  Value<String?> externalBorrowerContact,
  Value<String> status,
  Value<DateTime> requestedAt,
  Value<DateTime?> approvedAt,
  Value<DateTime?> dueDate,
  Value<DateTime?> borrowerReturnedAt,
  Value<DateTime?> lenderReturnedAt,
  Value<DateTime?> returnedAt,
  Value<bool?> wasRead,
  Value<DateTime?> markedReadAt,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

final class $$LoansTableReferences
    extends BaseReferences<_$AppDatabase, $LoansTable, Loan> {
  $$LoansTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $SharedBooksTable _sharedBookIdTable(_$AppDatabase db) =>
      db.sharedBooks.createAlias(
          $_aliasNameGenerator(db.loans.sharedBookId, db.sharedBooks.id));

  $$SharedBooksTableProcessedTableManager? get sharedBookId {
    final $_column = $_itemColumn<int>('shared_book_id');
    if ($_column == null) return null;
    final manager = $$SharedBooksTableTableManager($_db, $_db.sharedBooks)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_sharedBookIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $BooksTable _bookIdTable(_$AppDatabase db) =>
      db.books.createAlias($_aliasNameGenerator(db.loans.bookId, db.books.id));

  $$BooksTableProcessedTableManager? get bookId {
    final $_column = $_itemColumn<int>('book_id');
    if ($_column == null) return null;
    final manager = $$BooksTableTableManager($_db, $_db.books)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bookIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $LocalUsersTable _borrowerUserIdTable(_$AppDatabase db) =>
      db.localUsers.createAlias(
          $_aliasNameGenerator(db.loans.borrowerUserId, db.localUsers.id));

  $$LocalUsersTableProcessedTableManager? get borrowerUserId {
    final $_column = $_itemColumn<int>('borrower_user_id');
    if ($_column == null) return null;
    final manager = $$LocalUsersTableTableManager($_db, $_db.localUsers)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_borrowerUserIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $LocalUsersTable _lenderUserIdTable(_$AppDatabase db) =>
      db.localUsers.createAlias(
          $_aliasNameGenerator(db.loans.lenderUserId, db.localUsers.id));

  $$LocalUsersTableProcessedTableManager get lenderUserId {
    final $_column = $_itemColumn<int>('lender_user_id')!;

    final manager = $$LocalUsersTableTableManager($_db, $_db.localUsers)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_lenderUserIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$InAppNotificationsTable, List<InAppNotification>>
      _notificationLoansTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.inAppNotifications,
              aliasName: $_aliasNameGenerator(
                  db.loans.id, db.inAppNotifications.loanId));

  $$InAppNotificationsTableProcessedTableManager get notificationLoans {
    final manager =
        $$InAppNotificationsTableTableManager($_db, $_db.inAppNotifications)
            .filter((f) => f.loanId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_notificationLoansTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$LoansTableFilterComposer extends Composer<_$AppDatabase, $LoansTable> {
  $$LoansTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get externalBorrowerName => $composableBuilder(
      column: $table.externalBorrowerName,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get externalBorrowerContact => $composableBuilder(
      column: $table.externalBorrowerContact,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get requestedAt => $composableBuilder(
      column: $table.requestedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get approvedAt => $composableBuilder(
      column: $table.approvedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get dueDate => $composableBuilder(
      column: $table.dueDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get borrowerReturnedAt => $composableBuilder(
      column: $table.borrowerReturnedAt,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lenderReturnedAt => $composableBuilder(
      column: $table.lenderReturnedAt,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get returnedAt => $composableBuilder(
      column: $table.returnedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get wasRead => $composableBuilder(
      column: $table.wasRead, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get markedReadAt => $composableBuilder(
      column: $table.markedReadAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $$SharedBooksTableFilterComposer get sharedBookId {
    final $$SharedBooksTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.sharedBookId,
        referencedTable: $db.sharedBooks,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SharedBooksTableFilterComposer(
              $db: $db,
              $table: $db.sharedBooks,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$BooksTableFilterComposer get bookId {
    final $$BooksTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.bookId,
        referencedTable: $db.books,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BooksTableFilterComposer(
              $db: $db,
              $table: $db.books,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableFilterComposer get borrowerUserId {
    final $$LocalUsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.borrowerUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableFilterComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableFilterComposer get lenderUserId {
    final $$LocalUsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.lenderUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableFilterComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> notificationLoans(
      Expression<bool> Function($$InAppNotificationsTableFilterComposer f) f) {
    final $$InAppNotificationsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.inAppNotifications,
        getReferencedColumn: (t) => t.loanId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$InAppNotificationsTableFilterComposer(
              $db: $db,
              $table: $db.inAppNotifications,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$LoansTableOrderingComposer
    extends Composer<_$AppDatabase, $LoansTable> {
  $$LoansTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get externalBorrowerName => $composableBuilder(
      column: $table.externalBorrowerName,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get externalBorrowerContact => $composableBuilder(
      column: $table.externalBorrowerContact,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get requestedAt => $composableBuilder(
      column: $table.requestedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get approvedAt => $composableBuilder(
      column: $table.approvedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get dueDate => $composableBuilder(
      column: $table.dueDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get borrowerReturnedAt => $composableBuilder(
      column: $table.borrowerReturnedAt,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lenderReturnedAt => $composableBuilder(
      column: $table.lenderReturnedAt,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get returnedAt => $composableBuilder(
      column: $table.returnedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get wasRead => $composableBuilder(
      column: $table.wasRead, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get markedReadAt => $composableBuilder(
      column: $table.markedReadAt,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $$SharedBooksTableOrderingComposer get sharedBookId {
    final $$SharedBooksTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.sharedBookId,
        referencedTable: $db.sharedBooks,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SharedBooksTableOrderingComposer(
              $db: $db,
              $table: $db.sharedBooks,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$BooksTableOrderingComposer get bookId {
    final $$BooksTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.bookId,
        referencedTable: $db.books,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BooksTableOrderingComposer(
              $db: $db,
              $table: $db.books,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableOrderingComposer get borrowerUserId {
    final $$LocalUsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.borrowerUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableOrderingComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableOrderingComposer get lenderUserId {
    final $$LocalUsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.lenderUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableOrderingComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$LoansTableAnnotationComposer
    extends Composer<_$AppDatabase, $LoansTable> {
  $$LoansTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get remoteId =>
      $composableBuilder(column: $table.remoteId, builder: (column) => column);

  GeneratedColumn<String> get externalBorrowerName => $composableBuilder(
      column: $table.externalBorrowerName, builder: (column) => column);

  GeneratedColumn<String> get externalBorrowerContact => $composableBuilder(
      column: $table.externalBorrowerContact, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get requestedAt => $composableBuilder(
      column: $table.requestedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get approvedAt => $composableBuilder(
      column: $table.approvedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get dueDate =>
      $composableBuilder(column: $table.dueDate, builder: (column) => column);

  GeneratedColumn<DateTime> get borrowerReturnedAt => $composableBuilder(
      column: $table.borrowerReturnedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lenderReturnedAt => $composableBuilder(
      column: $table.lenderReturnedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get returnedAt => $composableBuilder(
      column: $table.returnedAt, builder: (column) => column);

  GeneratedColumn<bool> get wasRead =>
      $composableBuilder(column: $table.wasRead, builder: (column) => column);

  GeneratedColumn<DateTime> get markedReadAt => $composableBuilder(
      column: $table.markedReadAt, builder: (column) => column);

  GeneratedColumn<bool> get isDirty =>
      $composableBuilder(column: $table.isDirty, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get syncedAt =>
      $composableBuilder(column: $table.syncedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$SharedBooksTableAnnotationComposer get sharedBookId {
    final $$SharedBooksTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.sharedBookId,
        referencedTable: $db.sharedBooks,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SharedBooksTableAnnotationComposer(
              $db: $db,
              $table: $db.sharedBooks,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$BooksTableAnnotationComposer get bookId {
    final $$BooksTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.bookId,
        referencedTable: $db.books,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BooksTableAnnotationComposer(
              $db: $db,
              $table: $db.books,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableAnnotationComposer get borrowerUserId {
    final $$LocalUsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.borrowerUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableAnnotationComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableAnnotationComposer get lenderUserId {
    final $$LocalUsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.lenderUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableAnnotationComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> notificationLoans<T extends Object>(
      Expression<T> Function($$InAppNotificationsTableAnnotationComposer a) f) {
    final $$InAppNotificationsTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.inAppNotifications,
            getReferencedColumn: (t) => t.loanId,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$InAppNotificationsTableAnnotationComposer(
                  $db: $db,
                  $table: $db.inAppNotifications,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }
}

class $$LoansTableTableManager extends RootTableManager<
    _$AppDatabase,
    $LoansTable,
    Loan,
    $$LoansTableFilterComposer,
    $$LoansTableOrderingComposer,
    $$LoansTableAnnotationComposer,
    $$LoansTableCreateCompanionBuilder,
    $$LoansTableUpdateCompanionBuilder,
    (Loan, $$LoansTableReferences),
    Loan,
    PrefetchHooks Function(
        {bool sharedBookId,
        bool bookId,
        bool borrowerUserId,
        bool lenderUserId,
        bool notificationLoans})> {
  $$LoansTableTableManager(_$AppDatabase db, $LoansTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$LoansTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$LoansTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$LoansTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String?> remoteId = const Value.absent(),
            Value<int?> sharedBookId = const Value.absent(),
            Value<int?> bookId = const Value.absent(),
            Value<int?> borrowerUserId = const Value.absent(),
            Value<int> lenderUserId = const Value.absent(),
            Value<String?> externalBorrowerName = const Value.absent(),
            Value<String?> externalBorrowerContact = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<DateTime> requestedAt = const Value.absent(),
            Value<DateTime?> approvedAt = const Value.absent(),
            Value<DateTime?> dueDate = const Value.absent(),
            Value<DateTime?> borrowerReturnedAt = const Value.absent(),
            Value<DateTime?> lenderReturnedAt = const Value.absent(),
            Value<DateTime?> returnedAt = const Value.absent(),
            Value<bool?> wasRead = const Value.absent(),
            Value<DateTime?> markedReadAt = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              LoansCompanion(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            sharedBookId: sharedBookId,
            bookId: bookId,
            borrowerUserId: borrowerUserId,
            lenderUserId: lenderUserId,
            externalBorrowerName: externalBorrowerName,
            externalBorrowerContact: externalBorrowerContact,
            status: status,
            requestedAt: requestedAt,
            approvedAt: approvedAt,
            dueDate: dueDate,
            borrowerReturnedAt: borrowerReturnedAt,
            lenderReturnedAt: lenderReturnedAt,
            returnedAt: returnedAt,
            wasRead: wasRead,
            markedReadAt: markedReadAt,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            Value<String?> remoteId = const Value.absent(),
            Value<int?> sharedBookId = const Value.absent(),
            Value<int?> bookId = const Value.absent(),
            Value<int?> borrowerUserId = const Value.absent(),
            required int lenderUserId,
            Value<String?> externalBorrowerName = const Value.absent(),
            Value<String?> externalBorrowerContact = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<DateTime> requestedAt = const Value.absent(),
            Value<DateTime?> approvedAt = const Value.absent(),
            Value<DateTime?> dueDate = const Value.absent(),
            Value<DateTime?> borrowerReturnedAt = const Value.absent(),
            Value<DateTime?> lenderReturnedAt = const Value.absent(),
            Value<DateTime?> returnedAt = const Value.absent(),
            Value<bool?> wasRead = const Value.absent(),
            Value<DateTime?> markedReadAt = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              LoansCompanion.insert(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            sharedBookId: sharedBookId,
            bookId: bookId,
            borrowerUserId: borrowerUserId,
            lenderUserId: lenderUserId,
            externalBorrowerName: externalBorrowerName,
            externalBorrowerContact: externalBorrowerContact,
            status: status,
            requestedAt: requestedAt,
            approvedAt: approvedAt,
            dueDate: dueDate,
            borrowerReturnedAt: borrowerReturnedAt,
            lenderReturnedAt: lenderReturnedAt,
            returnedAt: returnedAt,
            wasRead: wasRead,
            markedReadAt: markedReadAt,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) =>
                  (e.readTable(table), $$LoansTableReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: (
              {sharedBookId = false,
              bookId = false,
              borrowerUserId = false,
              lenderUserId = false,
              notificationLoans = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (notificationLoans) db.inAppNotifications
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (sharedBookId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.sharedBookId,
                    referencedTable:
                        $$LoansTableReferences._sharedBookIdTable(db),
                    referencedColumn:
                        $$LoansTableReferences._sharedBookIdTable(db).id,
                  ) as T;
                }
                if (bookId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.bookId,
                    referencedTable: $$LoansTableReferences._bookIdTable(db),
                    referencedColumn:
                        $$LoansTableReferences._bookIdTable(db).id,
                  ) as T;
                }
                if (borrowerUserId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.borrowerUserId,
                    referencedTable:
                        $$LoansTableReferences._borrowerUserIdTable(db),
                    referencedColumn:
                        $$LoansTableReferences._borrowerUserIdTable(db).id,
                  ) as T;
                }
                if (lenderUserId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.lenderUserId,
                    referencedTable:
                        $$LoansTableReferences._lenderUserIdTable(db),
                    referencedColumn:
                        $$LoansTableReferences._lenderUserIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (notificationLoans)
                    await $_getPrefetchedData<Loan, $LoansTable,
                            InAppNotification>(
                        currentTable: table,
                        referencedTable:
                            $$LoansTableReferences._notificationLoansTable(db),
                        managerFromTypedResult: (p0) =>
                            $$LoansTableReferences(db, table, p0)
                                .notificationLoans,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.loanId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$LoansTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $LoansTable,
    Loan,
    $$LoansTableFilterComposer,
    $$LoansTableOrderingComposer,
    $$LoansTableAnnotationComposer,
    $$LoansTableCreateCompanionBuilder,
    $$LoansTableUpdateCompanionBuilder,
    (Loan, $$LoansTableReferences),
    Loan,
    PrefetchHooks Function(
        {bool sharedBookId,
        bool bookId,
        bool borrowerUserId,
        bool lenderUserId,
        bool notificationLoans})>;
typedef $$InAppNotificationsTableCreateCompanionBuilder
    = InAppNotificationsCompanion Function({
  Value<int> id,
  required String uuid,
  required String type,
  Value<int?> loanId,
  Value<String?> loanUuid,
  Value<int?> sharedBookId,
  Value<String?> sharedBookUuid,
  Value<int?> actorUserId,
  required int targetUserId,
  Value<String?> title,
  Value<String?> message,
  Value<String> status,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});
typedef $$InAppNotificationsTableUpdateCompanionBuilder
    = InAppNotificationsCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String> type,
  Value<int?> loanId,
  Value<String?> loanUuid,
  Value<int?> sharedBookId,
  Value<String?> sharedBookUuid,
  Value<int?> actorUserId,
  Value<int> targetUserId,
  Value<String?> title,
  Value<String?> message,
  Value<String> status,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

final class $$InAppNotificationsTableReferences extends BaseReferences<
    _$AppDatabase, $InAppNotificationsTable, InAppNotification> {
  $$InAppNotificationsTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $LoansTable _loanIdTable(_$AppDatabase db) => db.loans.createAlias(
      $_aliasNameGenerator(db.inAppNotifications.loanId, db.loans.id));

  $$LoansTableProcessedTableManager? get loanId {
    final $_column = $_itemColumn<int>('loan_id');
    if ($_column == null) return null;
    final manager = $$LoansTableTableManager($_db, $_db.loans)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_loanIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $SharedBooksTable _sharedBookIdTable(_$AppDatabase db) =>
      db.sharedBooks.createAlias($_aliasNameGenerator(
          db.inAppNotifications.sharedBookId, db.sharedBooks.id));

  $$SharedBooksTableProcessedTableManager? get sharedBookId {
    final $_column = $_itemColumn<int>('shared_book_id');
    if ($_column == null) return null;
    final manager = $$SharedBooksTableTableManager($_db, $_db.sharedBooks)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_sharedBookIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $LocalUsersTable _actorUserIdTable(_$AppDatabase db) =>
      db.localUsers.createAlias($_aliasNameGenerator(
          db.inAppNotifications.actorUserId, db.localUsers.id));

  $$LocalUsersTableProcessedTableManager? get actorUserId {
    final $_column = $_itemColumn<int>('actor_user_id');
    if ($_column == null) return null;
    final manager = $$LocalUsersTableTableManager($_db, $_db.localUsers)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_actorUserIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $LocalUsersTable _targetUserIdTable(_$AppDatabase db) =>
      db.localUsers.createAlias($_aliasNameGenerator(
          db.inAppNotifications.targetUserId, db.localUsers.id));

  $$LocalUsersTableProcessedTableManager get targetUserId {
    final $_column = $_itemColumn<int>('target_user_id')!;

    final manager = $$LocalUsersTableTableManager($_db, $_db.localUsers)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_targetUserIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$InAppNotificationsTableFilterComposer
    extends Composer<_$AppDatabase, $InAppNotificationsTable> {
  $$InAppNotificationsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get loanUuid => $composableBuilder(
      column: $table.loanUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get sharedBookUuid => $composableBuilder(
      column: $table.sharedBookUuid,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get title => $composableBuilder(
      column: $table.title, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get message => $composableBuilder(
      column: $table.message, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $$LoansTableFilterComposer get loanId {
    final $$LoansTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.loanId,
        referencedTable: $db.loans,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LoansTableFilterComposer(
              $db: $db,
              $table: $db.loans,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$SharedBooksTableFilterComposer get sharedBookId {
    final $$SharedBooksTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.sharedBookId,
        referencedTable: $db.sharedBooks,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SharedBooksTableFilterComposer(
              $db: $db,
              $table: $db.sharedBooks,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableFilterComposer get actorUserId {
    final $$LocalUsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.actorUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableFilterComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableFilterComposer get targetUserId {
    final $$LocalUsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.targetUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableFilterComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$InAppNotificationsTableOrderingComposer
    extends Composer<_$AppDatabase, $InAppNotificationsTable> {
  $$InAppNotificationsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get type => $composableBuilder(
      column: $table.type, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get loanUuid => $composableBuilder(
      column: $table.loanUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get sharedBookUuid => $composableBuilder(
      column: $table.sharedBookUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get title => $composableBuilder(
      column: $table.title, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get message => $composableBuilder(
      column: $table.message, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $$LoansTableOrderingComposer get loanId {
    final $$LoansTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.loanId,
        referencedTable: $db.loans,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LoansTableOrderingComposer(
              $db: $db,
              $table: $db.loans,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$SharedBooksTableOrderingComposer get sharedBookId {
    final $$SharedBooksTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.sharedBookId,
        referencedTable: $db.sharedBooks,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SharedBooksTableOrderingComposer(
              $db: $db,
              $table: $db.sharedBooks,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableOrderingComposer get actorUserId {
    final $$LocalUsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.actorUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableOrderingComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableOrderingComposer get targetUserId {
    final $$LocalUsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.targetUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableOrderingComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$InAppNotificationsTableAnnotationComposer
    extends Composer<_$AppDatabase, $InAppNotificationsTable> {
  $$InAppNotificationsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get loanUuid =>
      $composableBuilder(column: $table.loanUuid, builder: (column) => column);

  GeneratedColumn<String> get sharedBookUuid => $composableBuilder(
      column: $table.sharedBookUuid, builder: (column) => column);

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<String> get message =>
      $composableBuilder(column: $table.message, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<bool> get isDirty =>
      $composableBuilder(column: $table.isDirty, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get syncedAt =>
      $composableBuilder(column: $table.syncedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$LoansTableAnnotationComposer get loanId {
    final $$LoansTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.loanId,
        referencedTable: $db.loans,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LoansTableAnnotationComposer(
              $db: $db,
              $table: $db.loans,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$SharedBooksTableAnnotationComposer get sharedBookId {
    final $$SharedBooksTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.sharedBookId,
        referencedTable: $db.sharedBooks,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SharedBooksTableAnnotationComposer(
              $db: $db,
              $table: $db.sharedBooks,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableAnnotationComposer get actorUserId {
    final $$LocalUsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.actorUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableAnnotationComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableAnnotationComposer get targetUserId {
    final $$LocalUsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.targetUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableAnnotationComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$InAppNotificationsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $InAppNotificationsTable,
    InAppNotification,
    $$InAppNotificationsTableFilterComposer,
    $$InAppNotificationsTableOrderingComposer,
    $$InAppNotificationsTableAnnotationComposer,
    $$InAppNotificationsTableCreateCompanionBuilder,
    $$InAppNotificationsTableUpdateCompanionBuilder,
    (InAppNotification, $$InAppNotificationsTableReferences),
    InAppNotification,
    PrefetchHooks Function(
        {bool loanId,
        bool sharedBookId,
        bool actorUserId,
        bool targetUserId})> {
  $$InAppNotificationsTableTableManager(
      _$AppDatabase db, $InAppNotificationsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$InAppNotificationsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$InAppNotificationsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$InAppNotificationsTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String> type = const Value.absent(),
            Value<int?> loanId = const Value.absent(),
            Value<String?> loanUuid = const Value.absent(),
            Value<int?> sharedBookId = const Value.absent(),
            Value<String?> sharedBookUuid = const Value.absent(),
            Value<int?> actorUserId = const Value.absent(),
            Value<int> targetUserId = const Value.absent(),
            Value<String?> title = const Value.absent(),
            Value<String?> message = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              InAppNotificationsCompanion(
            id: id,
            uuid: uuid,
            type: type,
            loanId: loanId,
            loanUuid: loanUuid,
            sharedBookId: sharedBookId,
            sharedBookUuid: sharedBookUuid,
            actorUserId: actorUserId,
            targetUserId: targetUserId,
            title: title,
            message: message,
            status: status,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required String type,
            Value<int?> loanId = const Value.absent(),
            Value<String?> loanUuid = const Value.absent(),
            Value<int?> sharedBookId = const Value.absent(),
            Value<String?> sharedBookUuid = const Value.absent(),
            Value<int?> actorUserId = const Value.absent(),
            required int targetUserId,
            Value<String?> title = const Value.absent(),
            Value<String?> message = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              InAppNotificationsCompanion.insert(
            id: id,
            uuid: uuid,
            type: type,
            loanId: loanId,
            loanUuid: loanUuid,
            sharedBookId: sharedBookId,
            sharedBookUuid: sharedBookUuid,
            actorUserId: actorUserId,
            targetUserId: targetUserId,
            title: title,
            message: message,
            status: status,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$InAppNotificationsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {loanId = false,
              sharedBookId = false,
              actorUserId = false,
              targetUserId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (loanId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.loanId,
                    referencedTable:
                        $$InAppNotificationsTableReferences._loanIdTable(db),
                    referencedColumn:
                        $$InAppNotificationsTableReferences._loanIdTable(db).id,
                  ) as T;
                }
                if (sharedBookId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.sharedBookId,
                    referencedTable: $$InAppNotificationsTableReferences
                        ._sharedBookIdTable(db),
                    referencedColumn: $$InAppNotificationsTableReferences
                        ._sharedBookIdTable(db)
                        .id,
                  ) as T;
                }
                if (actorUserId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.actorUserId,
                    referencedTable: $$InAppNotificationsTableReferences
                        ._actorUserIdTable(db),
                    referencedColumn: $$InAppNotificationsTableReferences
                        ._actorUserIdTable(db)
                        .id,
                  ) as T;
                }
                if (targetUserId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.targetUserId,
                    referencedTable: $$InAppNotificationsTableReferences
                        ._targetUserIdTable(db),
                    referencedColumn: $$InAppNotificationsTableReferences
                        ._targetUserIdTable(db)
                        .id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$InAppNotificationsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $InAppNotificationsTable,
    InAppNotification,
    $$InAppNotificationsTableFilterComposer,
    $$InAppNotificationsTableOrderingComposer,
    $$InAppNotificationsTableAnnotationComposer,
    $$InAppNotificationsTableCreateCompanionBuilder,
    $$InAppNotificationsTableUpdateCompanionBuilder,
    (InAppNotification, $$InAppNotificationsTableReferences),
    InAppNotification,
    PrefetchHooks Function(
        {bool loanId, bool sharedBookId, bool actorUserId, bool targetUserId})>;
typedef $$WishlistItemsTableCreateCompanionBuilder = WishlistItemsCompanion
    Function({
  Value<int> id,
  required String uuid,
  required int userId,
  required String title,
  Value<String?> author,
  Value<String?> isbn,
  Value<String?> notes,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});
typedef $$WishlistItemsTableUpdateCompanionBuilder = WishlistItemsCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<int> userId,
  Value<String> title,
  Value<String?> author,
  Value<String?> isbn,
  Value<String?> notes,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

final class $$WishlistItemsTableReferences
    extends BaseReferences<_$AppDatabase, $WishlistItemsTable, WishlistItem> {
  $$WishlistItemsTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $LocalUsersTable _userIdTable(_$AppDatabase db) =>
      db.localUsers.createAlias(
          $_aliasNameGenerator(db.wishlistItems.userId, db.localUsers.id));

  $$LocalUsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<int>('user_id')!;

    final manager = $$LocalUsersTableTableManager($_db, $_db.localUsers)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$WishlistItemsTableFilterComposer
    extends Composer<_$AppDatabase, $WishlistItemsTable> {
  $$WishlistItemsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get title => $composableBuilder(
      column: $table.title, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get author => $composableBuilder(
      column: $table.author, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get isbn => $composableBuilder(
      column: $table.isbn, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $$LocalUsersTableFilterComposer get userId {
    final $$LocalUsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.userId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableFilterComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$WishlistItemsTableOrderingComposer
    extends Composer<_$AppDatabase, $WishlistItemsTable> {
  $$WishlistItemsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get title => $composableBuilder(
      column: $table.title, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get author => $composableBuilder(
      column: $table.author, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get isbn => $composableBuilder(
      column: $table.isbn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get notes => $composableBuilder(
      column: $table.notes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $$LocalUsersTableOrderingComposer get userId {
    final $$LocalUsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.userId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableOrderingComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$WishlistItemsTableAnnotationComposer
    extends Composer<_$AppDatabase, $WishlistItemsTable> {
  $$WishlistItemsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<String> get author =>
      $composableBuilder(column: $table.author, builder: (column) => column);

  GeneratedColumn<String> get isbn =>
      $composableBuilder(column: $table.isbn, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$LocalUsersTableAnnotationComposer get userId {
    final $$LocalUsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.userId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableAnnotationComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$WishlistItemsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $WishlistItemsTable,
    WishlistItem,
    $$WishlistItemsTableFilterComposer,
    $$WishlistItemsTableOrderingComposer,
    $$WishlistItemsTableAnnotationComposer,
    $$WishlistItemsTableCreateCompanionBuilder,
    $$WishlistItemsTableUpdateCompanionBuilder,
    (WishlistItem, $$WishlistItemsTableReferences),
    WishlistItem,
    PrefetchHooks Function({bool userId})> {
  $$WishlistItemsTableTableManager(_$AppDatabase db, $WishlistItemsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$WishlistItemsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$WishlistItemsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$WishlistItemsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<int> userId = const Value.absent(),
            Value<String> title = const Value.absent(),
            Value<String?> author = const Value.absent(),
            Value<String?> isbn = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              WishlistItemsCompanion(
            id: id,
            uuid: uuid,
            userId: userId,
            title: title,
            author: author,
            isbn: isbn,
            notes: notes,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required int userId,
            required String title,
            Value<String?> author = const Value.absent(),
            Value<String?> isbn = const Value.absent(),
            Value<String?> notes = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              WishlistItemsCompanion.insert(
            id: id,
            uuid: uuid,
            userId: userId,
            title: title,
            author: author,
            isbn: isbn,
            notes: notes,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$WishlistItemsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({userId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (userId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.userId,
                    referencedTable:
                        $$WishlistItemsTableReferences._userIdTable(db),
                    referencedColumn:
                        $$WishlistItemsTableReferences._userIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$WishlistItemsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $WishlistItemsTable,
    WishlistItem,
    $$WishlistItemsTableFilterComposer,
    $$WishlistItemsTableOrderingComposer,
    $$WishlistItemsTableAnnotationComposer,
    $$WishlistItemsTableCreateCompanionBuilder,
    $$WishlistItemsTableUpdateCompanionBuilder,
    (WishlistItem, $$WishlistItemsTableReferences),
    WishlistItem,
    PrefetchHooks Function({bool userId})>;
typedef $$ReadingClubsTableCreateCompanionBuilder = ReadingClubsCompanion
    Function({
  Value<int> id,
  required String uuid,
  Value<String?> remoteId,
  required String name,
  required String description,
  required String city,
  Value<String?> meetingPlace,
  required String frequency,
  Value<int?> frequencyDays,
  Value<String> visibility,
  Value<int> nextBooksVisible,
  required int ownerUserId,
  Value<String?> ownerRemoteId,
  Value<int?> currentBookId,
  Value<String?> currentBookUuid,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});
typedef $$ReadingClubsTableUpdateCompanionBuilder = ReadingClubsCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String?> remoteId,
  Value<String> name,
  Value<String> description,
  Value<String> city,
  Value<String?> meetingPlace,
  Value<String> frequency,
  Value<int?> frequencyDays,
  Value<String> visibility,
  Value<int> nextBooksVisible,
  Value<int> ownerUserId,
  Value<String?> ownerRemoteId,
  Value<int?> currentBookId,
  Value<String?> currentBookUuid,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

final class $$ReadingClubsTableReferences
    extends BaseReferences<_$AppDatabase, $ReadingClubsTable, ReadingClub> {
  $$ReadingClubsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $LocalUsersTable _ownerUserIdTable(_$AppDatabase db) =>
      db.localUsers.createAlias(
          $_aliasNameGenerator(db.readingClubs.ownerUserId, db.localUsers.id));

  $$LocalUsersTableProcessedTableManager get ownerUserId {
    final $_column = $_itemColumn<int>('owner_user_id')!;

    final manager = $$LocalUsersTableTableManager($_db, $_db.localUsers)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_ownerUserIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$ClubMembersTable, List<ClubMember>>
      _clubMembersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
          db.clubMembers,
          aliasName:
              $_aliasNameGenerator(db.readingClubs.id, db.clubMembers.clubId));

  $$ClubMembersTableProcessedTableManager get clubMembersRefs {
    final manager = $$ClubMembersTableTableManager($_db, $_db.clubMembers)
        .filter((f) => f.clubId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_clubMembersRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$ClubBooksTable, List<ClubBook>>
      _clubBooksRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
          db.clubBooks,
          aliasName:
              $_aliasNameGenerator(db.readingClubs.id, db.clubBooks.clubId));

  $$ClubBooksTableProcessedTableManager get clubBooksRefs {
    final manager = $$ClubBooksTableTableManager($_db, $_db.clubBooks)
        .filter((f) => f.clubId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_clubBooksRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$ClubReadingProgressTable,
      List<ClubReadingProgressData>> _clubReadingProgressRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.clubReadingProgress,
          aliasName: $_aliasNameGenerator(
              db.readingClubs.id, db.clubReadingProgress.clubId));

  $$ClubReadingProgressTableProcessedTableManager get clubReadingProgressRefs {
    final manager =
        $$ClubReadingProgressTableTableManager($_db, $_db.clubReadingProgress)
            .filter((f) => f.clubId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_clubReadingProgressRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$BookProposalsTable, List<BookProposal>>
      _bookProposalsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.bookProposals,
              aliasName: $_aliasNameGenerator(
                  db.readingClubs.id, db.bookProposals.clubId));

  $$BookProposalsTableProcessedTableManager get bookProposalsRefs {
    final manager = $$BookProposalsTableTableManager($_db, $_db.bookProposals)
        .filter((f) => f.clubId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_bookProposalsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$SectionCommentsTable, List<SectionComment>>
      _sectionCommentsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.sectionComments,
              aliasName: $_aliasNameGenerator(
                  db.readingClubs.id, db.sectionComments.clubId));

  $$SectionCommentsTableProcessedTableManager get sectionCommentsRefs {
    final manager =
        $$SectionCommentsTableTableManager($_db, $_db.sectionComments)
            .filter((f) => f.clubId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_sectionCommentsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$ModerationLogsTable, List<ModerationLog>>
      _moderationLogsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.moderationLogs,
              aliasName: $_aliasNameGenerator(
                  db.readingClubs.id, db.moderationLogs.clubId));

  $$ModerationLogsTableProcessedTableManager get moderationLogsRefs {
    final manager = $$ModerationLogsTableTableManager($_db, $_db.moderationLogs)
        .filter((f) => f.clubId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_moderationLogsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$ReadingClubsTableFilterComposer
    extends Composer<_$AppDatabase, $ReadingClubsTable> {
  $$ReadingClubsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get city => $composableBuilder(
      column: $table.city, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get meetingPlace => $composableBuilder(
      column: $table.meetingPlace, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get frequency => $composableBuilder(
      column: $table.frequency, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get frequencyDays => $composableBuilder(
      column: $table.frequencyDays, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get visibility => $composableBuilder(
      column: $table.visibility, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get nextBooksVisible => $composableBuilder(
      column: $table.nextBooksVisible,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get ownerRemoteId => $composableBuilder(
      column: $table.ownerRemoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get currentBookId => $composableBuilder(
      column: $table.currentBookId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get currentBookUuid => $composableBuilder(
      column: $table.currentBookUuid,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $$LocalUsersTableFilterComposer get ownerUserId {
    final $$LocalUsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ownerUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableFilterComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> clubMembersRefs(
      Expression<bool> Function($$ClubMembersTableFilterComposer f) f) {
    final $$ClubMembersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.clubMembers,
        getReferencedColumn: (t) => t.clubId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClubMembersTableFilterComposer(
              $db: $db,
              $table: $db.clubMembers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> clubBooksRefs(
      Expression<bool> Function($$ClubBooksTableFilterComposer f) f) {
    final $$ClubBooksTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.clubBooks,
        getReferencedColumn: (t) => t.clubId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClubBooksTableFilterComposer(
              $db: $db,
              $table: $db.clubBooks,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> clubReadingProgressRefs(
      Expression<bool> Function($$ClubReadingProgressTableFilterComposer f) f) {
    final $$ClubReadingProgressTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.clubReadingProgress,
        getReferencedColumn: (t) => t.clubId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClubReadingProgressTableFilterComposer(
              $db: $db,
              $table: $db.clubReadingProgress,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> bookProposalsRefs(
      Expression<bool> Function($$BookProposalsTableFilterComposer f) f) {
    final $$BookProposalsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.bookProposals,
        getReferencedColumn: (t) => t.clubId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BookProposalsTableFilterComposer(
              $db: $db,
              $table: $db.bookProposals,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> sectionCommentsRefs(
      Expression<bool> Function($$SectionCommentsTableFilterComposer f) f) {
    final $$SectionCommentsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.sectionComments,
        getReferencedColumn: (t) => t.clubId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SectionCommentsTableFilterComposer(
              $db: $db,
              $table: $db.sectionComments,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> moderationLogsRefs(
      Expression<bool> Function($$ModerationLogsTableFilterComposer f) f) {
    final $$ModerationLogsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.moderationLogs,
        getReferencedColumn: (t) => t.clubId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ModerationLogsTableFilterComposer(
              $db: $db,
              $table: $db.moderationLogs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$ReadingClubsTableOrderingComposer
    extends Composer<_$AppDatabase, $ReadingClubsTable> {
  $$ReadingClubsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get name => $composableBuilder(
      column: $table.name, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get city => $composableBuilder(
      column: $table.city, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get meetingPlace => $composableBuilder(
      column: $table.meetingPlace,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get frequency => $composableBuilder(
      column: $table.frequency, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get frequencyDays => $composableBuilder(
      column: $table.frequencyDays,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get visibility => $composableBuilder(
      column: $table.visibility, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get nextBooksVisible => $composableBuilder(
      column: $table.nextBooksVisible,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get ownerRemoteId => $composableBuilder(
      column: $table.ownerRemoteId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get currentBookId => $composableBuilder(
      column: $table.currentBookId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get currentBookUuid => $composableBuilder(
      column: $table.currentBookUuid,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $$LocalUsersTableOrderingComposer get ownerUserId {
    final $$LocalUsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ownerUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableOrderingComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ReadingClubsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ReadingClubsTable> {
  $$ReadingClubsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get remoteId =>
      $composableBuilder(column: $table.remoteId, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
      column: $table.description, builder: (column) => column);

  GeneratedColumn<String> get city =>
      $composableBuilder(column: $table.city, builder: (column) => column);

  GeneratedColumn<String> get meetingPlace => $composableBuilder(
      column: $table.meetingPlace, builder: (column) => column);

  GeneratedColumn<String> get frequency =>
      $composableBuilder(column: $table.frequency, builder: (column) => column);

  GeneratedColumn<int> get frequencyDays => $composableBuilder(
      column: $table.frequencyDays, builder: (column) => column);

  GeneratedColumn<String> get visibility => $composableBuilder(
      column: $table.visibility, builder: (column) => column);

  GeneratedColumn<int> get nextBooksVisible => $composableBuilder(
      column: $table.nextBooksVisible, builder: (column) => column);

  GeneratedColumn<String> get ownerRemoteId => $composableBuilder(
      column: $table.ownerRemoteId, builder: (column) => column);

  GeneratedColumn<int> get currentBookId => $composableBuilder(
      column: $table.currentBookId, builder: (column) => column);

  GeneratedColumn<String> get currentBookUuid => $composableBuilder(
      column: $table.currentBookUuid, builder: (column) => column);

  GeneratedColumn<bool> get isDirty =>
      $composableBuilder(column: $table.isDirty, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get syncedAt =>
      $composableBuilder(column: $table.syncedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$LocalUsersTableAnnotationComposer get ownerUserId {
    final $$LocalUsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.ownerUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableAnnotationComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> clubMembersRefs<T extends Object>(
      Expression<T> Function($$ClubMembersTableAnnotationComposer a) f) {
    final $$ClubMembersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.clubMembers,
        getReferencedColumn: (t) => t.clubId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClubMembersTableAnnotationComposer(
              $db: $db,
              $table: $db.clubMembers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> clubBooksRefs<T extends Object>(
      Expression<T> Function($$ClubBooksTableAnnotationComposer a) f) {
    final $$ClubBooksTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.clubBooks,
        getReferencedColumn: (t) => t.clubId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClubBooksTableAnnotationComposer(
              $db: $db,
              $table: $db.clubBooks,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> clubReadingProgressRefs<T extends Object>(
      Expression<T> Function($$ClubReadingProgressTableAnnotationComposer a)
          f) {
    final $$ClubReadingProgressTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.clubReadingProgress,
            getReferencedColumn: (t) => t.clubId,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$ClubReadingProgressTableAnnotationComposer(
                  $db: $db,
                  $table: $db.clubReadingProgress,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<T> bookProposalsRefs<T extends Object>(
      Expression<T> Function($$BookProposalsTableAnnotationComposer a) f) {
    final $$BookProposalsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.bookProposals,
        getReferencedColumn: (t) => t.clubId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$BookProposalsTableAnnotationComposer(
              $db: $db,
              $table: $db.bookProposals,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> sectionCommentsRefs<T extends Object>(
      Expression<T> Function($$SectionCommentsTableAnnotationComposer a) f) {
    final $$SectionCommentsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.sectionComments,
        getReferencedColumn: (t) => t.clubId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SectionCommentsTableAnnotationComposer(
              $db: $db,
              $table: $db.sectionComments,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<T> moderationLogsRefs<T extends Object>(
      Expression<T> Function($$ModerationLogsTableAnnotationComposer a) f) {
    final $$ModerationLogsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.moderationLogs,
        getReferencedColumn: (t) => t.clubId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ModerationLogsTableAnnotationComposer(
              $db: $db,
              $table: $db.moderationLogs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$ReadingClubsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ReadingClubsTable,
    ReadingClub,
    $$ReadingClubsTableFilterComposer,
    $$ReadingClubsTableOrderingComposer,
    $$ReadingClubsTableAnnotationComposer,
    $$ReadingClubsTableCreateCompanionBuilder,
    $$ReadingClubsTableUpdateCompanionBuilder,
    (ReadingClub, $$ReadingClubsTableReferences),
    ReadingClub,
    PrefetchHooks Function(
        {bool ownerUserId,
        bool clubMembersRefs,
        bool clubBooksRefs,
        bool clubReadingProgressRefs,
        bool bookProposalsRefs,
        bool sectionCommentsRefs,
        bool moderationLogsRefs})> {
  $$ReadingClubsTableTableManager(_$AppDatabase db, $ReadingClubsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ReadingClubsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ReadingClubsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ReadingClubsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String?> remoteId = const Value.absent(),
            Value<String> name = const Value.absent(),
            Value<String> description = const Value.absent(),
            Value<String> city = const Value.absent(),
            Value<String?> meetingPlace = const Value.absent(),
            Value<String> frequency = const Value.absent(),
            Value<int?> frequencyDays = const Value.absent(),
            Value<String> visibility = const Value.absent(),
            Value<int> nextBooksVisible = const Value.absent(),
            Value<int> ownerUserId = const Value.absent(),
            Value<String?> ownerRemoteId = const Value.absent(),
            Value<int?> currentBookId = const Value.absent(),
            Value<String?> currentBookUuid = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              ReadingClubsCompanion(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            name: name,
            description: description,
            city: city,
            meetingPlace: meetingPlace,
            frequency: frequency,
            frequencyDays: frequencyDays,
            visibility: visibility,
            nextBooksVisible: nextBooksVisible,
            ownerUserId: ownerUserId,
            ownerRemoteId: ownerRemoteId,
            currentBookId: currentBookId,
            currentBookUuid: currentBookUuid,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            Value<String?> remoteId = const Value.absent(),
            required String name,
            required String description,
            required String city,
            Value<String?> meetingPlace = const Value.absent(),
            required String frequency,
            Value<int?> frequencyDays = const Value.absent(),
            Value<String> visibility = const Value.absent(),
            Value<int> nextBooksVisible = const Value.absent(),
            required int ownerUserId,
            Value<String?> ownerRemoteId = const Value.absent(),
            Value<int?> currentBookId = const Value.absent(),
            Value<String?> currentBookUuid = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              ReadingClubsCompanion.insert(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            name: name,
            description: description,
            city: city,
            meetingPlace: meetingPlace,
            frequency: frequency,
            frequencyDays: frequencyDays,
            visibility: visibility,
            nextBooksVisible: nextBooksVisible,
            ownerUserId: ownerUserId,
            ownerRemoteId: ownerRemoteId,
            currentBookId: currentBookId,
            currentBookUuid: currentBookUuid,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$ReadingClubsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {ownerUserId = false,
              clubMembersRefs = false,
              clubBooksRefs = false,
              clubReadingProgressRefs = false,
              bookProposalsRefs = false,
              sectionCommentsRefs = false,
              moderationLogsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (clubMembersRefs) db.clubMembers,
                if (clubBooksRefs) db.clubBooks,
                if (clubReadingProgressRefs) db.clubReadingProgress,
                if (bookProposalsRefs) db.bookProposals,
                if (sectionCommentsRefs) db.sectionComments,
                if (moderationLogsRefs) db.moderationLogs
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (ownerUserId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.ownerUserId,
                    referencedTable:
                        $$ReadingClubsTableReferences._ownerUserIdTable(db),
                    referencedColumn:
                        $$ReadingClubsTableReferences._ownerUserIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (clubMembersRefs)
                    await $_getPrefetchedData<ReadingClub, $ReadingClubsTable,
                            ClubMember>(
                        currentTable: table,
                        referencedTable: $$ReadingClubsTableReferences
                            ._clubMembersRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ReadingClubsTableReferences(db, table, p0)
                                .clubMembersRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.clubId == item.id),
                        typedResults: items),
                  if (clubBooksRefs)
                    await $_getPrefetchedData<ReadingClub, $ReadingClubsTable,
                            ClubBook>(
                        currentTable: table,
                        referencedTable: $$ReadingClubsTableReferences
                            ._clubBooksRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ReadingClubsTableReferences(db, table, p0)
                                .clubBooksRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.clubId == item.id),
                        typedResults: items),
                  if (clubReadingProgressRefs)
                    await $_getPrefetchedData<ReadingClub, $ReadingClubsTable,
                            ClubReadingProgressData>(
                        currentTable: table,
                        referencedTable: $$ReadingClubsTableReferences
                            ._clubReadingProgressRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ReadingClubsTableReferences(db, table, p0)
                                .clubReadingProgressRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.clubId == item.id),
                        typedResults: items),
                  if (bookProposalsRefs)
                    await $_getPrefetchedData<ReadingClub, $ReadingClubsTable,
                            BookProposal>(
                        currentTable: table,
                        referencedTable: $$ReadingClubsTableReferences
                            ._bookProposalsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ReadingClubsTableReferences(db, table, p0)
                                .bookProposalsRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.clubId == item.id),
                        typedResults: items),
                  if (sectionCommentsRefs)
                    await $_getPrefetchedData<ReadingClub, $ReadingClubsTable,
                            SectionComment>(
                        currentTable: table,
                        referencedTable: $$ReadingClubsTableReferences
                            ._sectionCommentsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ReadingClubsTableReferences(db, table, p0)
                                .sectionCommentsRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.clubId == item.id),
                        typedResults: items),
                  if (moderationLogsRefs)
                    await $_getPrefetchedData<ReadingClub, $ReadingClubsTable,
                            ModerationLog>(
                        currentTable: table,
                        referencedTable: $$ReadingClubsTableReferences
                            ._moderationLogsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ReadingClubsTableReferences(db, table, p0)
                                .moderationLogsRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.clubId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$ReadingClubsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ReadingClubsTable,
    ReadingClub,
    $$ReadingClubsTableFilterComposer,
    $$ReadingClubsTableOrderingComposer,
    $$ReadingClubsTableAnnotationComposer,
    $$ReadingClubsTableCreateCompanionBuilder,
    $$ReadingClubsTableUpdateCompanionBuilder,
    (ReadingClub, $$ReadingClubsTableReferences),
    ReadingClub,
    PrefetchHooks Function(
        {bool ownerUserId,
        bool clubMembersRefs,
        bool clubBooksRefs,
        bool clubReadingProgressRefs,
        bool bookProposalsRefs,
        bool sectionCommentsRefs,
        bool moderationLogsRefs})>;
typedef $$ClubMembersTableCreateCompanionBuilder = ClubMembersCompanion
    Function({
  Value<int> id,
  required String uuid,
  Value<String?> remoteId,
  required int clubId,
  required String clubUuid,
  required int memberUserId,
  Value<String?> memberRemoteId,
  Value<String> role,
  Value<String> status,
  Value<DateTime> joinedAt,
  Value<DateTime> lastActivity,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});
typedef $$ClubMembersTableUpdateCompanionBuilder = ClubMembersCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String?> remoteId,
  Value<int> clubId,
  Value<String> clubUuid,
  Value<int> memberUserId,
  Value<String?> memberRemoteId,
  Value<String> role,
  Value<String> status,
  Value<DateTime> joinedAt,
  Value<DateTime> lastActivity,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

final class $$ClubMembersTableReferences
    extends BaseReferences<_$AppDatabase, $ClubMembersTable, ClubMember> {
  $$ClubMembersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ReadingClubsTable _clubIdTable(_$AppDatabase db) =>
      db.readingClubs.createAlias(
          $_aliasNameGenerator(db.clubMembers.clubId, db.readingClubs.id));

  $$ReadingClubsTableProcessedTableManager get clubId {
    final $_column = $_itemColumn<int>('club_id')!;

    final manager = $$ReadingClubsTableTableManager($_db, $_db.readingClubs)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_clubIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $LocalUsersTable _memberUserIdTable(_$AppDatabase db) =>
      db.localUsers.createAlias(
          $_aliasNameGenerator(db.clubMembers.memberUserId, db.localUsers.id));

  $$LocalUsersTableProcessedTableManager get memberUserId {
    final $_column = $_itemColumn<int>('member_user_id')!;

    final manager = $$LocalUsersTableTableManager($_db, $_db.localUsers)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_memberUserIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$ClubMembersTableFilterComposer
    extends Composer<_$AppDatabase, $ClubMembersTable> {
  $$ClubMembersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get clubUuid => $composableBuilder(
      column: $table.clubUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get memberRemoteId => $composableBuilder(
      column: $table.memberRemoteId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get role => $composableBuilder(
      column: $table.role, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get joinedAt => $composableBuilder(
      column: $table.joinedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get lastActivity => $composableBuilder(
      column: $table.lastActivity, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $$ReadingClubsTableFilterComposer get clubId {
    final $$ReadingClubsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clubId,
        referencedTable: $db.readingClubs,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReadingClubsTableFilterComposer(
              $db: $db,
              $table: $db.readingClubs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableFilterComposer get memberUserId {
    final $$LocalUsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.memberUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableFilterComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ClubMembersTableOrderingComposer
    extends Composer<_$AppDatabase, $ClubMembersTable> {
  $$ClubMembersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get clubUuid => $composableBuilder(
      column: $table.clubUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get memberRemoteId => $composableBuilder(
      column: $table.memberRemoteId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get role => $composableBuilder(
      column: $table.role, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get joinedAt => $composableBuilder(
      column: $table.joinedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get lastActivity => $composableBuilder(
      column: $table.lastActivity,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $$ReadingClubsTableOrderingComposer get clubId {
    final $$ReadingClubsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clubId,
        referencedTable: $db.readingClubs,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReadingClubsTableOrderingComposer(
              $db: $db,
              $table: $db.readingClubs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableOrderingComposer get memberUserId {
    final $$LocalUsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.memberUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableOrderingComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ClubMembersTableAnnotationComposer
    extends Composer<_$AppDatabase, $ClubMembersTable> {
  $$ClubMembersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get remoteId =>
      $composableBuilder(column: $table.remoteId, builder: (column) => column);

  GeneratedColumn<String> get clubUuid =>
      $composableBuilder(column: $table.clubUuid, builder: (column) => column);

  GeneratedColumn<String> get memberRemoteId => $composableBuilder(
      column: $table.memberRemoteId, builder: (column) => column);

  GeneratedColumn<String> get role =>
      $composableBuilder(column: $table.role, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get joinedAt =>
      $composableBuilder(column: $table.joinedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get lastActivity => $composableBuilder(
      column: $table.lastActivity, builder: (column) => column);

  GeneratedColumn<bool> get isDirty =>
      $composableBuilder(column: $table.isDirty, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get syncedAt =>
      $composableBuilder(column: $table.syncedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$ReadingClubsTableAnnotationComposer get clubId {
    final $$ReadingClubsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clubId,
        referencedTable: $db.readingClubs,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReadingClubsTableAnnotationComposer(
              $db: $db,
              $table: $db.readingClubs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableAnnotationComposer get memberUserId {
    final $$LocalUsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.memberUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableAnnotationComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ClubMembersTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ClubMembersTable,
    ClubMember,
    $$ClubMembersTableFilterComposer,
    $$ClubMembersTableOrderingComposer,
    $$ClubMembersTableAnnotationComposer,
    $$ClubMembersTableCreateCompanionBuilder,
    $$ClubMembersTableUpdateCompanionBuilder,
    (ClubMember, $$ClubMembersTableReferences),
    ClubMember,
    PrefetchHooks Function({bool clubId, bool memberUserId})> {
  $$ClubMembersTableTableManager(_$AppDatabase db, $ClubMembersTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ClubMembersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ClubMembersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ClubMembersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String?> remoteId = const Value.absent(),
            Value<int> clubId = const Value.absent(),
            Value<String> clubUuid = const Value.absent(),
            Value<int> memberUserId = const Value.absent(),
            Value<String?> memberRemoteId = const Value.absent(),
            Value<String> role = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<DateTime> joinedAt = const Value.absent(),
            Value<DateTime> lastActivity = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              ClubMembersCompanion(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            clubId: clubId,
            clubUuid: clubUuid,
            memberUserId: memberUserId,
            memberRemoteId: memberRemoteId,
            role: role,
            status: status,
            joinedAt: joinedAt,
            lastActivity: lastActivity,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            Value<String?> remoteId = const Value.absent(),
            required int clubId,
            required String clubUuid,
            required int memberUserId,
            Value<String?> memberRemoteId = const Value.absent(),
            Value<String> role = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<DateTime> joinedAt = const Value.absent(),
            Value<DateTime> lastActivity = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              ClubMembersCompanion.insert(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            clubId: clubId,
            clubUuid: clubUuid,
            memberUserId: memberUserId,
            memberRemoteId: memberRemoteId,
            role: role,
            status: status,
            joinedAt: joinedAt,
            lastActivity: lastActivity,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$ClubMembersTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({clubId = false, memberUserId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (clubId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.clubId,
                    referencedTable:
                        $$ClubMembersTableReferences._clubIdTable(db),
                    referencedColumn:
                        $$ClubMembersTableReferences._clubIdTable(db).id,
                  ) as T;
                }
                if (memberUserId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.memberUserId,
                    referencedTable:
                        $$ClubMembersTableReferences._memberUserIdTable(db),
                    referencedColumn:
                        $$ClubMembersTableReferences._memberUserIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$ClubMembersTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ClubMembersTable,
    ClubMember,
    $$ClubMembersTableFilterComposer,
    $$ClubMembersTableOrderingComposer,
    $$ClubMembersTableAnnotationComposer,
    $$ClubMembersTableCreateCompanionBuilder,
    $$ClubMembersTableUpdateCompanionBuilder,
    (ClubMember, $$ClubMembersTableReferences),
    ClubMember,
    PrefetchHooks Function({bool clubId, bool memberUserId})>;
typedef $$ClubBooksTableCreateCompanionBuilder = ClubBooksCompanion Function({
  Value<int> id,
  required String uuid,
  Value<String?> remoteId,
  required int clubId,
  required String clubUuid,
  required String bookUuid,
  Value<int> orderPosition,
  Value<String> status,
  Value<String> sectionMode,
  required int totalChapters,
  required String sections,
  Value<DateTime?> startDate,
  Value<DateTime?> endDate,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});
typedef $$ClubBooksTableUpdateCompanionBuilder = ClubBooksCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<String?> remoteId,
  Value<int> clubId,
  Value<String> clubUuid,
  Value<String> bookUuid,
  Value<int> orderPosition,
  Value<String> status,
  Value<String> sectionMode,
  Value<int> totalChapters,
  Value<String> sections,
  Value<DateTime?> startDate,
  Value<DateTime?> endDate,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

final class $$ClubBooksTableReferences
    extends BaseReferences<_$AppDatabase, $ClubBooksTable, ClubBook> {
  $$ClubBooksTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $ReadingClubsTable _clubIdTable(_$AppDatabase db) =>
      db.readingClubs.createAlias(
          $_aliasNameGenerator(db.clubBooks.clubId, db.readingClubs.id));

  $$ReadingClubsTableProcessedTableManager get clubId {
    final $_column = $_itemColumn<int>('club_id')!;

    final manager = $$ReadingClubsTableTableManager($_db, $_db.readingClubs)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_clubIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$ClubReadingProgressTable,
      List<ClubReadingProgressData>> _clubReadingProgressRefsTable(
          _$AppDatabase db) =>
      MultiTypedResultKey.fromTable(db.clubReadingProgress,
          aliasName: $_aliasNameGenerator(
              db.clubBooks.id, db.clubReadingProgress.bookId));

  $$ClubReadingProgressTableProcessedTableManager get clubReadingProgressRefs {
    final manager =
        $$ClubReadingProgressTableTableManager($_db, $_db.clubReadingProgress)
            .filter((f) => f.bookId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_clubReadingProgressRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }

  static MultiTypedResultKey<$SectionCommentsTable, List<SectionComment>>
      _sectionCommentsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.sectionComments,
              aliasName: $_aliasNameGenerator(
                  db.clubBooks.id, db.sectionComments.bookId));

  $$SectionCommentsTableProcessedTableManager get sectionCommentsRefs {
    final manager =
        $$SectionCommentsTableTableManager($_db, $_db.sectionComments)
            .filter((f) => f.bookId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache =
        $_typedResult.readTableOrNull(_sectionCommentsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$ClubBooksTableFilterComposer
    extends Composer<_$AppDatabase, $ClubBooksTable> {
  $$ClubBooksTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get clubUuid => $composableBuilder(
      column: $table.clubUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get bookUuid => $composableBuilder(
      column: $table.bookUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get orderPosition => $composableBuilder(
      column: $table.orderPosition, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get sectionMode => $composableBuilder(
      column: $table.sectionMode, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get totalChapters => $composableBuilder(
      column: $table.totalChapters, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get sections => $composableBuilder(
      column: $table.sections, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get startDate => $composableBuilder(
      column: $table.startDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get endDate => $composableBuilder(
      column: $table.endDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $$ReadingClubsTableFilterComposer get clubId {
    final $$ReadingClubsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clubId,
        referencedTable: $db.readingClubs,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReadingClubsTableFilterComposer(
              $db: $db,
              $table: $db.readingClubs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> clubReadingProgressRefs(
      Expression<bool> Function($$ClubReadingProgressTableFilterComposer f) f) {
    final $$ClubReadingProgressTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.clubReadingProgress,
        getReferencedColumn: (t) => t.bookId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClubReadingProgressTableFilterComposer(
              $db: $db,
              $table: $db.clubReadingProgress,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }

  Expression<bool> sectionCommentsRefs(
      Expression<bool> Function($$SectionCommentsTableFilterComposer f) f) {
    final $$SectionCommentsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.sectionComments,
        getReferencedColumn: (t) => t.bookId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SectionCommentsTableFilterComposer(
              $db: $db,
              $table: $db.sectionComments,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$ClubBooksTableOrderingComposer
    extends Composer<_$AppDatabase, $ClubBooksTable> {
  $$ClubBooksTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get clubUuid => $composableBuilder(
      column: $table.clubUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get bookUuid => $composableBuilder(
      column: $table.bookUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get orderPosition => $composableBuilder(
      column: $table.orderPosition,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get sectionMode => $composableBuilder(
      column: $table.sectionMode, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get totalChapters => $composableBuilder(
      column: $table.totalChapters,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get sections => $composableBuilder(
      column: $table.sections, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get startDate => $composableBuilder(
      column: $table.startDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get endDate => $composableBuilder(
      column: $table.endDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $$ReadingClubsTableOrderingComposer get clubId {
    final $$ReadingClubsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clubId,
        referencedTable: $db.readingClubs,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReadingClubsTableOrderingComposer(
              $db: $db,
              $table: $db.readingClubs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ClubBooksTableAnnotationComposer
    extends Composer<_$AppDatabase, $ClubBooksTable> {
  $$ClubBooksTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get remoteId =>
      $composableBuilder(column: $table.remoteId, builder: (column) => column);

  GeneratedColumn<String> get clubUuid =>
      $composableBuilder(column: $table.clubUuid, builder: (column) => column);

  GeneratedColumn<String> get bookUuid =>
      $composableBuilder(column: $table.bookUuid, builder: (column) => column);

  GeneratedColumn<int> get orderPosition => $composableBuilder(
      column: $table.orderPosition, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get sectionMode => $composableBuilder(
      column: $table.sectionMode, builder: (column) => column);

  GeneratedColumn<int> get totalChapters => $composableBuilder(
      column: $table.totalChapters, builder: (column) => column);

  GeneratedColumn<String> get sections =>
      $composableBuilder(column: $table.sections, builder: (column) => column);

  GeneratedColumn<DateTime> get startDate =>
      $composableBuilder(column: $table.startDate, builder: (column) => column);

  GeneratedColumn<DateTime> get endDate =>
      $composableBuilder(column: $table.endDate, builder: (column) => column);

  GeneratedColumn<bool> get isDirty =>
      $composableBuilder(column: $table.isDirty, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get syncedAt =>
      $composableBuilder(column: $table.syncedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$ReadingClubsTableAnnotationComposer get clubId {
    final $$ReadingClubsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clubId,
        referencedTable: $db.readingClubs,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReadingClubsTableAnnotationComposer(
              $db: $db,
              $table: $db.readingClubs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> clubReadingProgressRefs<T extends Object>(
      Expression<T> Function($$ClubReadingProgressTableAnnotationComposer a)
          f) {
    final $$ClubReadingProgressTableAnnotationComposer composer =
        $composerBuilder(
            composer: this,
            getCurrentColumn: (t) => t.id,
            referencedTable: $db.clubReadingProgress,
            getReferencedColumn: (t) => t.bookId,
            builder: (joinBuilder,
                    {$addJoinBuilderToRootComposer,
                    $removeJoinBuilderFromRootComposer}) =>
                $$ClubReadingProgressTableAnnotationComposer(
                  $db: $db,
                  $table: $db.clubReadingProgress,
                  $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                  joinBuilder: joinBuilder,
                  $removeJoinBuilderFromRootComposer:
                      $removeJoinBuilderFromRootComposer,
                ));
    return f(composer);
  }

  Expression<T> sectionCommentsRefs<T extends Object>(
      Expression<T> Function($$SectionCommentsTableAnnotationComposer a) f) {
    final $$SectionCommentsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.sectionComments,
        getReferencedColumn: (t) => t.bookId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SectionCommentsTableAnnotationComposer(
              $db: $db,
              $table: $db.sectionComments,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$ClubBooksTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ClubBooksTable,
    ClubBook,
    $$ClubBooksTableFilterComposer,
    $$ClubBooksTableOrderingComposer,
    $$ClubBooksTableAnnotationComposer,
    $$ClubBooksTableCreateCompanionBuilder,
    $$ClubBooksTableUpdateCompanionBuilder,
    (ClubBook, $$ClubBooksTableReferences),
    ClubBook,
    PrefetchHooks Function(
        {bool clubId,
        bool clubReadingProgressRefs,
        bool sectionCommentsRefs})> {
  $$ClubBooksTableTableManager(_$AppDatabase db, $ClubBooksTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ClubBooksTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ClubBooksTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ClubBooksTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String?> remoteId = const Value.absent(),
            Value<int> clubId = const Value.absent(),
            Value<String> clubUuid = const Value.absent(),
            Value<String> bookUuid = const Value.absent(),
            Value<int> orderPosition = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<String> sectionMode = const Value.absent(),
            Value<int> totalChapters = const Value.absent(),
            Value<String> sections = const Value.absent(),
            Value<DateTime?> startDate = const Value.absent(),
            Value<DateTime?> endDate = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              ClubBooksCompanion(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            clubId: clubId,
            clubUuid: clubUuid,
            bookUuid: bookUuid,
            orderPosition: orderPosition,
            status: status,
            sectionMode: sectionMode,
            totalChapters: totalChapters,
            sections: sections,
            startDate: startDate,
            endDate: endDate,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            Value<String?> remoteId = const Value.absent(),
            required int clubId,
            required String clubUuid,
            required String bookUuid,
            Value<int> orderPosition = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<String> sectionMode = const Value.absent(),
            required int totalChapters,
            required String sections,
            Value<DateTime?> startDate = const Value.absent(),
            Value<DateTime?> endDate = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              ClubBooksCompanion.insert(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            clubId: clubId,
            clubUuid: clubUuid,
            bookUuid: bookUuid,
            orderPosition: orderPosition,
            status: status,
            sectionMode: sectionMode,
            totalChapters: totalChapters,
            sections: sections,
            startDate: startDate,
            endDate: endDate,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$ClubBooksTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {clubId = false,
              clubReadingProgressRefs = false,
              sectionCommentsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (clubReadingProgressRefs) db.clubReadingProgress,
                if (sectionCommentsRefs) db.sectionComments
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (clubId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.clubId,
                    referencedTable:
                        $$ClubBooksTableReferences._clubIdTable(db),
                    referencedColumn:
                        $$ClubBooksTableReferences._clubIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (clubReadingProgressRefs)
                    await $_getPrefetchedData<ClubBook, $ClubBooksTable,
                            ClubReadingProgressData>(
                        currentTable: table,
                        referencedTable: $$ClubBooksTableReferences
                            ._clubReadingProgressRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ClubBooksTableReferences(db, table, p0)
                                .clubReadingProgressRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.bookId == item.id),
                        typedResults: items),
                  if (sectionCommentsRefs)
                    await $_getPrefetchedData<ClubBook, $ClubBooksTable,
                            SectionComment>(
                        currentTable: table,
                        referencedTable: $$ClubBooksTableReferences
                            ._sectionCommentsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$ClubBooksTableReferences(db, table, p0)
                                .sectionCommentsRefs,
                        referencedItemsForCurrentItem: (item,
                                referencedItems) =>
                            referencedItems.where((e) => e.bookId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$ClubBooksTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ClubBooksTable,
    ClubBook,
    $$ClubBooksTableFilterComposer,
    $$ClubBooksTableOrderingComposer,
    $$ClubBooksTableAnnotationComposer,
    $$ClubBooksTableCreateCompanionBuilder,
    $$ClubBooksTableUpdateCompanionBuilder,
    (ClubBook, $$ClubBooksTableReferences),
    ClubBook,
    PrefetchHooks Function(
        {bool clubId, bool clubReadingProgressRefs, bool sectionCommentsRefs})>;
typedef $$ClubReadingProgressTableCreateCompanionBuilder
    = ClubReadingProgressCompanion Function({
  Value<int> id,
  required String uuid,
  required int clubId,
  required String clubUuid,
  required int bookId,
  required String bookUuid,
  required int userId,
  Value<String?> userRemoteId,
  Value<String?> remoteId,
  Value<String> status,
  Value<int> currentChapter,
  Value<int> currentSection,
  Value<bool> isDirty,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});
typedef $$ClubReadingProgressTableUpdateCompanionBuilder
    = ClubReadingProgressCompanion Function({
  Value<int> id,
  Value<String> uuid,
  Value<int> clubId,
  Value<String> clubUuid,
  Value<int> bookId,
  Value<String> bookUuid,
  Value<int> userId,
  Value<String?> userRemoteId,
  Value<String?> remoteId,
  Value<String> status,
  Value<int> currentChapter,
  Value<int> currentSection,
  Value<bool> isDirty,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

final class $$ClubReadingProgressTableReferences extends BaseReferences<
    _$AppDatabase, $ClubReadingProgressTable, ClubReadingProgressData> {
  $$ClubReadingProgressTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $ReadingClubsTable _clubIdTable(_$AppDatabase db) =>
      db.readingClubs.createAlias($_aliasNameGenerator(
          db.clubReadingProgress.clubId, db.readingClubs.id));

  $$ReadingClubsTableProcessedTableManager get clubId {
    final $_column = $_itemColumn<int>('club_id')!;

    final manager = $$ReadingClubsTableTableManager($_db, $_db.readingClubs)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_clubIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $ClubBooksTable _bookIdTable(_$AppDatabase db) =>
      db.clubBooks.createAlias(
          $_aliasNameGenerator(db.clubReadingProgress.bookId, db.clubBooks.id));

  $$ClubBooksTableProcessedTableManager get bookId {
    final $_column = $_itemColumn<int>('book_id')!;

    final manager = $$ClubBooksTableTableManager($_db, $_db.clubBooks)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bookIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $LocalUsersTable _userIdTable(_$AppDatabase db) =>
      db.localUsers.createAlias($_aliasNameGenerator(
          db.clubReadingProgress.userId, db.localUsers.id));

  $$LocalUsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<int>('user_id')!;

    final manager = $$LocalUsersTableTableManager($_db, $_db.localUsers)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$ClubReadingProgressTableFilterComposer
    extends Composer<_$AppDatabase, $ClubReadingProgressTable> {
  $$ClubReadingProgressTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get clubUuid => $composableBuilder(
      column: $table.clubUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get bookUuid => $composableBuilder(
      column: $table.bookUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get userRemoteId => $composableBuilder(
      column: $table.userRemoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get currentChapter => $composableBuilder(
      column: $table.currentChapter,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get currentSection => $composableBuilder(
      column: $table.currentSection,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $$ReadingClubsTableFilterComposer get clubId {
    final $$ReadingClubsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clubId,
        referencedTable: $db.readingClubs,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReadingClubsTableFilterComposer(
              $db: $db,
              $table: $db.readingClubs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$ClubBooksTableFilterComposer get bookId {
    final $$ClubBooksTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.bookId,
        referencedTable: $db.clubBooks,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClubBooksTableFilterComposer(
              $db: $db,
              $table: $db.clubBooks,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableFilterComposer get userId {
    final $$LocalUsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.userId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableFilterComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ClubReadingProgressTableOrderingComposer
    extends Composer<_$AppDatabase, $ClubReadingProgressTable> {
  $$ClubReadingProgressTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get clubUuid => $composableBuilder(
      column: $table.clubUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get bookUuid => $composableBuilder(
      column: $table.bookUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get userRemoteId => $composableBuilder(
      column: $table.userRemoteId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get currentChapter => $composableBuilder(
      column: $table.currentChapter,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get currentSection => $composableBuilder(
      column: $table.currentSection,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $$ReadingClubsTableOrderingComposer get clubId {
    final $$ReadingClubsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clubId,
        referencedTable: $db.readingClubs,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReadingClubsTableOrderingComposer(
              $db: $db,
              $table: $db.readingClubs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$ClubBooksTableOrderingComposer get bookId {
    final $$ClubBooksTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.bookId,
        referencedTable: $db.clubBooks,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClubBooksTableOrderingComposer(
              $db: $db,
              $table: $db.clubBooks,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableOrderingComposer get userId {
    final $$LocalUsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.userId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableOrderingComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ClubReadingProgressTableAnnotationComposer
    extends Composer<_$AppDatabase, $ClubReadingProgressTable> {
  $$ClubReadingProgressTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get clubUuid =>
      $composableBuilder(column: $table.clubUuid, builder: (column) => column);

  GeneratedColumn<String> get bookUuid =>
      $composableBuilder(column: $table.bookUuid, builder: (column) => column);

  GeneratedColumn<String> get userRemoteId => $composableBuilder(
      column: $table.userRemoteId, builder: (column) => column);

  GeneratedColumn<String> get remoteId =>
      $composableBuilder(column: $table.remoteId, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<int> get currentChapter => $composableBuilder(
      column: $table.currentChapter, builder: (column) => column);

  GeneratedColumn<int> get currentSection => $composableBuilder(
      column: $table.currentSection, builder: (column) => column);

  GeneratedColumn<bool> get isDirty =>
      $composableBuilder(column: $table.isDirty, builder: (column) => column);

  GeneratedColumn<DateTime> get syncedAt =>
      $composableBuilder(column: $table.syncedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$ReadingClubsTableAnnotationComposer get clubId {
    final $$ReadingClubsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clubId,
        referencedTable: $db.readingClubs,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReadingClubsTableAnnotationComposer(
              $db: $db,
              $table: $db.readingClubs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$ClubBooksTableAnnotationComposer get bookId {
    final $$ClubBooksTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.bookId,
        referencedTable: $db.clubBooks,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClubBooksTableAnnotationComposer(
              $db: $db,
              $table: $db.clubBooks,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableAnnotationComposer get userId {
    final $$LocalUsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.userId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableAnnotationComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ClubReadingProgressTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ClubReadingProgressTable,
    ClubReadingProgressData,
    $$ClubReadingProgressTableFilterComposer,
    $$ClubReadingProgressTableOrderingComposer,
    $$ClubReadingProgressTableAnnotationComposer,
    $$ClubReadingProgressTableCreateCompanionBuilder,
    $$ClubReadingProgressTableUpdateCompanionBuilder,
    (ClubReadingProgressData, $$ClubReadingProgressTableReferences),
    ClubReadingProgressData,
    PrefetchHooks Function({bool clubId, bool bookId, bool userId})> {
  $$ClubReadingProgressTableTableManager(
      _$AppDatabase db, $ClubReadingProgressTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ClubReadingProgressTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ClubReadingProgressTableOrderingComposer(
                  $db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ClubReadingProgressTableAnnotationComposer(
                  $db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<int> clubId = const Value.absent(),
            Value<String> clubUuid = const Value.absent(),
            Value<int> bookId = const Value.absent(),
            Value<String> bookUuid = const Value.absent(),
            Value<int> userId = const Value.absent(),
            Value<String?> userRemoteId = const Value.absent(),
            Value<String?> remoteId = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<int> currentChapter = const Value.absent(),
            Value<int> currentSection = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              ClubReadingProgressCompanion(
            id: id,
            uuid: uuid,
            clubId: clubId,
            clubUuid: clubUuid,
            bookId: bookId,
            bookUuid: bookUuid,
            userId: userId,
            userRemoteId: userRemoteId,
            remoteId: remoteId,
            status: status,
            currentChapter: currentChapter,
            currentSection: currentSection,
            isDirty: isDirty,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            required int clubId,
            required String clubUuid,
            required int bookId,
            required String bookUuid,
            required int userId,
            Value<String?> userRemoteId = const Value.absent(),
            Value<String?> remoteId = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<int> currentChapter = const Value.absent(),
            Value<int> currentSection = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              ClubReadingProgressCompanion.insert(
            id: id,
            uuid: uuid,
            clubId: clubId,
            clubUuid: clubUuid,
            bookId: bookId,
            bookUuid: bookUuid,
            userId: userId,
            userRemoteId: userRemoteId,
            remoteId: remoteId,
            status: status,
            currentChapter: currentChapter,
            currentSection: currentSection,
            isDirty: isDirty,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$ClubReadingProgressTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {clubId = false, bookId = false, userId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (clubId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.clubId,
                    referencedTable:
                        $$ClubReadingProgressTableReferences._clubIdTable(db),
                    referencedColumn: $$ClubReadingProgressTableReferences
                        ._clubIdTable(db)
                        .id,
                  ) as T;
                }
                if (bookId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.bookId,
                    referencedTable:
                        $$ClubReadingProgressTableReferences._bookIdTable(db),
                    referencedColumn: $$ClubReadingProgressTableReferences
                        ._bookIdTable(db)
                        .id,
                  ) as T;
                }
                if (userId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.userId,
                    referencedTable:
                        $$ClubReadingProgressTableReferences._userIdTable(db),
                    referencedColumn: $$ClubReadingProgressTableReferences
                        ._userIdTable(db)
                        .id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$ClubReadingProgressTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ClubReadingProgressTable,
    ClubReadingProgressData,
    $$ClubReadingProgressTableFilterComposer,
    $$ClubReadingProgressTableOrderingComposer,
    $$ClubReadingProgressTableAnnotationComposer,
    $$ClubReadingProgressTableCreateCompanionBuilder,
    $$ClubReadingProgressTableUpdateCompanionBuilder,
    (ClubReadingProgressData, $$ClubReadingProgressTableReferences),
    ClubReadingProgressData,
    PrefetchHooks Function({bool clubId, bool bookId, bool userId})>;
typedef $$BookProposalsTableCreateCompanionBuilder = BookProposalsCompanion
    Function({
  Value<int> id,
  required String uuid,
  Value<String?> remoteId,
  required int clubId,
  required String clubUuid,
  required String bookUuid,
  required int proposedByUserId,
  Value<String?> proposedByRemoteId,
  Value<String?> title,
  Value<String?> author,
  Value<String?> isbn,
  Value<String?> coverUrl,
  Value<DateTime?> closingDate,
  required int totalChapters,
  Value<String> votes,
  Value<int> voteCount,
  Value<String> status,
  Value<DateTime?> closeDate,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});
typedef $$BookProposalsTableUpdateCompanionBuilder = BookProposalsCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String?> remoteId,
  Value<int> clubId,
  Value<String> clubUuid,
  Value<String> bookUuid,
  Value<int> proposedByUserId,
  Value<String?> proposedByRemoteId,
  Value<String?> title,
  Value<String?> author,
  Value<String?> isbn,
  Value<String?> coverUrl,
  Value<DateTime?> closingDate,
  Value<int> totalChapters,
  Value<String> votes,
  Value<int> voteCount,
  Value<String> status,
  Value<DateTime?> closeDate,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

final class $$BookProposalsTableReferences
    extends BaseReferences<_$AppDatabase, $BookProposalsTable, BookProposal> {
  $$BookProposalsTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $ReadingClubsTable _clubIdTable(_$AppDatabase db) =>
      db.readingClubs.createAlias(
          $_aliasNameGenerator(db.bookProposals.clubId, db.readingClubs.id));

  $$ReadingClubsTableProcessedTableManager get clubId {
    final $_column = $_itemColumn<int>('club_id')!;

    final manager = $$ReadingClubsTableTableManager($_db, $_db.readingClubs)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_clubIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $LocalUsersTable _proposedByUserIdTable(_$AppDatabase db) =>
      db.localUsers.createAlias($_aliasNameGenerator(
          db.bookProposals.proposedByUserId, db.localUsers.id));

  $$LocalUsersTableProcessedTableManager get proposedByUserId {
    final $_column = $_itemColumn<int>('proposed_by_user_id')!;

    final manager = $$LocalUsersTableTableManager($_db, $_db.localUsers)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_proposedByUserIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$BookProposalsTableFilterComposer
    extends Composer<_$AppDatabase, $BookProposalsTable> {
  $$BookProposalsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get clubUuid => $composableBuilder(
      column: $table.clubUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get bookUuid => $composableBuilder(
      column: $table.bookUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get proposedByRemoteId => $composableBuilder(
      column: $table.proposedByRemoteId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get title => $composableBuilder(
      column: $table.title, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get author => $composableBuilder(
      column: $table.author, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get isbn => $composableBuilder(
      column: $table.isbn, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get coverUrl => $composableBuilder(
      column: $table.coverUrl, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get closingDate => $composableBuilder(
      column: $table.closingDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get totalChapters => $composableBuilder(
      column: $table.totalChapters, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get votes => $composableBuilder(
      column: $table.votes, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get voteCount => $composableBuilder(
      column: $table.voteCount, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get closeDate => $composableBuilder(
      column: $table.closeDate, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $$ReadingClubsTableFilterComposer get clubId {
    final $$ReadingClubsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clubId,
        referencedTable: $db.readingClubs,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReadingClubsTableFilterComposer(
              $db: $db,
              $table: $db.readingClubs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableFilterComposer get proposedByUserId {
    final $$LocalUsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.proposedByUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableFilterComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$BookProposalsTableOrderingComposer
    extends Composer<_$AppDatabase, $BookProposalsTable> {
  $$BookProposalsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get clubUuid => $composableBuilder(
      column: $table.clubUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get bookUuid => $composableBuilder(
      column: $table.bookUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get proposedByRemoteId => $composableBuilder(
      column: $table.proposedByRemoteId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get title => $composableBuilder(
      column: $table.title, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get author => $composableBuilder(
      column: $table.author, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get isbn => $composableBuilder(
      column: $table.isbn, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get coverUrl => $composableBuilder(
      column: $table.coverUrl, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get closingDate => $composableBuilder(
      column: $table.closingDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get totalChapters => $composableBuilder(
      column: $table.totalChapters,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get votes => $composableBuilder(
      column: $table.votes, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get voteCount => $composableBuilder(
      column: $table.voteCount, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get status => $composableBuilder(
      column: $table.status, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get closeDate => $composableBuilder(
      column: $table.closeDate, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $$ReadingClubsTableOrderingComposer get clubId {
    final $$ReadingClubsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clubId,
        referencedTable: $db.readingClubs,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReadingClubsTableOrderingComposer(
              $db: $db,
              $table: $db.readingClubs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableOrderingComposer get proposedByUserId {
    final $$LocalUsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.proposedByUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableOrderingComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$BookProposalsTableAnnotationComposer
    extends Composer<_$AppDatabase, $BookProposalsTable> {
  $$BookProposalsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get remoteId =>
      $composableBuilder(column: $table.remoteId, builder: (column) => column);

  GeneratedColumn<String> get clubUuid =>
      $composableBuilder(column: $table.clubUuid, builder: (column) => column);

  GeneratedColumn<String> get bookUuid =>
      $composableBuilder(column: $table.bookUuid, builder: (column) => column);

  GeneratedColumn<String> get proposedByRemoteId => $composableBuilder(
      column: $table.proposedByRemoteId, builder: (column) => column);

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<String> get author =>
      $composableBuilder(column: $table.author, builder: (column) => column);

  GeneratedColumn<String> get isbn =>
      $composableBuilder(column: $table.isbn, builder: (column) => column);

  GeneratedColumn<String> get coverUrl =>
      $composableBuilder(column: $table.coverUrl, builder: (column) => column);

  GeneratedColumn<DateTime> get closingDate => $composableBuilder(
      column: $table.closingDate, builder: (column) => column);

  GeneratedColumn<int> get totalChapters => $composableBuilder(
      column: $table.totalChapters, builder: (column) => column);

  GeneratedColumn<String> get votes =>
      $composableBuilder(column: $table.votes, builder: (column) => column);

  GeneratedColumn<int> get voteCount =>
      $composableBuilder(column: $table.voteCount, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get closeDate =>
      $composableBuilder(column: $table.closeDate, builder: (column) => column);

  GeneratedColumn<bool> get isDirty =>
      $composableBuilder(column: $table.isDirty, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get syncedAt =>
      $composableBuilder(column: $table.syncedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$ReadingClubsTableAnnotationComposer get clubId {
    final $$ReadingClubsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clubId,
        referencedTable: $db.readingClubs,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReadingClubsTableAnnotationComposer(
              $db: $db,
              $table: $db.readingClubs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableAnnotationComposer get proposedByUserId {
    final $$LocalUsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.proposedByUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableAnnotationComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$BookProposalsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $BookProposalsTable,
    BookProposal,
    $$BookProposalsTableFilterComposer,
    $$BookProposalsTableOrderingComposer,
    $$BookProposalsTableAnnotationComposer,
    $$BookProposalsTableCreateCompanionBuilder,
    $$BookProposalsTableUpdateCompanionBuilder,
    (BookProposal, $$BookProposalsTableReferences),
    BookProposal,
    PrefetchHooks Function({bool clubId, bool proposedByUserId})> {
  $$BookProposalsTableTableManager(_$AppDatabase db, $BookProposalsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BookProposalsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BookProposalsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BookProposalsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String?> remoteId = const Value.absent(),
            Value<int> clubId = const Value.absent(),
            Value<String> clubUuid = const Value.absent(),
            Value<String> bookUuid = const Value.absent(),
            Value<int> proposedByUserId = const Value.absent(),
            Value<String?> proposedByRemoteId = const Value.absent(),
            Value<String?> title = const Value.absent(),
            Value<String?> author = const Value.absent(),
            Value<String?> isbn = const Value.absent(),
            Value<String?> coverUrl = const Value.absent(),
            Value<DateTime?> closingDate = const Value.absent(),
            Value<int> totalChapters = const Value.absent(),
            Value<String> votes = const Value.absent(),
            Value<int> voteCount = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<DateTime?> closeDate = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              BookProposalsCompanion(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            clubId: clubId,
            clubUuid: clubUuid,
            bookUuid: bookUuid,
            proposedByUserId: proposedByUserId,
            proposedByRemoteId: proposedByRemoteId,
            title: title,
            author: author,
            isbn: isbn,
            coverUrl: coverUrl,
            closingDate: closingDate,
            totalChapters: totalChapters,
            votes: votes,
            voteCount: voteCount,
            status: status,
            closeDate: closeDate,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            Value<String?> remoteId = const Value.absent(),
            required int clubId,
            required String clubUuid,
            required String bookUuid,
            required int proposedByUserId,
            Value<String?> proposedByRemoteId = const Value.absent(),
            Value<String?> title = const Value.absent(),
            Value<String?> author = const Value.absent(),
            Value<String?> isbn = const Value.absent(),
            Value<String?> coverUrl = const Value.absent(),
            Value<DateTime?> closingDate = const Value.absent(),
            required int totalChapters,
            Value<String> votes = const Value.absent(),
            Value<int> voteCount = const Value.absent(),
            Value<String> status = const Value.absent(),
            Value<DateTime?> closeDate = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              BookProposalsCompanion.insert(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            clubId: clubId,
            clubUuid: clubUuid,
            bookUuid: bookUuid,
            proposedByUserId: proposedByUserId,
            proposedByRemoteId: proposedByRemoteId,
            title: title,
            author: author,
            isbn: isbn,
            coverUrl: coverUrl,
            closingDate: closingDate,
            totalChapters: totalChapters,
            votes: votes,
            voteCount: voteCount,
            status: status,
            closeDate: closeDate,
            isDirty: isDirty,
            isDeleted: isDeleted,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$BookProposalsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({clubId = false, proposedByUserId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (clubId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.clubId,
                    referencedTable:
                        $$BookProposalsTableReferences._clubIdTable(db),
                    referencedColumn:
                        $$BookProposalsTableReferences._clubIdTable(db).id,
                  ) as T;
                }
                if (proposedByUserId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.proposedByUserId,
                    referencedTable: $$BookProposalsTableReferences
                        ._proposedByUserIdTable(db),
                    referencedColumn: $$BookProposalsTableReferences
                        ._proposedByUserIdTable(db)
                        .id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$BookProposalsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $BookProposalsTable,
    BookProposal,
    $$BookProposalsTableFilterComposer,
    $$BookProposalsTableOrderingComposer,
    $$BookProposalsTableAnnotationComposer,
    $$BookProposalsTableCreateCompanionBuilder,
    $$BookProposalsTableUpdateCompanionBuilder,
    (BookProposal, $$BookProposalsTableReferences),
    BookProposal,
    PrefetchHooks Function({bool clubId, bool proposedByUserId})>;
typedef $$SectionCommentsTableCreateCompanionBuilder = SectionCommentsCompanion
    Function({
  Value<int> id,
  required String uuid,
  Value<String?> remoteId,
  required int clubId,
  required String clubUuid,
  required int bookId,
  required String bookUuid,
  required int sectionNumber,
  required int userId,
  Value<String?> userRemoteId,
  Value<String?> authorRemoteId,
  required String content,
  Value<int> reportsCount,
  Value<bool> isHidden,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> deletedAt,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});
typedef $$SectionCommentsTableUpdateCompanionBuilder = SectionCommentsCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String?> remoteId,
  Value<int> clubId,
  Value<String> clubUuid,
  Value<int> bookId,
  Value<String> bookUuid,
  Value<int> sectionNumber,
  Value<int> userId,
  Value<String?> userRemoteId,
  Value<String?> authorRemoteId,
  Value<String> content,
  Value<int> reportsCount,
  Value<bool> isHidden,
  Value<bool> isDirty,
  Value<bool> isDeleted,
  Value<DateTime?> deletedAt,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
  Value<DateTime> updatedAt,
});

final class $$SectionCommentsTableReferences extends BaseReferences<
    _$AppDatabase, $SectionCommentsTable, SectionComment> {
  $$SectionCommentsTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $ReadingClubsTable _clubIdTable(_$AppDatabase db) =>
      db.readingClubs.createAlias(
          $_aliasNameGenerator(db.sectionComments.clubId, db.readingClubs.id));

  $$ReadingClubsTableProcessedTableManager get clubId {
    final $_column = $_itemColumn<int>('club_id')!;

    final manager = $$ReadingClubsTableTableManager($_db, $_db.readingClubs)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_clubIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $ClubBooksTable _bookIdTable(_$AppDatabase db) =>
      db.clubBooks.createAlias(
          $_aliasNameGenerator(db.sectionComments.bookId, db.clubBooks.id));

  $$ClubBooksTableProcessedTableManager get bookId {
    final $_column = $_itemColumn<int>('book_id')!;

    final manager = $$ClubBooksTableTableManager($_db, $_db.clubBooks)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_bookIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $LocalUsersTable _userIdTable(_$AppDatabase db) =>
      db.localUsers.createAlias(
          $_aliasNameGenerator(db.sectionComments.userId, db.localUsers.id));

  $$LocalUsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<int>('user_id')!;

    final manager = $$LocalUsersTableTableManager($_db, $_db.localUsers)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static MultiTypedResultKey<$CommentReportsTable, List<CommentReport>>
      _commentReportsRefsTable(_$AppDatabase db) =>
          MultiTypedResultKey.fromTable(db.commentReports,
              aliasName: $_aliasNameGenerator(
                  db.sectionComments.id, db.commentReports.commentId));

  $$CommentReportsTableProcessedTableManager get commentReportsRefs {
    final manager = $$CommentReportsTableTableManager($_db, $_db.commentReports)
        .filter((f) => f.commentId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_commentReportsRefsTable($_db));
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: cache));
  }
}

class $$SectionCommentsTableFilterComposer
    extends Composer<_$AppDatabase, $SectionCommentsTable> {
  $$SectionCommentsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get clubUuid => $composableBuilder(
      column: $table.clubUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get bookUuid => $composableBuilder(
      column: $table.bookUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get sectionNumber => $composableBuilder(
      column: $table.sectionNumber, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get userRemoteId => $composableBuilder(
      column: $table.userRemoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get authorRemoteId => $composableBuilder(
      column: $table.authorRemoteId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get content => $composableBuilder(
      column: $table.content, builder: (column) => ColumnFilters(column));

  ColumnFilters<int> get reportsCount => $composableBuilder(
      column: $table.reportsCount, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isHidden => $composableBuilder(
      column: $table.isHidden, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get deletedAt => $composableBuilder(
      column: $table.deletedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnFilters(column));

  $$ReadingClubsTableFilterComposer get clubId {
    final $$ReadingClubsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clubId,
        referencedTable: $db.readingClubs,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReadingClubsTableFilterComposer(
              $db: $db,
              $table: $db.readingClubs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$ClubBooksTableFilterComposer get bookId {
    final $$ClubBooksTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.bookId,
        referencedTable: $db.clubBooks,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClubBooksTableFilterComposer(
              $db: $db,
              $table: $db.clubBooks,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableFilterComposer get userId {
    final $$LocalUsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.userId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableFilterComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<bool> commentReportsRefs(
      Expression<bool> Function($$CommentReportsTableFilterComposer f) f) {
    final $$CommentReportsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.commentReports,
        getReferencedColumn: (t) => t.commentId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$CommentReportsTableFilterComposer(
              $db: $db,
              $table: $db.commentReports,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$SectionCommentsTableOrderingComposer
    extends Composer<_$AppDatabase, $SectionCommentsTable> {
  $$SectionCommentsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get clubUuid => $composableBuilder(
      column: $table.clubUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get bookUuid => $composableBuilder(
      column: $table.bookUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get sectionNumber => $composableBuilder(
      column: $table.sectionNumber,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get userRemoteId => $composableBuilder(
      column: $table.userRemoteId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get authorRemoteId => $composableBuilder(
      column: $table.authorRemoteId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get content => $composableBuilder(
      column: $table.content, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<int> get reportsCount => $composableBuilder(
      column: $table.reportsCount,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isHidden => $composableBuilder(
      column: $table.isHidden, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
      column: $table.isDeleted, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get deletedAt => $composableBuilder(
      column: $table.deletedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
      column: $table.updatedAt, builder: (column) => ColumnOrderings(column));

  $$ReadingClubsTableOrderingComposer get clubId {
    final $$ReadingClubsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clubId,
        referencedTable: $db.readingClubs,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReadingClubsTableOrderingComposer(
              $db: $db,
              $table: $db.readingClubs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$ClubBooksTableOrderingComposer get bookId {
    final $$ClubBooksTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.bookId,
        referencedTable: $db.clubBooks,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClubBooksTableOrderingComposer(
              $db: $db,
              $table: $db.clubBooks,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableOrderingComposer get userId {
    final $$LocalUsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.userId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableOrderingComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$SectionCommentsTableAnnotationComposer
    extends Composer<_$AppDatabase, $SectionCommentsTable> {
  $$SectionCommentsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get remoteId =>
      $composableBuilder(column: $table.remoteId, builder: (column) => column);

  GeneratedColumn<String> get clubUuid =>
      $composableBuilder(column: $table.clubUuid, builder: (column) => column);

  GeneratedColumn<String> get bookUuid =>
      $composableBuilder(column: $table.bookUuid, builder: (column) => column);

  GeneratedColumn<int> get sectionNumber => $composableBuilder(
      column: $table.sectionNumber, builder: (column) => column);

  GeneratedColumn<String> get userRemoteId => $composableBuilder(
      column: $table.userRemoteId, builder: (column) => column);

  GeneratedColumn<String> get authorRemoteId => $composableBuilder(
      column: $table.authorRemoteId, builder: (column) => column);

  GeneratedColumn<String> get content =>
      $composableBuilder(column: $table.content, builder: (column) => column);

  GeneratedColumn<int> get reportsCount => $composableBuilder(
      column: $table.reportsCount, builder: (column) => column);

  GeneratedColumn<bool> get isHidden =>
      $composableBuilder(column: $table.isHidden, builder: (column) => column);

  GeneratedColumn<bool> get isDirty =>
      $composableBuilder(column: $table.isDirty, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get deletedAt =>
      $composableBuilder(column: $table.deletedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get syncedAt =>
      $composableBuilder(column: $table.syncedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$ReadingClubsTableAnnotationComposer get clubId {
    final $$ReadingClubsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clubId,
        referencedTable: $db.readingClubs,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReadingClubsTableAnnotationComposer(
              $db: $db,
              $table: $db.readingClubs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$ClubBooksTableAnnotationComposer get bookId {
    final $$ClubBooksTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.bookId,
        referencedTable: $db.clubBooks,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ClubBooksTableAnnotationComposer(
              $db: $db,
              $table: $db.clubBooks,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableAnnotationComposer get userId {
    final $$LocalUsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.userId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableAnnotationComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  Expression<T> commentReportsRefs<T extends Object>(
      Expression<T> Function($$CommentReportsTableAnnotationComposer a) f) {
    final $$CommentReportsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.id,
        referencedTable: $db.commentReports,
        getReferencedColumn: (t) => t.commentId,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$CommentReportsTableAnnotationComposer(
              $db: $db,
              $table: $db.commentReports,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return f(composer);
  }
}

class $$SectionCommentsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $SectionCommentsTable,
    SectionComment,
    $$SectionCommentsTableFilterComposer,
    $$SectionCommentsTableOrderingComposer,
    $$SectionCommentsTableAnnotationComposer,
    $$SectionCommentsTableCreateCompanionBuilder,
    $$SectionCommentsTableUpdateCompanionBuilder,
    (SectionComment, $$SectionCommentsTableReferences),
    SectionComment,
    PrefetchHooks Function(
        {bool clubId, bool bookId, bool userId, bool commentReportsRefs})> {
  $$SectionCommentsTableTableManager(
      _$AppDatabase db, $SectionCommentsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SectionCommentsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SectionCommentsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SectionCommentsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String?> remoteId = const Value.absent(),
            Value<int> clubId = const Value.absent(),
            Value<String> clubUuid = const Value.absent(),
            Value<int> bookId = const Value.absent(),
            Value<String> bookUuid = const Value.absent(),
            Value<int> sectionNumber = const Value.absent(),
            Value<int> userId = const Value.absent(),
            Value<String?> userRemoteId = const Value.absent(),
            Value<String?> authorRemoteId = const Value.absent(),
            Value<String> content = const Value.absent(),
            Value<int> reportsCount = const Value.absent(),
            Value<bool> isHidden = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> deletedAt = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              SectionCommentsCompanion(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            clubId: clubId,
            clubUuid: clubUuid,
            bookId: bookId,
            bookUuid: bookUuid,
            sectionNumber: sectionNumber,
            userId: userId,
            userRemoteId: userRemoteId,
            authorRemoteId: authorRemoteId,
            content: content,
            reportsCount: reportsCount,
            isHidden: isHidden,
            isDirty: isDirty,
            isDeleted: isDeleted,
            deletedAt: deletedAt,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            Value<String?> remoteId = const Value.absent(),
            required int clubId,
            required String clubUuid,
            required int bookId,
            required String bookUuid,
            required int sectionNumber,
            required int userId,
            Value<String?> userRemoteId = const Value.absent(),
            Value<String?> authorRemoteId = const Value.absent(),
            required String content,
            Value<int> reportsCount = const Value.absent(),
            Value<bool> isHidden = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<bool> isDeleted = const Value.absent(),
            Value<DateTime?> deletedAt = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
            Value<DateTime> updatedAt = const Value.absent(),
          }) =>
              SectionCommentsCompanion.insert(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            clubId: clubId,
            clubUuid: clubUuid,
            bookId: bookId,
            bookUuid: bookUuid,
            sectionNumber: sectionNumber,
            userId: userId,
            userRemoteId: userRemoteId,
            authorRemoteId: authorRemoteId,
            content: content,
            reportsCount: reportsCount,
            isHidden: isHidden,
            isDirty: isDirty,
            isDeleted: isDeleted,
            deletedAt: deletedAt,
            syncedAt: syncedAt,
            createdAt: createdAt,
            updatedAt: updatedAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$SectionCommentsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {clubId = false,
              bookId = false,
              userId = false,
              commentReportsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [
                if (commentReportsRefs) db.commentReports
              ],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (clubId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.clubId,
                    referencedTable:
                        $$SectionCommentsTableReferences._clubIdTable(db),
                    referencedColumn:
                        $$SectionCommentsTableReferences._clubIdTable(db).id,
                  ) as T;
                }
                if (bookId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.bookId,
                    referencedTable:
                        $$SectionCommentsTableReferences._bookIdTable(db),
                    referencedColumn:
                        $$SectionCommentsTableReferences._bookIdTable(db).id,
                  ) as T;
                }
                if (userId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.userId,
                    referencedTable:
                        $$SectionCommentsTableReferences._userIdTable(db),
                    referencedColumn:
                        $$SectionCommentsTableReferences._userIdTable(db).id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [
                  if (commentReportsRefs)
                    await $_getPrefetchedData<SectionComment,
                            $SectionCommentsTable, CommentReport>(
                        currentTable: table,
                        referencedTable: $$SectionCommentsTableReferences
                            ._commentReportsRefsTable(db),
                        managerFromTypedResult: (p0) =>
                            $$SectionCommentsTableReferences(db, table, p0)
                                .commentReportsRefs,
                        referencedItemsForCurrentItem:
                            (item, referencedItems) => referencedItems
                                .where((e) => e.commentId == item.id),
                        typedResults: items)
                ];
              },
            );
          },
        ));
}

typedef $$SectionCommentsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $SectionCommentsTable,
    SectionComment,
    $$SectionCommentsTableFilterComposer,
    $$SectionCommentsTableOrderingComposer,
    $$SectionCommentsTableAnnotationComposer,
    $$SectionCommentsTableCreateCompanionBuilder,
    $$SectionCommentsTableUpdateCompanionBuilder,
    (SectionComment, $$SectionCommentsTableReferences),
    SectionComment,
    PrefetchHooks Function(
        {bool clubId, bool bookId, bool userId, bool commentReportsRefs})>;
typedef $$CommentReportsTableCreateCompanionBuilder = CommentReportsCompanion
    Function({
  Value<int> id,
  required String uuid,
  Value<String?> remoteId,
  required int commentId,
  required String commentUuid,
  required int reportedByUserId,
  Value<String?> reportedByRemoteId,
  Value<String?> reason,
  Value<bool> isDirty,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
});
typedef $$CommentReportsTableUpdateCompanionBuilder = CommentReportsCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String?> remoteId,
  Value<int> commentId,
  Value<String> commentUuid,
  Value<int> reportedByUserId,
  Value<String?> reportedByRemoteId,
  Value<String?> reason,
  Value<bool> isDirty,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
});

final class $$CommentReportsTableReferences
    extends BaseReferences<_$AppDatabase, $CommentReportsTable, CommentReport> {
  $$CommentReportsTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $SectionCommentsTable _commentIdTable(_$AppDatabase db) =>
      db.sectionComments.createAlias($_aliasNameGenerator(
          db.commentReports.commentId, db.sectionComments.id));

  $$SectionCommentsTableProcessedTableManager get commentId {
    final $_column = $_itemColumn<int>('comment_id')!;

    final manager =
        $$SectionCommentsTableTableManager($_db, $_db.sectionComments)
            .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_commentIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $LocalUsersTable _reportedByUserIdTable(_$AppDatabase db) =>
      db.localUsers.createAlias($_aliasNameGenerator(
          db.commentReports.reportedByUserId, db.localUsers.id));

  $$LocalUsersTableProcessedTableManager get reportedByUserId {
    final $_column = $_itemColumn<int>('reported_by_user_id')!;

    final manager = $$LocalUsersTableTableManager($_db, $_db.localUsers)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_reportedByUserIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$CommentReportsTableFilterComposer
    extends Composer<_$AppDatabase, $CommentReportsTable> {
  $$CommentReportsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get commentUuid => $composableBuilder(
      column: $table.commentUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get reportedByRemoteId => $composableBuilder(
      column: $table.reportedByRemoteId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get reason => $composableBuilder(
      column: $table.reason, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  $$SectionCommentsTableFilterComposer get commentId {
    final $$SectionCommentsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.commentId,
        referencedTable: $db.sectionComments,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SectionCommentsTableFilterComposer(
              $db: $db,
              $table: $db.sectionComments,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableFilterComposer get reportedByUserId {
    final $$LocalUsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.reportedByUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableFilterComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$CommentReportsTableOrderingComposer
    extends Composer<_$AppDatabase, $CommentReportsTable> {
  $$CommentReportsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get commentUuid => $composableBuilder(
      column: $table.commentUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get reportedByRemoteId => $composableBuilder(
      column: $table.reportedByRemoteId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get reason => $composableBuilder(
      column: $table.reason, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  $$SectionCommentsTableOrderingComposer get commentId {
    final $$SectionCommentsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.commentId,
        referencedTable: $db.sectionComments,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SectionCommentsTableOrderingComposer(
              $db: $db,
              $table: $db.sectionComments,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableOrderingComposer get reportedByUserId {
    final $$LocalUsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.reportedByUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableOrderingComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$CommentReportsTableAnnotationComposer
    extends Composer<_$AppDatabase, $CommentReportsTable> {
  $$CommentReportsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get remoteId =>
      $composableBuilder(column: $table.remoteId, builder: (column) => column);

  GeneratedColumn<String> get commentUuid => $composableBuilder(
      column: $table.commentUuid, builder: (column) => column);

  GeneratedColumn<String> get reportedByRemoteId => $composableBuilder(
      column: $table.reportedByRemoteId, builder: (column) => column);

  GeneratedColumn<String> get reason =>
      $composableBuilder(column: $table.reason, builder: (column) => column);

  GeneratedColumn<bool> get isDirty =>
      $composableBuilder(column: $table.isDirty, builder: (column) => column);

  GeneratedColumn<DateTime> get syncedAt =>
      $composableBuilder(column: $table.syncedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$SectionCommentsTableAnnotationComposer get commentId {
    final $$SectionCommentsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.commentId,
        referencedTable: $db.sectionComments,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$SectionCommentsTableAnnotationComposer(
              $db: $db,
              $table: $db.sectionComments,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableAnnotationComposer get reportedByUserId {
    final $$LocalUsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.reportedByUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableAnnotationComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$CommentReportsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $CommentReportsTable,
    CommentReport,
    $$CommentReportsTableFilterComposer,
    $$CommentReportsTableOrderingComposer,
    $$CommentReportsTableAnnotationComposer,
    $$CommentReportsTableCreateCompanionBuilder,
    $$CommentReportsTableUpdateCompanionBuilder,
    (CommentReport, $$CommentReportsTableReferences),
    CommentReport,
    PrefetchHooks Function({bool commentId, bool reportedByUserId})> {
  $$CommentReportsTableTableManager(
      _$AppDatabase db, $CommentReportsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CommentReportsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CommentReportsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CommentReportsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String?> remoteId = const Value.absent(),
            Value<int> commentId = const Value.absent(),
            Value<String> commentUuid = const Value.absent(),
            Value<int> reportedByUserId = const Value.absent(),
            Value<String?> reportedByRemoteId = const Value.absent(),
            Value<String?> reason = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
          }) =>
              CommentReportsCompanion(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            commentId: commentId,
            commentUuid: commentUuid,
            reportedByUserId: reportedByUserId,
            reportedByRemoteId: reportedByRemoteId,
            reason: reason,
            isDirty: isDirty,
            syncedAt: syncedAt,
            createdAt: createdAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            Value<String?> remoteId = const Value.absent(),
            required int commentId,
            required String commentUuid,
            required int reportedByUserId,
            Value<String?> reportedByRemoteId = const Value.absent(),
            Value<String?> reason = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
          }) =>
              CommentReportsCompanion.insert(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            commentId: commentId,
            commentUuid: commentUuid,
            reportedByUserId: reportedByUserId,
            reportedByRemoteId: reportedByRemoteId,
            reason: reason,
            isDirty: isDirty,
            syncedAt: syncedAt,
            createdAt: createdAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$CommentReportsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: (
              {commentId = false, reportedByUserId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (commentId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.commentId,
                    referencedTable:
                        $$CommentReportsTableReferences._commentIdTable(db),
                    referencedColumn:
                        $$CommentReportsTableReferences._commentIdTable(db).id,
                  ) as T;
                }
                if (reportedByUserId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.reportedByUserId,
                    referencedTable: $$CommentReportsTableReferences
                        ._reportedByUserIdTable(db),
                    referencedColumn: $$CommentReportsTableReferences
                        ._reportedByUserIdTable(db)
                        .id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$CommentReportsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $CommentReportsTable,
    CommentReport,
    $$CommentReportsTableFilterComposer,
    $$CommentReportsTableOrderingComposer,
    $$CommentReportsTableAnnotationComposer,
    $$CommentReportsTableCreateCompanionBuilder,
    $$CommentReportsTableUpdateCompanionBuilder,
    (CommentReport, $$CommentReportsTableReferences),
    CommentReport,
    PrefetchHooks Function({bool commentId, bool reportedByUserId})>;
typedef $$ModerationLogsTableCreateCompanionBuilder = ModerationLogsCompanion
    Function({
  Value<int> id,
  required String uuid,
  Value<String?> remoteId,
  required int clubId,
  required String clubUuid,
  required String action,
  required int performedByUserId,
  Value<String?> performedByRemoteId,
  required String targetId,
  Value<String?> reason,
  Value<bool> isDirty,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
});
typedef $$ModerationLogsTableUpdateCompanionBuilder = ModerationLogsCompanion
    Function({
  Value<int> id,
  Value<String> uuid,
  Value<String?> remoteId,
  Value<int> clubId,
  Value<String> clubUuid,
  Value<String> action,
  Value<int> performedByUserId,
  Value<String?> performedByRemoteId,
  Value<String> targetId,
  Value<String?> reason,
  Value<bool> isDirty,
  Value<DateTime?> syncedAt,
  Value<DateTime> createdAt,
});

final class $$ModerationLogsTableReferences
    extends BaseReferences<_$AppDatabase, $ModerationLogsTable, ModerationLog> {
  $$ModerationLogsTableReferences(
      super.$_db, super.$_table, super.$_typedResult);

  static $ReadingClubsTable _clubIdTable(_$AppDatabase db) =>
      db.readingClubs.createAlias(
          $_aliasNameGenerator(db.moderationLogs.clubId, db.readingClubs.id));

  $$ReadingClubsTableProcessedTableManager get clubId {
    final $_column = $_itemColumn<int>('club_id')!;

    final manager = $$ReadingClubsTableTableManager($_db, $_db.readingClubs)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_clubIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }

  static $LocalUsersTable _performedByUserIdTable(_$AppDatabase db) =>
      db.localUsers.createAlias($_aliasNameGenerator(
          db.moderationLogs.performedByUserId, db.localUsers.id));

  $$LocalUsersTableProcessedTableManager get performedByUserId {
    final $_column = $_itemColumn<int>('performed_by_user_id')!;

    final manager = $$LocalUsersTableTableManager($_db, $_db.localUsers)
        .filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_performedByUserIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
        manager.$state.copyWith(prefetchedData: [item]));
  }
}

class $$ModerationLogsTableFilterComposer
    extends Composer<_$AppDatabase, $ModerationLogsTable> {
  $$ModerationLogsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get clubUuid => $composableBuilder(
      column: $table.clubUuid, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get action => $composableBuilder(
      column: $table.action, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get performedByRemoteId => $composableBuilder(
      column: $table.performedByRemoteId,
      builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get targetId => $composableBuilder(
      column: $table.targetId, builder: (column) => ColumnFilters(column));

  ColumnFilters<String> get reason => $composableBuilder(
      column: $table.reason, builder: (column) => ColumnFilters(column));

  ColumnFilters<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnFilters(column));

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnFilters(column));

  $$ReadingClubsTableFilterComposer get clubId {
    final $$ReadingClubsTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clubId,
        referencedTable: $db.readingClubs,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReadingClubsTableFilterComposer(
              $db: $db,
              $table: $db.readingClubs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableFilterComposer get performedByUserId {
    final $$LocalUsersTableFilterComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.performedByUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableFilterComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ModerationLogsTableOrderingComposer
    extends Composer<_$AppDatabase, $ModerationLogsTable> {
  $$ModerationLogsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
      column: $table.id, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get uuid => $composableBuilder(
      column: $table.uuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get remoteId => $composableBuilder(
      column: $table.remoteId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get clubUuid => $composableBuilder(
      column: $table.clubUuid, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get action => $composableBuilder(
      column: $table.action, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get performedByRemoteId => $composableBuilder(
      column: $table.performedByRemoteId,
      builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get targetId => $composableBuilder(
      column: $table.targetId, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<String> get reason => $composableBuilder(
      column: $table.reason, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<bool> get isDirty => $composableBuilder(
      column: $table.isDirty, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get syncedAt => $composableBuilder(
      column: $table.syncedAt, builder: (column) => ColumnOrderings(column));

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
      column: $table.createdAt, builder: (column) => ColumnOrderings(column));

  $$ReadingClubsTableOrderingComposer get clubId {
    final $$ReadingClubsTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clubId,
        referencedTable: $db.readingClubs,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReadingClubsTableOrderingComposer(
              $db: $db,
              $table: $db.readingClubs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableOrderingComposer get performedByUserId {
    final $$LocalUsersTableOrderingComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.performedByUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableOrderingComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ModerationLogsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ModerationLogsTable> {
  $$ModerationLogsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get uuid =>
      $composableBuilder(column: $table.uuid, builder: (column) => column);

  GeneratedColumn<String> get remoteId =>
      $composableBuilder(column: $table.remoteId, builder: (column) => column);

  GeneratedColumn<String> get clubUuid =>
      $composableBuilder(column: $table.clubUuid, builder: (column) => column);

  GeneratedColumn<String> get action =>
      $composableBuilder(column: $table.action, builder: (column) => column);

  GeneratedColumn<String> get performedByRemoteId => $composableBuilder(
      column: $table.performedByRemoteId, builder: (column) => column);

  GeneratedColumn<String> get targetId =>
      $composableBuilder(column: $table.targetId, builder: (column) => column);

  GeneratedColumn<String> get reason =>
      $composableBuilder(column: $table.reason, builder: (column) => column);

  GeneratedColumn<bool> get isDirty =>
      $composableBuilder(column: $table.isDirty, builder: (column) => column);

  GeneratedColumn<DateTime> get syncedAt =>
      $composableBuilder(column: $table.syncedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$ReadingClubsTableAnnotationComposer get clubId {
    final $$ReadingClubsTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.clubId,
        referencedTable: $db.readingClubs,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$ReadingClubsTableAnnotationComposer(
              $db: $db,
              $table: $db.readingClubs,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }

  $$LocalUsersTableAnnotationComposer get performedByUserId {
    final $$LocalUsersTableAnnotationComposer composer = $composerBuilder(
        composer: this,
        getCurrentColumn: (t) => t.performedByUserId,
        referencedTable: $db.localUsers,
        getReferencedColumn: (t) => t.id,
        builder: (joinBuilder,
                {$addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer}) =>
            $$LocalUsersTableAnnotationComposer(
              $db: $db,
              $table: $db.localUsers,
              $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
              joinBuilder: joinBuilder,
              $removeJoinBuilderFromRootComposer:
                  $removeJoinBuilderFromRootComposer,
            ));
    return composer;
  }
}

class $$ModerationLogsTableTableManager extends RootTableManager<
    _$AppDatabase,
    $ModerationLogsTable,
    ModerationLog,
    $$ModerationLogsTableFilterComposer,
    $$ModerationLogsTableOrderingComposer,
    $$ModerationLogsTableAnnotationComposer,
    $$ModerationLogsTableCreateCompanionBuilder,
    $$ModerationLogsTableUpdateCompanionBuilder,
    (ModerationLog, $$ModerationLogsTableReferences),
    ModerationLog,
    PrefetchHooks Function({bool clubId, bool performedByUserId})> {
  $$ModerationLogsTableTableManager(
      _$AppDatabase db, $ModerationLogsTable table)
      : super(TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ModerationLogsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ModerationLogsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ModerationLogsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback: ({
            Value<int> id = const Value.absent(),
            Value<String> uuid = const Value.absent(),
            Value<String?> remoteId = const Value.absent(),
            Value<int> clubId = const Value.absent(),
            Value<String> clubUuid = const Value.absent(),
            Value<String> action = const Value.absent(),
            Value<int> performedByUserId = const Value.absent(),
            Value<String?> performedByRemoteId = const Value.absent(),
            Value<String> targetId = const Value.absent(),
            Value<String?> reason = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
          }) =>
              ModerationLogsCompanion(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            clubId: clubId,
            clubUuid: clubUuid,
            action: action,
            performedByUserId: performedByUserId,
            performedByRemoteId: performedByRemoteId,
            targetId: targetId,
            reason: reason,
            isDirty: isDirty,
            syncedAt: syncedAt,
            createdAt: createdAt,
          ),
          createCompanionCallback: ({
            Value<int> id = const Value.absent(),
            required String uuid,
            Value<String?> remoteId = const Value.absent(),
            required int clubId,
            required String clubUuid,
            required String action,
            required int performedByUserId,
            Value<String?> performedByRemoteId = const Value.absent(),
            required String targetId,
            Value<String?> reason = const Value.absent(),
            Value<bool> isDirty = const Value.absent(),
            Value<DateTime?> syncedAt = const Value.absent(),
            Value<DateTime> createdAt = const Value.absent(),
          }) =>
              ModerationLogsCompanion.insert(
            id: id,
            uuid: uuid,
            remoteId: remoteId,
            clubId: clubId,
            clubUuid: clubUuid,
            action: action,
            performedByUserId: performedByUserId,
            performedByRemoteId: performedByRemoteId,
            targetId: targetId,
            reason: reason,
            isDirty: isDirty,
            syncedAt: syncedAt,
            createdAt: createdAt,
          ),
          withReferenceMapper: (p0) => p0
              .map((e) => (
                    e.readTable(table),
                    $$ModerationLogsTableReferences(db, table, e)
                  ))
              .toList(),
          prefetchHooksCallback: ({clubId = false, performedByUserId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins: <
                  T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic>>(state) {
                if (clubId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.clubId,
                    referencedTable:
                        $$ModerationLogsTableReferences._clubIdTable(db),
                    referencedColumn:
                        $$ModerationLogsTableReferences._clubIdTable(db).id,
                  ) as T;
                }
                if (performedByUserId) {
                  state = state.withJoin(
                    currentTable: table,
                    currentColumn: table.performedByUserId,
                    referencedTable: $$ModerationLogsTableReferences
                        ._performedByUserIdTable(db),
                    referencedColumn: $$ModerationLogsTableReferences
                        ._performedByUserIdTable(db)
                        .id,
                  ) as T;
                }

                return state;
              },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ));
}

typedef $$ModerationLogsTableProcessedTableManager = ProcessedTableManager<
    _$AppDatabase,
    $ModerationLogsTable,
    ModerationLog,
    $$ModerationLogsTableFilterComposer,
    $$ModerationLogsTableOrderingComposer,
    $$ModerationLogsTableAnnotationComposer,
    $$ModerationLogsTableCreateCompanionBuilder,
    $$ModerationLogsTableUpdateCompanionBuilder,
    (ModerationLog, $$ModerationLogsTableReferences),
    ModerationLog,
    PrefetchHooks Function({bool clubId, bool performedByUserId})>;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$LocalUsersTableTableManager get localUsers =>
      $$LocalUsersTableTableManager(_db, _db.localUsers);
  $$BooksTableTableManager get books =>
      $$BooksTableTableManager(_db, _db.books);
  $$BookReviewsTableTableManager get bookReviews =>
      $$BookReviewsTableTableManager(_db, _db.bookReviews);
  $$ReadingTimelineEntriesTableTableManager get readingTimelineEntries =>
      $$ReadingTimelineEntriesTableTableManager(
          _db, _db.readingTimelineEntries);
  $$GroupsTableTableManager get groups =>
      $$GroupsTableTableManager(_db, _db.groups);
  $$GroupMembersTableTableManager get groupMembers =>
      $$GroupMembersTableTableManager(_db, _db.groupMembers);
  $$SharedBooksTableTableManager get sharedBooks =>
      $$SharedBooksTableTableManager(_db, _db.sharedBooks);
  $$GroupInvitationsTableTableManager get groupInvitations =>
      $$GroupInvitationsTableTableManager(_db, _db.groupInvitations);
  $$LoansTableTableManager get loans =>
      $$LoansTableTableManager(_db, _db.loans);
  $$InAppNotificationsTableTableManager get inAppNotifications =>
      $$InAppNotificationsTableTableManager(_db, _db.inAppNotifications);
  $$WishlistItemsTableTableManager get wishlistItems =>
      $$WishlistItemsTableTableManager(_db, _db.wishlistItems);
  $$ReadingClubsTableTableManager get readingClubs =>
      $$ReadingClubsTableTableManager(_db, _db.readingClubs);
  $$ClubMembersTableTableManager get clubMembers =>
      $$ClubMembersTableTableManager(_db, _db.clubMembers);
  $$ClubBooksTableTableManager get clubBooks =>
      $$ClubBooksTableTableManager(_db, _db.clubBooks);
  $$ClubReadingProgressTableTableManager get clubReadingProgress =>
      $$ClubReadingProgressTableTableManager(_db, _db.clubReadingProgress);
  $$BookProposalsTableTableManager get bookProposals =>
      $$BookProposalsTableTableManager(_db, _db.bookProposals);
  $$SectionCommentsTableTableManager get sectionComments =>
      $$SectionCommentsTableTableManager(_db, _db.sectionComments);
  $$CommentReportsTableTableManager get commentReports =>
      $$CommentReportsTableTableManager(_db, _db.commentReports);
  $$ModerationLogsTableTableManager get moderationLogs =>
      $$ModerationLogsTableTableManager(_db, _db.moderationLogs);
}
